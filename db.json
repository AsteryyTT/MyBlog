{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/archive_img.jpg","path":"img/archive_img.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/background.png","path":"img/background.png","modified":0,"renderable":0},{"_id":"source/img/cat.jpg","path":"img/cat.jpg","modified":0,"renderable":0},{"_id":"source/img/category_img.png","path":"img/category_img.png","modified":0,"renderable":0},{"_id":"source/img/category_per_img.png","path":"img/category_per_img.png","modified":0,"renderable":0},{"_id":"source/img/default_top_img.png","path":"img/default_top_img.png","modified":0,"renderable":0},{"_id":"source/img/tag_img.png","path":"img/tag_img.png","modified":0,"renderable":0},{"_id":"source/img/tag_per_img.jpg","path":"img/tag_per_img.jpg","modified":0,"renderable":0},{"_id":"source/img/wallhaven-jxwwgp.jpg","path":"img/wallhaven-jxwwgp.jpg","modified":0,"renderable":0},{"_id":"source/img/zy1.jpg","path":"img/zy1.jpg","modified":0,"renderable":0},{"_id":"source/img/images/IT.jpg","path":"img/images/IT.jpg","modified":0,"renderable":0},{"_id":"source/img/images/Internet.jpg","path":"img/images/Internet.jpg","modified":0,"renderable":0},{"_id":"source/img/images/Internet2.jpg","path":"img/images/Internet2.jpg","modified":0,"renderable":0},{"_id":"source/img/images/Java.jpg","path":"img/images/Java.jpg","modified":0,"renderable":0},{"_id":"source/img/images/Linux2.png","path":"img/images/Linux2.png","modified":0,"renderable":0},{"_id":"source/img/images/MySQL.jpg","path":"img/images/MySQL.jpg","modified":0,"renderable":0},{"_id":"source/img/images/Rabbit.png","path":"img/images/Rabbit.png","modified":0,"renderable":0},{"_id":"source/img/images/Spring.jpg","path":"img/images/Spring.jpg","modified":0,"renderable":0},{"_id":"source/img/images/computer.jpg","path":"img/images/computer.jpg","modified":0,"renderable":0},{"_id":"source/img/images/computer2.jpg","path":"img/images/computer2.jpg","modified":0,"renderable":0},{"_id":"source/img/images/computer3.jpg","path":"img/images/computer3.jpg","modified":0,"renderable":0},{"_id":"source/img/images/computer4.jpg","path":"img/images/computer4.jpg","modified":0,"renderable":0},{"_id":"source/img/images/docker.png","path":"img/images/docker.png","modified":0,"renderable":0},{"_id":"source/img/images/earth.png","path":"img/images/earth.png","modified":0,"renderable":0},{"_id":"source/img/images/linux.jpg","path":"img/images/linux.jpg","modified":0,"renderable":0},{"_id":"source/img/images/mesh.jpg","path":"img/images/mesh.jpg","modified":0,"renderable":0},{"_id":"source/img/images/mesh2.jpg","path":"img/images/mesh2.jpg","modified":0,"renderable":0},{"_id":"source/img/images/network.jpg","path":"img/images/network.jpg","modified":0,"renderable":0},{"_id":"source/img/images/nginx.jpg","path":"img/images/nginx.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/HTTP状态码.md","hash":"2d1d33735f71cf57ad67f7176bdde7251f323fea","modified":1691660222641},{"_id":"source/_posts/HTTP特点.md","hash":"5c55819311cc8119cc9a7c12c9837bea82a4ae49","modified":1691660201736},{"_id":"source/_posts/JAVA基础.md","hash":"00c693ec15f9f39876472d9648fed05726f1bf2b","modified":1691660929304},{"_id":"source/_posts/Docker.md","hash":"fd3a59928e4b4d2f00253d88f2c50618b75f151a","modified":1691661011182},{"_id":"source/_posts/JDBC.md","hash":"04500265094b9b67e5e8c62bcf299e30470645cb","modified":1691661024651},{"_id":"source/_posts/JavaAPI.md","hash":"ae035dc098f68ae8c2e32a60c8fd62ce3151e30d","modified":1691660935634},{"_id":"source/_posts/JavaScript.md","hash":"c72bca78d42a254129a7a4b1990d18e9308680b1","modified":1691660986691},{"_id":"source/_posts/Linux.md","hash":"12c7549b1bd15e0e8a8f37b5ac309689db438a04","modified":1691661032470},{"_id":"source/_posts/Nginx基础.md","hash":"3f1a6e810c893a4209c843f7714b7aa1bf2c558c","modified":1691661050561},{"_id":"source/_posts/MySQL.md","hash":"e77ccbd2e2a619189fb11e527f780103e54c03da","modified":1691661042688},{"_id":"source/_posts/RabbitMQ.md","hash":"e7afeeb3dddcf33146601fc15a16cfcb3275b0e2","modified":1691661056846},{"_id":"source/_posts/Typora快捷键大全.md","hash":"08459e1e710534598e2a7449e117959ae304f389","modified":1691653658090},{"_id":"source/_posts/Redis.md","hash":"325e2fbbf6e77cfa100bc18eeead1a73a2aff470","modified":1691661062868},{"_id":"source/_posts/SSM.md","hash":"7c86e79c0c168be133f01497040d883df403f063","modified":1691661069706},{"_id":"source/_posts/Spring.md","hash":"f389f4668f6184b2a1e95bf4dc1ae66ef46f3a56","modified":1691659225919},{"_id":"source/_posts/URL和URI的区别.md","hash":"76f31583fa0c663b8db3354084b65ddcec35a5ec","modified":1691653655019},{"_id":"source/_posts/XML.md","hash":"5d77143df668e72551ffb816aeeeb0ce0d92d078","modified":1691653652200},{"_id":"source/_posts/markdown基本语法.md","hash":"7ff22fa81b7d83f479abf6d3906fb97afa14669f","modified":1691653648256},{"_id":"source/_posts/代理模式.md","hash":"fd874a565582c1a6fd92a47640ffa10a9295c2ef","modified":1691660062463},{"_id":"source/_posts/前端.md","hash":"5a8f5d1d9108c76d2efb4b7d84f2247c455b56fb","modified":1691660965846},{"_id":"source/_posts/数据结构+算法.md","hash":"385b1b9499eadb5758f0912c18266c522dc5147d","modified":1691659366862},{"_id":"source/_posts/到底什么是CDN.md","hash":"3a4d5a098836c452048804c1a0fef9a5f97187b4","modified":1691660099762},{"_id":"source/_posts/浏览器输入地址后操作.md","hash":"21353e4495561c8225b635c6a82319bbfa373ce5","modified":1691659443402},{"_id":"source/archives/index.md","hash":"9460f2cb6f161e1846ddcdc84548163c40145b63","modified":1691652569988},{"_id":"source/categories/index.md","hash":"702dea93e6e8490d9fa1b348b7fe406809935012","modified":1691651704586},{"_id":"source/_posts/线程.md","hash":"c3cd27a9c2d688fd8379a79c8f38e7cda2e0076f","modified":1691660921125},{"_id":"source/_posts/集合.md","hash":"aa8ab4300e32df8134a54e7f511e9a564933e702","modified":1691660888998},{"_id":"source/_posts/面向对象.md","hash":"e7d426f6447ba9c00260d0d8c2eb414769c6c74a","modified":1691660902070},{"_id":"source/link/index.md","hash":"09e580581a0b3d6a0ee6383cb39c7dde0d0d9c77","modified":1691650395127},{"_id":"source/tags/index.md","hash":"4c65415e8cf0dc6880ea867f9f45091e3bae5228","modified":1691652599265},{"_id":"source/about/index.md","hash":"431db6c97bae1300afc36ea206381412ee4df67c","modified":1691660649802},{"_id":"source/img/images/nginx.jpg","hash":"7e02e60233e3180c23450a92a0dd6cbe9a038da0","modified":1691660726994},{"_id":"source/img/images/computer.jpg","hash":"1e9af0761d939181f62d1eb4325af175db5aaa20","modified":1691659738646},{"_id":"source/img/images/Internet.jpg","hash":"61704269dba5d56cf44609e4d8af55e8274d7a2c","modified":1691658500723},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"656d8b548940d7d214459cd8853007af38e6c465","modified":1691631728411},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1691631728278},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1691631728415},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1691631728626},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1691631728636},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1691631728414},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1691631728639},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1691631728634},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1691631728540},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1691631728632},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1691631728495},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1691631728475},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1691631728531},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1691631728572},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1691631728631},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1691631728633},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1691631728635},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1691631728632},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1691631728636},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1691631728547},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1691631728630},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1691631728418},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1691631728511},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1691631728532},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1691631728522},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1691631728567},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1691631728368},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1691631728468},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1691631728380},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1691631728388},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1691631728568},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1691631728381},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1691631728410},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1691631728404},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1691631728401},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1691631728402},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1691631728382},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1691631728376},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1691631728378},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1691631728540},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1691631728399},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1691631728403},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1691631728379},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1691631728396},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1691631728385},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1691631728389},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1691631728387},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1691631728391},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1691631728386},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1691631728404},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1691631728397},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1691631728405},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1691631728406},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1691631728606},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1691631728391},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1691631728367},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1691631728625},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1691631728395},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1691631728539},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1691631728365},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1691631728410},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1691631728409},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1691631728522},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1691631728416},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1691631728496},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1691631728473},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1691631728498},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1691631728570},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1691631728552},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1691631728538},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1691631728547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1691631728539},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1691631728570},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1691631728535},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1691631728525},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1691631728540},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1691631728543},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1691631728524},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1691631728514},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1691631728494},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1691631728482},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1691631728572},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1691631728546},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1691631728510},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1691631728565},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1691631728474},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1691631728502},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1691631728541},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1691631728550},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1691631728508},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1691631728542},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1691631728483},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1691631728484},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1691631728571},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1691631728486},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1691631728486},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1691631728489},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1691631728488},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1691631728486},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1691631728492},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1691631728490},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1691631728491},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1691631728492},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1691631728531},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1691631728604},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1691631728596},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1691631728602},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1691631728543},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1691631728588},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1691631728489},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1691631728621},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1691631728586},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1691631728589},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1691631728595},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1691631728600},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1691631728612},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1691631728615},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1691631728615},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1691631728617},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1691631728618},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1691631728618},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1691631728621},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1691631728616},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1691631728619},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1691631728591},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1691631728584},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1691631728588},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1691631728590},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1691631728620},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1691631728585},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1691631728595},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1691631728603},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1691631728606},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1691631728584},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1691631728612},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1691631728600},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1691631728588},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1691631728607},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1691631728608},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1691631728599},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1691631728601},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1691631728620},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1691631728614},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1691631728624},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1691631728279},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1691631728419},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1691631728525},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1691631728374},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1691631728505},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1691631728526},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1691631728394},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1691631728552},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1691631728476},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1691631728575},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1691631728509},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1691631728581},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1691631728578},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1691631728526},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1691631728496},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1691631728500},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1691631728499},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1691631728574},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1691631728538},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1691631728479},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1691631728506},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1691631728506},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1691631728516},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1691631728509},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1691631728519},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1691631728528},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1691631728532},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1691631728533},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1691631728553},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1691631728578},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1691631728578},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1691631728528},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1691631728579},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1691631728532},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1691631728582},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1691631728535},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1691631728534},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1691631728504},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1691631728481},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1691631728519},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1691631728528},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1691631728574},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1691631728563},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1691631728471},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1691631728581},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1691631728530},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1691631728582},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1691631728530},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1691631728508},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1691631728469},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1691631728420},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1691631728568},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1691631728605},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1691631728534},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1691631728594},{"_id":"source/img/images/Linux2.png","hash":"4e6220aa3fc0a5a8cdd83d013ed33a08c48e73de","modified":1691658402145},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1691631728605},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1691631728611},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1691631728593},{"_id":"source/img/zy1.jpg","hash":"07ba2bdd0ad80fa7dae6584ecc66378a5eab36ea","modified":1681272440538},{"_id":"source/img/images/docker.png","hash":"06b2fb0f27690d87f76a0ce3f09a8d8321a2d725","modified":1691657893113},{"_id":"source/img/avatar.png","hash":"12539c17e6481a75da25dacb8c1f7f4ae8ce7f20","modified":1691635019178},{"_id":"source/img/images/IT.jpg","hash":"41f3ff39f1fbdd88ff659d7d7dd68ac291c47a20","modified":1691659704442},{"_id":"source/img/images/Rabbit.png","hash":"e683a3ffb73f941c75eb84b31eda5796857df9a5","modified":1691658202147},{"_id":"source/img/images/linux.jpg","hash":"68e4b3fda8e3da4a930f71ba893edf3ff60ca741","modified":1691658376035},{"_id":"source/img/images/network.jpg","hash":"62a73270232a6be484511611a4ccfa3bcf50b0f1","modified":1691658457083},{"_id":"source/img/images/computer3.jpg","hash":"a5bb0c401db3e1c1cf92eb14f788d269871f63c7","modified":1691659780921},{"_id":"source/img/cat.jpg","hash":"ae8930b4de5b1939733fecafa320d4cb16dc80e9","modified":1687234846875},{"_id":"source/img/images/mesh.jpg","hash":"6be4da4644a56c08ce5d4f4b8bd8877e2b7ce149","modified":1691659992373},{"_id":"source/img/images/Java.jpg","hash":"ab1b4378838747d6c32e2e8fdb37543ff5a682d6","modified":1691658081545},{"_id":"source/img/images/mesh2.jpg","hash":"4e8f93abc6c2ecb27fa0b375f0b071e2095d3845","modified":1691660014340},{"_id":"source/img/images/computer4.jpg","hash":"2c327a0be90db4cf3d0a34bef02f207d29ffe1aa","modified":1691659799900},{"_id":"source/img/images/Spring.jpg","hash":"93fdd0fc5e8277c6ab6625ecb1624f2361045308","modified":1691658284274},{"_id":"source/img/images/Internet2.jpg","hash":"7d4b30d9158877fb17915ba46ebffb9d7cb01e9b","modified":1691658523914},{"_id":"source/img/tag_per_img.jpg","hash":"cb127f4aae1c6b5a3fb3d0960a61ae3e4798d5e5","modified":1678554614139},{"_id":"source/img/background.png","hash":"e64dcacb5308f5648f7f9a2fac41d06630d6ca72","modified":1654257054170},{"_id":"source/img/wallhaven-jxwwgp.jpg","hash":"404fc50410f42a065fd674f53ed2ff691de638ee","modified":1678554606450},{"_id":"source/img/archive_img.jpg","hash":"f55503504a362eae9262594c2da545284d7cd5f3","modified":1678554610564},{"_id":"source/img/images/computer2.jpg","hash":"7e387b368503811e392a94cf6080fd18fb3b4c32","modified":1691659760868},{"_id":"source/img/images/MySQL.jpg","hash":"ca323e1d0c27779c0674a4e50ca89dadd7f48278","modified":1691658050054},{"_id":"source/img/category_per_img.png","hash":"68748b6178fd77bfd0681258c431fbdc8433fd0d","modified":1676948420285},{"_id":"source/img/category_img.png","hash":"a02e309e73d0dff62298c82dd66324b23beb99c7","modified":1676948401963},{"_id":"source/img/images/earth.png","hash":"d54d8175d33abe194c11d7c171d02576bbad6081","modified":1691659645597},{"_id":"source/img/tag_img.png","hash":"27c049664ae185a13ea5a7d9dce0a1b20bb0f345","modified":1678546157788},{"_id":"source/img/default_top_img.png","hash":"86dbf5167e8ec9abe75a31f1b6ab1944ce607ed2","modified":1678546242554},{"_id":"public/archives/index.html","hash":"bfd63002f2d914f42e1ea80acd1c286770d2316a","modified":1691670126598},{"_id":"public/categories/index.html","hash":"dc1917d49ec7a01f762a379fe9b8ef3bde6b7869","modified":1691670126598},{"_id":"public/about/index.html","hash":"03931f743d4567234dfddee7011b737f0146a31f","modified":1691670126598},{"_id":"public/tags/index.html","hash":"f3e7c5cfdfd3e891ed37e0db99656547a41c2629","modified":1691670126598},{"_id":"public/link/index.html","hash":"b06784c154d11ef202305c1fc612d099bd67307c","modified":1691670126598},{"_id":"public/2023/07/12/Redis/index.html","hash":"a47a6c6b936b33f908cdb12a6b07b7f34a36d8a2","modified":1691670126598},{"_id":"public/2023/06/18/RabbitMQ/index.html","hash":"349e154e7de98c5f1223a69e828af18223793d3d","modified":1691670126598},{"_id":"public/2023/05/16/Nginx基础/index.html","hash":"c3208ea9ff16f30ccb611149d547a6fbfa787fff","modified":1691670126598},{"_id":"public/2023/04/18/Linux/index.html","hash":"7bb7bac6fecb867ceba92d05a2590ff54fe0051c","modified":1691670126598},{"_id":"public/2023/03/19/Docker/index.html","hash":"07fe6da955bb89fac55e34cec2be0ecd13c88936","modified":1691670126598},{"_id":"public/2023/03/15/SSM/index.html","hash":"68f7608a267559c6f0df458c9c9e34e3b9e89fa3","modified":1691670126598},{"_id":"public/2023/03/12/Spring/index.html","hash":"4649747012208054c2302292020d9d1bda9b77ed","modified":1691670126598},{"_id":"public/2023/03/12/代理模式/index.html","hash":"c553b4d936c55c5e2d240b49263a7e8d22d473c4","modified":1691670126598},{"_id":"public/2023/03/12/数据结构+算法/index.html","hash":"ac2f802c8afa202830127793b68ca6aa59ced427","modified":1691670126598},{"_id":"public/2023/03/12/浏览器输入地址后操作/index.html","hash":"1b06b45a7b921da298df38574308f4ba79f684e3","modified":1691670126598},{"_id":"public/2023/02/25/MySQL/index.html","hash":"b70c844cee62174bd1a0af973ab6592d9da1b558","modified":1691670126598},{"_id":"public/2023/02/02/JDBC/index.html","hash":"5ab50896862a3b232246bf35f431318b14945f75","modified":1691670126598},{"_id":"public/2023/01/15/线程/index.html","hash":"a58a5a34f345ac6917a5f13ca63ff3d7a23308db","modified":1691670126598},{"_id":"public/2023/01/10/集合/index.html","hash":"59da89f5b0d5180a66ed028a82fd1c9800328390","modified":1691670126598},{"_id":"public/2023/01/07/面向对象/index.html","hash":"e260c5ed94a2b8a557322214ade662e2ae0ce67d","modified":1691670126598},{"_id":"public/2023/01/06/JavaAPI/index.html","hash":"3024604b952910b48abbc4c7a1ee72dbd303e971","modified":1691670126598},{"_id":"public/2023/01/05/JAVA基础/index.html","hash":"9b57e35d93c4dfbc0adb108e91202ab075a3c399","modified":1691670126598},{"_id":"public/2022/08/28/JavaScript/index.html","hash":"984e5e795fa88dea4001dcbbc8ae5e2daa3b7428","modified":1691670126598},{"_id":"public/2022/08/22/前端/index.html","hash":"e329ed5c2a81a031933acbfebddc9cae64770f0b","modified":1691670126598},{"_id":"public/2022/08/18/XML/index.html","hash":"2cdfca422f6c12293e9427e71395fcec5ee9eeac","modified":1691670126598},{"_id":"public/2022/08/15/Typora快捷键大全/index.html","hash":"54ebabc532dd00dfc0951cc7117b5024548b70f4","modified":1691670126598},{"_id":"public/2022/07/20/markdown基本语法/index.html","hash":"468efc63f62ff814971e84d541135b82cf43a492","modified":1691670126598},{"_id":"public/2022/07/18/到底什么是CDN/index.html","hash":"5e8f8a559623feb856a725fc3b994f5836a84cf5","modified":1691670126598},{"_id":"public/2022/07/15/URL和URI的区别/index.html","hash":"b2d23d0719f50340c085225db140d2bbc889b89f","modified":1691670126598},{"_id":"public/2022/07/12/HTTP状态码/index.html","hash":"5417d412ca57b3a4516b77653e30f32055f61a96","modified":1691670126598},{"_id":"public/2022/07/10/HTTP特点/index.html","hash":"9a18029906075cf39684f410ee808df0ff6a3b97","modified":1691670126598},{"_id":"public/文章/index.html","hash":"3f269ec806bc0eeb5c1529b6eac5f4b62122177f","modified":1691670126598},{"_id":"public/文章/page/2/index.html","hash":"5a2e9f8462ee44da874c8883ea1c6f3a14117abe","modified":1691670126598},{"_id":"public/文章/page/3/index.html","hash":"52164e3bf78b2de44752621f864674d047b20377","modified":1691670126598},{"_id":"public/文章/2022/index.html","hash":"3237162f6d73f19e70ceb2b68eda2309473f7efc","modified":1691670126598},{"_id":"public/文章/2022/07/index.html","hash":"fa8623509795a949e08581e144e6810be15676b2","modified":1691670126598},{"_id":"public/文章/2022/08/index.html","hash":"4e12a62adf99f4e6822997990448153055c847f6","modified":1691670126598},{"_id":"public/文章/2023/index.html","hash":"7f6992012eccd5fc4e067e1a09f3c54174f31f18","modified":1691670126598},{"_id":"public/文章/2023/page/2/index.html","hash":"ca347b845d5056dd35edeac20f9f17b37530c90c","modified":1691670126598},{"_id":"public/文章/2023/01/index.html","hash":"81b16bb90e6394179dddfaa673351f9b320bc44b","modified":1691670126598},{"_id":"public/文章/2023/02/index.html","hash":"06ea7c21441ed908b9f726cd959b75fa98551905","modified":1691670126598},{"_id":"public/文章/2023/03/index.html","hash":"a49a16211e9fbd80af10da938021e7d5b0c84fb1","modified":1691670126598},{"_id":"public/文章/2023/04/index.html","hash":"ab67bf10d68add6e8dac08bb496e82a1ac142857","modified":1691670126598},{"_id":"public/文章/2023/05/index.html","hash":"037022045fe97700c6b81b589cb0e1c4dda75375","modified":1691670126598},{"_id":"public/文章/2023/06/index.html","hash":"79c440367626ba34b499a9b54561fdb456c2179f","modified":1691670126598},{"_id":"public/文章/2023/07/index.html","hash":"36b3b0270228aea46dd0d4173afb9d015e1a8d81","modified":1691670126598},{"_id":"public/index.html","hash":"398b4b13fa4242ca9771d62e34e45181b50d1977","modified":1691670126598},{"_id":"public/page/2/index.html","hash":"cc705de36043af4f05ad6644d93ca41965933a3d","modified":1691670126598},{"_id":"public/page/3/index.html","hash":"908a47e091e7f231ab4623e7dffd835da2b9082d","modified":1691670126598},{"_id":"public/分类/中间件/index.html","hash":"5e00109cbc1ab629be7e9dd3f97d6e2b63b5d16f","modified":1691670126598},{"_id":"public/分类/网络/index.html","hash":"9e8f9e6935596e84e93187561c9c36903d77a719","modified":1691670126598},{"_id":"public/分类/Java/index.html","hash":"b405c8fb10f493254a4b56c84d200e449808c22b","modified":1691670126598},{"_id":"public/分类/Linux/index.html","hash":"201b8e703f99ae3d37b69eddea6fc30cfb5b8c20","modified":1691670126598},{"_id":"public/分类/前端/index.html","hash":"ef13ab85b75372785f7cfb30f19ff6fc4cd5d9ea","modified":1691670126598},{"_id":"public/分类/数据库/index.html","hash":"91a0405b1599cf05644ed2d827d3b4330f42110b","modified":1691670126598},{"_id":"public/分类/框架/index.html","hash":"638422673356b61591255df8d7be2da3cb9fa4b8","modified":1691670126598},{"_id":"public/分类/计算机学习/index.html","hash":"65f59bd24a7c12d173eda7412fee8a25111e8150","modified":1691670126598},{"_id":"public/分类/设计模式/index.html","hash":"53edd4eab8db07176697a85bbd7d3abcbf177584","modified":1691670126598},{"_id":"public/标签/中间件/index.html","hash":"e493416a3db4897bedfc636ca407af8dfd8fb4f7","modified":1691670126598},{"_id":"public/标签/网络/index.html","hash":"1fed51e688f14576179dc24aca44c569bd758cbf","modified":1691670126598},{"_id":"public/标签/Java/index.html","hash":"7b1c81f894c4a840b503453aefd22743504d0bc2","modified":1691670126598},{"_id":"public/标签/Linux/index.html","hash":"e9b6cd181d0d22aa959f8e27559df717fc0aafea","modified":1691670126598},{"_id":"public/标签/前端/index.html","hash":"4f0242b2cf3c9f9760779fe6ef384f0297cc0584","modified":1691670126598},{"_id":"public/标签/数据库/index.html","hash":"7c49bf2aa5983f1a175d9b2e22b05f3fb6d80c13","modified":1691670126598},{"_id":"public/标签/框架/index.html","hash":"38d6fbb913ba78fabc43ed88ae54422a56871e26","modified":1691670126598},{"_id":"public/标签/计算机学习/index.html","hash":"9040c20d0ec8850029dd0cd1c2448bd53066f4b5","modified":1691670126598},{"_id":"public/标签/设计模式/index.html","hash":"72427bc34a0a5bdd9e90a26315ff5ee62f83c4ae","modified":1691670126598},{"_id":"public/标签/数据结构/index.html","hash":"263338678ca621fdbaac72151e43e920ec5f54aa","modified":1691670126598},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1691670126598},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1691670126598},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1691670126598},{"_id":"public/img/images/nginx.jpg","hash":"7e02e60233e3180c23450a92a0dd6cbe9a038da0","modified":1691670126598},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1691670126598},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1691670126598},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1691670126598},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1691670126598},{"_id":"public/live2dw/assets/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1691670126598},{"_id":"public/live2dw/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1691670126598},{"_id":"public/live2dw/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1691670126598},{"_id":"public/live2dw/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1691670126598},{"_id":"public/live2dw/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1691670126598},{"_id":"public/live2dw/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1691670126598},{"_id":"public/live2dw/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1691670126598},{"_id":"public/live2dw/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1691670126598},{"_id":"public/live2dw/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1691670126598},{"_id":"public/live2dw/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1691670126598},{"_id":"public/live2dw/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1691670126598},{"_id":"public/live2dw/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1691670126598},{"_id":"public/live2dw/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1691670126598},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1691670126598},{"_id":"public/img/images/computer.jpg","hash":"1e9af0761d939181f62d1eb4325af175db5aaa20","modified":1691670126598},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1691670126598},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1691670126598},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1691670126598},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1691670126598},{"_id":"public/css/index.css","hash":"1d59e26f63c5f7a34b384640f6885ca1c017d534","modified":1691670126598},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1691670126598},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1691670126598},{"_id":"public/live2dw/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1691670126598},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1691670126598},{"_id":"public/img/images/Internet.jpg","hash":"61704269dba5d56cf44609e4d8af55e8274d7a2c","modified":1691670126598},{"_id":"public/img/images/Linux2.png","hash":"4e6220aa3fc0a5a8cdd83d013ed33a08c48e73de","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1691670126598},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1691670126598},{"_id":"public/img/zy1.jpg","hash":"07ba2bdd0ad80fa7dae6584ecc66378a5eab36ea","modified":1691670126598},{"_id":"public/img/images/docker.png","hash":"06b2fb0f27690d87f76a0ce3f09a8d8321a2d725","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1691670126598},{"_id":"public/img/avatar.png","hash":"12539c17e6481a75da25dacb8c1f7f4ae8ce7f20","modified":1691670126598},{"_id":"public/img/images/IT.jpg","hash":"41f3ff39f1fbdd88ff659d7d7dd68ac291c47a20","modified":1691670126598},{"_id":"public/img/images/Rabbit.png","hash":"e683a3ffb73f941c75eb84b31eda5796857df9a5","modified":1691670126598},{"_id":"public/img/images/linux.jpg","hash":"68e4b3fda8e3da4a930f71ba893edf3ff60ca741","modified":1691670126598},{"_id":"public/img/images/network.jpg","hash":"62a73270232a6be484511611a4ccfa3bcf50b0f1","modified":1691670126598},{"_id":"public/img/images/computer3.jpg","hash":"a5bb0c401db3e1c1cf92eb14f788d269871f63c7","modified":1691670126598},{"_id":"public/img/images/mesh.jpg","hash":"6be4da4644a56c08ce5d4f4b8bd8877e2b7ce149","modified":1691670126598},{"_id":"public/img/cat.jpg","hash":"ae8930b4de5b1939733fecafa320d4cb16dc80e9","modified":1691670126598},{"_id":"public/img/images/Java.jpg","hash":"ab1b4378838747d6c32e2e8fdb37543ff5a682d6","modified":1691670126598},{"_id":"public/img/images/mesh2.jpg","hash":"4e8f93abc6c2ecb27fa0b375f0b071e2095d3845","modified":1691670126598},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1691670126598},{"_id":"public/img/images/computer4.jpg","hash":"2c327a0be90db4cf3d0a34bef02f207d29ffe1aa","modified":1691670126598},{"_id":"public/live2dw/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1691670126598},{"_id":"public/img/images/Spring.jpg","hash":"93fdd0fc5e8277c6ab6625ecb1624f2361045308","modified":1691670126598},{"_id":"public/img/images/Internet2.jpg","hash":"7d4b30d9158877fb17915ba46ebffb9d7cb01e9b","modified":1691670126598},{"_id":"public/img/tag_per_img.jpg","hash":"cb127f4aae1c6b5a3fb3d0960a61ae3e4798d5e5","modified":1691670126598},{"_id":"public/img/background.png","hash":"e64dcacb5308f5648f7f9a2fac41d06630d6ca72","modified":1691670126598},{"_id":"public/img/archive_img.jpg","hash":"f55503504a362eae9262594c2da545284d7cd5f3","modified":1691670126598},{"_id":"public/img/images/MySQL.jpg","hash":"ca323e1d0c27779c0674a4e50ca89dadd7f48278","modified":1691670126598},{"_id":"public/img/wallhaven-jxwwgp.jpg","hash":"404fc50410f42a065fd674f53ed2ff691de638ee","modified":1691670126598},{"_id":"public/img/images/computer2.jpg","hash":"7e387b368503811e392a94cf6080fd18fb3b4c32","modified":1691670126598},{"_id":"public/img/images/earth.png","hash":"d54d8175d33abe194c11d7c171d02576bbad6081","modified":1691670126598},{"_id":"public/img/category_per_img.png","hash":"68748b6178fd77bfd0681258c431fbdc8433fd0d","modified":1691670126598},{"_id":"public/img/category_img.png","hash":"a02e309e73d0dff62298c82dd66324b23beb99c7","modified":1691670126598},{"_id":"public/img/default_top_img.png","hash":"86dbf5167e8ec9abe75a31f1b6ab1944ce607ed2","modified":1691670126598},{"_id":"public/img/tag_img.png","hash":"27c049664ae185a13ea5a7d9dce0a1b20bb0f345","modified":1691670126598}],"Category":[{"name":"中间件","_id":"cll54pw8z0004fswo3iabhr04"},{"name":"网络","_id":"cll54pw97000cfswogmdpayo0"},{"name":"Java","_id":"cll54pw9h000nfswoa897b68l"},{"name":"Linux","_id":"cll54pw9s0019fswod17n2lke"},{"name":"前端","_id":"cll54pw9v001ifswodcykaqdx"},{"name":"数据库","_id":"cll54pw9z001rfswo2pmk8z0w"},{"name":"框架","_id":"cll54pwa6001yfswoh4mg7ntu"},{"name":"计算机学习","_id":"cll54pwa70024fswod3tq2loo"},{"name":"设计模式","_id":"cll54pwab002kfswohhtp1ybe"}],"Data":[],"Page":[{"title":"归档","date":"2023-08-10T06:51:57.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: 归档\ndate: 2023-08-10 14:51:57\ntype: \"archives\"\n---\n","updated":"2023-08-10T07:29:29.988Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cll54pw8o0000fswo044ca5b6","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"分类","date":"2023-08-10T06:53:01.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-08-10 14:53:01\ntype: \"categories\"\n---\n","updated":"2023-08-10T07:15:04.586Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cll54pw8v0002fswo6has1w6s","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"关于","date":"2023-03-12T03:26:49.000Z","type":"about","top_img":"/img/cat.jpg","_content":"- - -\n## <center>个人信息\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;☎️手机：15336261319 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;📧邮箱：2384395814@qq.com &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🏠地址：陕西省安康市</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;✈️求职意向:&ensp;&ensp;Java软件开发</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🌈爱好:&ensp;&ensp;素描&ensp;&ensp;&ensp;&ensp;游戏&ensp;&ensp;&ensp;&ensp;</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🎬本人也是一名老二次元选手也偶尔看看科普视频让自己的知识面更广泛</div>\n\n- - -\n## <center>个人技能\n 1.\t熟练掌握Java基础,有良好的编码习惯\n2.\t熟练掌握Spring、SpringMVC、SpringBoot框架的应用开发\n3.\t熟悉使用MySQL的常用SQL语句、采用Mybatis整合dao层提高工作效率\n4.\t熟悉使用Redis缓存以及Shiro安全框架\n5.\t熟悉使用Linux的常用命令，已经java项目的部署、团队开发时使用Git配合组员开发、Maven版本控制工具\n6.\t了解RabbitMQ的六种模式\n \n- - -\n## <center>关于本站\n- 采用的是Hexo博客框架\n- 代码托管平台gitee\n- Hexo博客主题Butterfly\n- - -\n\n## <center>技能证书\n\n- - -\n\n## <center>工作经历\n\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-03-12 11:26:49\ntype: \"about\"\ntop_img: /img/cat.jpg\n---\n- - -\n## <center>个人信息\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;☎️手机：15336261319 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;📧邮箱：2384395814@qq.com &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🏠地址：陕西省安康市</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;✈️求职意向:&ensp;&ensp;Java软件开发</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🌈爱好:&ensp;&ensp;素描&ensp;&ensp;&ensp;&ensp;游戏&ensp;&ensp;&ensp;&ensp;</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🎬本人也是一名老二次元选手也偶尔看看科普视频让自己的知识面更广泛</div>\n\n- - -\n## <center>个人技能\n 1.\t熟练掌握Java基础,有良好的编码习惯\n2.\t熟练掌握Spring、SpringMVC、SpringBoot框架的应用开发\n3.\t熟悉使用MySQL的常用SQL语句、采用Mybatis整合dao层提高工作效率\n4.\t熟悉使用Redis缓存以及Shiro安全框架\n5.\t熟悉使用Linux的常用命令，已经java项目的部署、团队开发时使用Git配合组员开发、Maven版本控制工具\n6.\t了解RabbitMQ的六种模式\n \n- - -\n## <center>关于本站\n- 采用的是Hexo博客框架\n- 代码托管平台gitee\n- Hexo博客主题Butterfly\n- - -\n\n## <center>技能证书\n\n- - -\n\n## <center>工作经历\n\n\n\n","updated":"2023-08-10T09:44:09.802Z","path":"about/index.html","comments":1,"layout":"page","_id":"cll54pw910006fswo6segev3f","content":"<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a><center>个人信息</h2><div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;☎️手机：15336261319 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;📧邮箱：2384395814@qq.com &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🏠地址：陕西省安康市</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;✈️求职意向:&ensp;&ensp;Java软件开发</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🌈爱好:&ensp;&ensp;素描&ensp;&ensp;&ensp;&ensp;游戏&ensp;&ensp;&ensp;&ensp;</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🎬本人也是一名老二次元选手也偶尔看看科普视频让自己的知识面更广泛</div>\n\n<hr>\n<h2 id=\"个人技能\"><a href=\"#个人技能\" class=\"headerlink\" title=\"个人技能\"></a><center>个人技能</h2><ol>\n<li>   熟练掌握Java基础,有良好的编码习惯</li>\n<li>   熟练掌握Spring、SpringMVC、SpringBoot框架的应用开发</li>\n<li>   熟悉使用MySQL的常用SQL语句、采用Mybatis整合dao层提高工作效率</li>\n<li>   熟悉使用Redis缓存以及Shiro安全框架</li>\n<li>   熟悉使用Linux的常用命令，已经java项目的部署、团队开发时使用Git配合组员开发、Maven版本控制工具</li>\n<li>   了解RabbitMQ的六种模式</li>\n</ol>\n<hr>\n<h2 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a><center>关于本站</h2><ul>\n<li>采用的是Hexo博客框架</li>\n<li>代码托管平台gitee</li>\n<li>Hexo博客主题Butterfly</li>\n</ul>\n<hr>\n<h2 id=\"技能证书\"><a href=\"#技能证书\" class=\"headerlink\" title=\"技能证书\"></a><center>技能证书</h2><hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a><center>工作经历</h2>","site":{"data":{}},"cover":false,"excerpt":"","more":"<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a><center>个人信息</h2><div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;☎️手机：15336261319 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;📧邮箱：2384395814@qq.com &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🏠地址：陕西省安康市</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;✈️求职意向:&ensp;&ensp;Java软件开发</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🌈爱好:&ensp;&ensp;素描&ensp;&ensp;&ensp;&ensp;游戏&ensp;&ensp;&ensp;&ensp;</div>\n<div>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;🎬本人也是一名老二次元选手也偶尔看看科普视频让自己的知识面更广泛</div>\n\n<hr>\n<h2 id=\"个人技能\"><a href=\"#个人技能\" class=\"headerlink\" title=\"个人技能\"></a><center>个人技能</h2><ol>\n<li>   熟练掌握Java基础,有良好的编码习惯</li>\n<li>   熟练掌握Spring、SpringMVC、SpringBoot框架的应用开发</li>\n<li>   熟悉使用MySQL的常用SQL语句、采用Mybatis整合dao层提高工作效率</li>\n<li>   熟悉使用Redis缓存以及Shiro安全框架</li>\n<li>   熟悉使用Linux的常用命令，已经java项目的部署、团队开发时使用Git配合组员开发、Maven版本控制工具</li>\n<li>   了解RabbitMQ的六种模式</li>\n</ol>\n<hr>\n<h2 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a><center>关于本站</h2><ul>\n<li>采用的是Hexo博客框架</li>\n<li>代码托管平台gitee</li>\n<li>Hexo博客主题Butterfly</li>\n</ul>\n<hr>\n<h2 id=\"技能证书\"><a href=\"#技能证书\" class=\"headerlink\" title=\"技能证书\"></a><center>技能证书</h2><hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a><center>工作经历</h2>"},{"title":"标签","date":"2023-03-11T16:53:45.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-03-12 00:53:45\ntype: \"tags\"\n---\n","updated":"2023-08-10T07:29:59.265Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cll54pw940008fswofx3898xu","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"link","date":"2023-08-10T06:53:15.000Z","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-08-10 14:53:15\n---\n","updated":"2023-08-10T06:53:15.127Z","path":"link/index.html","comments":1,"layout":"page","_id":"cll54pw95000afswo7i0rf525","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"Docker","date":"2023-03-19T03:18:57.000Z","cover":"/img/images/docker.png","_content":"\n# Docker\n\n## Docker容器技术\n\nDocker是一门平台级别的技术\n\n\n\n### Docker安装和部署\n\n在服务器上安装各种各样的环境需要花费很多时间，有了Docker以后我只需要将这些环境打包成一个镜像，就可以实现一键部署了\n\n卸载旧版本\n\n> ```\n>  sudo yum remove docker \\\n>                   docker-client \\\n>                   docker-client-latest \\\n>                   docker-common \\\n>                   docker-latest \\\n>                   docker-latest-logrotate \\\n>                   docker-logrotate \\\n>                   docker-engine\n> ```\n\n> ```\n> sudo yum install -y yum-utils\n> \n> $ sudo yum-config-manager \\\n>     --add-repo \\\n>     https://download.docker.com/linux/centos/docker-ce.repo\n> ```\n\n> ```\n> sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n> ```\n\n> ```\n> sudo systemctl start docker\n> ```\n\n> ```\n>  sudo docker run hello-world\n> ```\n\n\n\n### 容器与镜像\n\n\n\n### 容器网络管理\n\n\n\n### 容器存储管理\n\n\n\n### 容器资源管理\n\n\n\n\n\ndocker命令\n\nsystemctl start docker\n\nsystemctl restart docker \n\nsystemctl status docker\n\ndocker images\n\nsystemctl enable docker\n\nsystemctl stop docker","source":"_posts/Docker.md","raw":"---\ntitle: Docker\ndate: 2023-03-19 11:18:57\ntags: 中间件\ncategories: 中间件\ncover: /img/images/docker.png\n---\n\n# Docker\n\n## Docker容器技术\n\nDocker是一门平台级别的技术\n\n\n\n### Docker安装和部署\n\n在服务器上安装各种各样的环境需要花费很多时间，有了Docker以后我只需要将这些环境打包成一个镜像，就可以实现一键部署了\n\n卸载旧版本\n\n> ```\n>  sudo yum remove docker \\\n>                   docker-client \\\n>                   docker-client-latest \\\n>                   docker-common \\\n>                   docker-latest \\\n>                   docker-latest-logrotate \\\n>                   docker-logrotate \\\n>                   docker-engine\n> ```\n\n> ```\n> sudo yum install -y yum-utils\n> \n> $ sudo yum-config-manager \\\n>     --add-repo \\\n>     https://download.docker.com/linux/centos/docker-ce.repo\n> ```\n\n> ```\n> sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n> ```\n\n> ```\n> sudo systemctl start docker\n> ```\n\n> ```\n>  sudo docker run hello-world\n> ```\n\n\n\n### 容器与镜像\n\n\n\n### 容器网络管理\n\n\n\n### 容器存储管理\n\n\n\n### 容器资源管理\n\n\n\n\n\ndocker命令\n\nsystemctl start docker\n\nsystemctl restart docker \n\nsystemctl status docker\n\ndocker images\n\nsystemctl enable docker\n\nsystemctl stop docker","slug":"Docker","published":1,"updated":"2023-08-10T09:50:11.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw8r0001fswogladhsvn","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"Docker容器技术\"><a href=\"#Docker容器技术\" class=\"headerlink\" title=\"Docker容器技术\"></a>Docker容器技术</h2><p>Docker是一门平台级别的技术</p>\n<h3 id=\"Docker安装和部署\"><a href=\"#Docker安装和部署\" class=\"headerlink\" title=\"Docker安装和部署\"></a>Docker安装和部署</h3><p>在服务器上安装各种各样的环境需要花费很多时间，有了Docker以后我只需要将这些环境打包成一个镜像，就可以实现一键部署了</p>\n<p>卸载旧版本</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                 docker-client \\</span><br><span class=\"line\">                 docker-client-latest \\</span><br><span class=\"line\">                 docker-common \\</span><br><span class=\"line\">                 docker-latest \\</span><br><span class=\"line\">                 docker-latest-logrotate \\</span><br><span class=\"line\">                 docker-logrotate \\</span><br><span class=\"line\">                 docker-engine</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"容器与镜像\"><a href=\"#容器与镜像\" class=\"headerlink\" title=\"容器与镜像\"></a>容器与镜像</h3><h3 id=\"容器网络管理\"><a href=\"#容器网络管理\" class=\"headerlink\" title=\"容器网络管理\"></a>容器网络管理</h3><h3 id=\"容器存储管理\"><a href=\"#容器存储管理\" class=\"headerlink\" title=\"容器存储管理\"></a>容器存储管理</h3><h3 id=\"容器资源管理\"><a href=\"#容器资源管理\" class=\"headerlink\" title=\"容器资源管理\"></a>容器资源管理</h3><p>docker命令</p>\n<p>systemctl start docker</p>\n<p>systemctl restart docker </p>\n<p>systemctl status docker</p>\n<p>docker images</p>\n<p>systemctl enable docker</p>\n<p>systemctl stop docker</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"Docker容器技术\"><a href=\"#Docker容器技术\" class=\"headerlink\" title=\"Docker容器技术\"></a>Docker容器技术</h2><p>Docker是一门平台级别的技术</p>\n<h3 id=\"Docker安装和部署\"><a href=\"#Docker安装和部署\" class=\"headerlink\" title=\"Docker安装和部署\"></a>Docker安装和部署</h3><p>在服务器上安装各种各样的环境需要花费很多时间，有了Docker以后我只需要将这些环境打包成一个镜像，就可以实现一键部署了</p>\n<p>卸载旧版本</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                 docker-client \\</span><br><span class=\"line\">                 docker-client-latest \\</span><br><span class=\"line\">                 docker-common \\</span><br><span class=\"line\">                 docker-latest \\</span><br><span class=\"line\">                 docker-latest-logrotate \\</span><br><span class=\"line\">                 docker-logrotate \\</span><br><span class=\"line\">                 docker-engine</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"容器与镜像\"><a href=\"#容器与镜像\" class=\"headerlink\" title=\"容器与镜像\"></a>容器与镜像</h3><h3 id=\"容器网络管理\"><a href=\"#容器网络管理\" class=\"headerlink\" title=\"容器网络管理\"></a>容器网络管理</h3><h3 id=\"容器存储管理\"><a href=\"#容器存储管理\" class=\"headerlink\" title=\"容器存储管理\"></a>容器存储管理</h3><h3 id=\"容器资源管理\"><a href=\"#容器资源管理\" class=\"headerlink\" title=\"容器资源管理\"></a>容器资源管理</h3><p>docker命令</p>\n<p>systemctl start docker</p>\n<p>systemctl restart docker </p>\n<p>systemctl status docker</p>\n<p>docker images</p>\n<p>systemctl enable docker</p>\n<p>systemctl stop docker</p>\n"},{"title":"HTTP协议","date":"2022-07-10T03:18:57.000Z","cover":"/img/images/IT.jpg","_content":"\n# HTTP 协议一共有五大特点：\n\n1. `支持客户/服务器模式`\n\n2. `简单快速：`客户向服务器请求服务时，只需传送请求方法和路径。\n3. `灵活：`HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。\n4. `无链接：`无链接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n5. `无状态：`无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session应运而生）","source":"_posts/HTTP特点.md","raw":"---\ntitle: HTTP协议\ndate: 2022-07-10 11:18:57\ntags: 网络\ncategories: 网络\ncover: /img/images/IT.jpg\n---\n\n# HTTP 协议一共有五大特点：\n\n1. `支持客户/服务器模式`\n\n2. `简单快速：`客户向服务器请求服务时，只需传送请求方法和路径。\n3. `灵活：`HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。\n4. `无链接：`无链接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n5. `无状态：`无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session应运而生）","slug":"HTTP特点","published":1,"updated":"2023-08-10T09:36:41.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw8w0003fswoff2rhrzj","content":"<h1 id=\"HTTP-协议一共有五大特点：\"><a href=\"#HTTP-协议一共有五大特点：\" class=\"headerlink\" title=\"HTTP 协议一共有五大特点：\"></a>HTTP 协议一共有五大特点：</h1><ol>\n<li><p><code>支持客户/服务器模式</code></p>\n</li>\n<li><p><code>简单快速：</code>客户向服务器请求服务时，只需传送请求方法和路径。</p>\n</li>\n<li><p><code>灵活：</code>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>\n</li>\n<li><p><code>无链接：</code>无链接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p><code>无状态：</code>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session应运而生）</p>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"HTTP-协议一共有五大特点：\"><a href=\"#HTTP-协议一共有五大特点：\" class=\"headerlink\" title=\"HTTP 协议一共有五大特点：\"></a>HTTP 协议一共有五大特点：</h1><ol>\n<li><p><code>支持客户/服务器模式</code></p>\n</li>\n<li><p><code>简单快速：</code>客户向服务器请求服务时，只需传送请求方法和路径。</p>\n</li>\n<li><p><code>灵活：</code>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>\n</li>\n<li><p><code>无链接：</code>无链接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p><code>无状态：</code>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session应运而生）</p>\n</li>\n</ol>\n"},{"title":"HTTP状态码","date":"2022-07-12T03:10:10.000Z","cover":"/img/images/computer2.jpg","_content":"\n# HTTP状态码\n\n## 1xx:信息提示\n这类状态代码标识临时的响应。客户端在收到常规响应之前，应准备接受一个或多个1xx响应。\n\n|HTTP状态码|说明|\n|---|---|\n|100|继续|\n|101|切换协议|\n\n## 2xx:成功\n这类状态代码表明服务器成功地接受了客户端请求。\n|HTTP状态码|说明|\n|---|---|\n|200|确定。客户端请求已成功。|\n|201|已创建。|\n|202|已接受。|\n|203|非权威性信息。|\n|204|无内容。|\n|205|重置内容。|\n|206|部分内容。表明已部分下载了一个文件。可以续传损坏的下载，或者将下载拆分为多个并发的流。|\n|207|多状态(WebDAV)。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出多少个子请求。|\n\n## 3xx:重定向\n客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复请求。\n\n|HTTP状态码|说明|\n|---|---|\n|301|已永久移动。此请求和之后所有的请求应该转到制定的URI。|\n|302|对象已移动。对于基于表单的身份验证，此消息通常表示为“对象已移动”。请求的资源临时驻留在不同的URI。由于重定向有时可能会改变。客户端将来在请求时应该继续使用 RequestURI。只有在CacheControl或Expires标题字段中指示，此响应才能够缓存。|\n|304|未修改。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。|\n|307|临时重定向|\n\n## 4xx:客户端错误\n发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。\n|HTTP状态码|说明|\n|---|---|\n|400|错误的请求。|\n|401|访问被拒绝。IIS定义了几个不同的401错误，用于指示更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示。详见401状态码。|\n|403|服务器拒绝请求。可以理解为没有权限访问此网站，服务器能够收到请求但拒绝提供服务。IIS定义了几个不同的403错误，用于指示更为具体的错误原因，详见403状态码。|\n|404|服务器找不到请求的网页。例如，访问网站中不存在的页面，或者原有页面被移走或删除，则可能会出现该状态码。IIS定义了几个不同的404错误，用于只是更为具体的错误原因，详见404状态码。|\n|405|用来访问本页面的HTTP谓词不被允许(方法不被允许)。当客户端向运行IIS的服务器发送一个HTTP请求，并且该请求包含服务器无法识别的HTTTP动词时，就会发生此错误，若要解决此问题，请确保客户端的请求使用与HTTP rfc兼容的HTTP动词。|\n|406|客户端浏览器不接受所请求页面的MIME类型。|\n|407|要求进行代理身份验证。|\n|412|前提条件失败。|\n|413|请求实体太大。|\n|414|请求URI太长。|\n|415|不支持的媒体类型。|\n|416|无法满足请求的范围。|\n|417|执行失败。|\n|423|锁定的错误。|\n\n## 401状态码\n|HTTP状态码|说明|\n|---|---|\n|401.1|用户名或密码无效导致登录失败。|\n|401.2|服务器配置导致登录失败。|\n|401.3|由于ACL对资源的限制而未获得授权。表示存在NTFS权限问题。即使您对试图访问的文件具备相应的权限，也可能发生此错误。例如，如果IUSR账户无权访问C:WinntSystem32Inetsrv目录，您会看到这个错误|\n|401.4|筛选器授权失败|\n|401.5|ISAPI/CGI应用程序授权失败。|\n|401.7|由Web服务器上的URL验证策略拒绝访问。这个错误代码为IIS 6.0所专用。|\n\n## 403状态码\n|HTTP状态码|说明|\n|---|---|\n|403.1|执行访问被禁止。可能原因：<br />您没有足够的执行许可。例如，如果试图访问的 ASP 页所在的目录权限设为 “无”，或者，试图执行的 CGI 脚本所在的目录权限为 “只允许脚本”，将出现此错误消息。若要修改执行权限，请在 Microsoft 管理控制台（MMC）中右击目录，然后依次单击 “属性” 和 “目录” 选项卡，确保为试图访问的内容设置适当的执行权限。<br />您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击 “属性”、“目录” 选项卡和 “配置”，然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。|\n|403.2|读访问被禁止。验证是否已将 IIS 设置为允许对目录进行读访问。另外，如果您正在使用默认文件，请验证该文件是否存在。|\n|403.3|写访问被禁止。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。|\n|403.4|要求SSL禁用要求安全通道选项，或使用HTTPS代替HTTP来访问该页面|\n|403.5|要求SSL128.禁用要求128位加密选项，或使用支持128位加密的浏览器以查看该页面，|\n|403.6|IP地址被拒绝。您已经将服务器配置为拒绝访问您当前的IP地址。|\n|403.7|要求客户端证书。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。|\n|403.8|站点访问被拒绝。您已经为用来访问服务器的域设置了域名限制|\n|403.9|用户数过多。与该服务器链接的用户数量超过了您设置的连接限制。注意：Microsoft Windows 2000 Professional和Windows XP Professional 自动设置了在IIS上最多10个连接的限制。您无法更改此限制|\n|403.10|配置无效。|\n|403.11|密码更改。|\n|403.12|拒绝访问映射表。您要访问的页面要求提供客户端证书。但是，映射到该客户端证书的用户ID已经拒绝访问该文件。|\n|403.13|客户端证书被吊销。|\n|403.14|拒绝目录列表。|\n|403.15|超出客户端访问许可。|\n|403.16|客户端证书不受信任或无效|\n|403.17|客户端证书已过期或尚未生效|\n|403.18|在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。|\n|403.19|不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用|\n|403.20|Passport登录失败。这个错误代码为IIS6.0所专用。|\n\n\n\n## 404状态码\n\n| HTTP状态码 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 404.0      | 没有找到文件或目录                                           |\n| 404.1      | 无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的IP地址不接受来自请求所用端口的请求。 |\n| 404.2      | Web服务扩展锁定策略阻止本请求。在IIS6.0中，表示Web服务扩展列表中已经阻止了该请求。 |\n| 404.3      | MIME映射策略阻止了此请求。如果存在下列情况，将出现此问题:<br/>1.未配置请求的文件扩展名的处理程序映射。<br/>2.没有为网站或应用或应用程序配置相应的MIME类型。|\n\n## 5xx:服务器错误\n\n| HTTP状态码 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 500        | 内部服务器错误。很多服务器端错误都有可能导致此错误消息。事件查看器日志包含更详细的错误原因。此外，你可以禁用友好HTTP错误消息以便收到详细的错误说明。IIS定义了几个不同的500错误，用于指示更为具体的错误原因，详见500状态码。 |\n| 501        | 页眉值指定了未实现的配置。                                   |\n| 502        | Web服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关(与请求无关)。IIS定义了几个不同的502错误，用于指示更为具体的错误原因，详见502状态码。 |\n| 503        | 目前服务器无法使用，一般是应为服务器超载或停止维护。         |\n| 504        | 网关超时。                                                   |\n| 505        | HTTP版本不受支持。                                           |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/HTTP状态码.md","raw":"---\ntitle: HTTP状态码\ndate: 2022-07-12 11:10:10\ntags: 网络\ncategories: 网络\ncover: /img/images/computer2.jpg\n---\n\n# HTTP状态码\n\n## 1xx:信息提示\n这类状态代码标识临时的响应。客户端在收到常规响应之前，应准备接受一个或多个1xx响应。\n\n|HTTP状态码|说明|\n|---|---|\n|100|继续|\n|101|切换协议|\n\n## 2xx:成功\n这类状态代码表明服务器成功地接受了客户端请求。\n|HTTP状态码|说明|\n|---|---|\n|200|确定。客户端请求已成功。|\n|201|已创建。|\n|202|已接受。|\n|203|非权威性信息。|\n|204|无内容。|\n|205|重置内容。|\n|206|部分内容。表明已部分下载了一个文件。可以续传损坏的下载，或者将下载拆分为多个并发的流。|\n|207|多状态(WebDAV)。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出多少个子请求。|\n\n## 3xx:重定向\n客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复请求。\n\n|HTTP状态码|说明|\n|---|---|\n|301|已永久移动。此请求和之后所有的请求应该转到制定的URI。|\n|302|对象已移动。对于基于表单的身份验证，此消息通常表示为“对象已移动”。请求的资源临时驻留在不同的URI。由于重定向有时可能会改变。客户端将来在请求时应该继续使用 RequestURI。只有在CacheControl或Expires标题字段中指示，此响应才能够缓存。|\n|304|未修改。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。|\n|307|临时重定向|\n\n## 4xx:客户端错误\n发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。\n|HTTP状态码|说明|\n|---|---|\n|400|错误的请求。|\n|401|访问被拒绝。IIS定义了几个不同的401错误，用于指示更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示。详见401状态码。|\n|403|服务器拒绝请求。可以理解为没有权限访问此网站，服务器能够收到请求但拒绝提供服务。IIS定义了几个不同的403错误，用于指示更为具体的错误原因，详见403状态码。|\n|404|服务器找不到请求的网页。例如，访问网站中不存在的页面，或者原有页面被移走或删除，则可能会出现该状态码。IIS定义了几个不同的404错误，用于只是更为具体的错误原因，详见404状态码。|\n|405|用来访问本页面的HTTP谓词不被允许(方法不被允许)。当客户端向运行IIS的服务器发送一个HTTP请求，并且该请求包含服务器无法识别的HTTTP动词时，就会发生此错误，若要解决此问题，请确保客户端的请求使用与HTTP rfc兼容的HTTP动词。|\n|406|客户端浏览器不接受所请求页面的MIME类型。|\n|407|要求进行代理身份验证。|\n|412|前提条件失败。|\n|413|请求实体太大。|\n|414|请求URI太长。|\n|415|不支持的媒体类型。|\n|416|无法满足请求的范围。|\n|417|执行失败。|\n|423|锁定的错误。|\n\n## 401状态码\n|HTTP状态码|说明|\n|---|---|\n|401.1|用户名或密码无效导致登录失败。|\n|401.2|服务器配置导致登录失败。|\n|401.3|由于ACL对资源的限制而未获得授权。表示存在NTFS权限问题。即使您对试图访问的文件具备相应的权限，也可能发生此错误。例如，如果IUSR账户无权访问C:WinntSystem32Inetsrv目录，您会看到这个错误|\n|401.4|筛选器授权失败|\n|401.5|ISAPI/CGI应用程序授权失败。|\n|401.7|由Web服务器上的URL验证策略拒绝访问。这个错误代码为IIS 6.0所专用。|\n\n## 403状态码\n|HTTP状态码|说明|\n|---|---|\n|403.1|执行访问被禁止。可能原因：<br />您没有足够的执行许可。例如，如果试图访问的 ASP 页所在的目录权限设为 “无”，或者，试图执行的 CGI 脚本所在的目录权限为 “只允许脚本”，将出现此错误消息。若要修改执行权限，请在 Microsoft 管理控制台（MMC）中右击目录，然后依次单击 “属性” 和 “目录” 选项卡，确保为试图访问的内容设置适当的执行权限。<br />您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击 “属性”、“目录” 选项卡和 “配置”，然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。|\n|403.2|读访问被禁止。验证是否已将 IIS 设置为允许对目录进行读访问。另外，如果您正在使用默认文件，请验证该文件是否存在。|\n|403.3|写访问被禁止。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。|\n|403.4|要求SSL禁用要求安全通道选项，或使用HTTPS代替HTTP来访问该页面|\n|403.5|要求SSL128.禁用要求128位加密选项，或使用支持128位加密的浏览器以查看该页面，|\n|403.6|IP地址被拒绝。您已经将服务器配置为拒绝访问您当前的IP地址。|\n|403.7|要求客户端证书。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。|\n|403.8|站点访问被拒绝。您已经为用来访问服务器的域设置了域名限制|\n|403.9|用户数过多。与该服务器链接的用户数量超过了您设置的连接限制。注意：Microsoft Windows 2000 Professional和Windows XP Professional 自动设置了在IIS上最多10个连接的限制。您无法更改此限制|\n|403.10|配置无效。|\n|403.11|密码更改。|\n|403.12|拒绝访问映射表。您要访问的页面要求提供客户端证书。但是，映射到该客户端证书的用户ID已经拒绝访问该文件。|\n|403.13|客户端证书被吊销。|\n|403.14|拒绝目录列表。|\n|403.15|超出客户端访问许可。|\n|403.16|客户端证书不受信任或无效|\n|403.17|客户端证书已过期或尚未生效|\n|403.18|在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。|\n|403.19|不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用|\n|403.20|Passport登录失败。这个错误代码为IIS6.0所专用。|\n\n\n\n## 404状态码\n\n| HTTP状态码 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 404.0      | 没有找到文件或目录                                           |\n| 404.1      | 无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的IP地址不接受来自请求所用端口的请求。 |\n| 404.2      | Web服务扩展锁定策略阻止本请求。在IIS6.0中，表示Web服务扩展列表中已经阻止了该请求。 |\n| 404.3      | MIME映射策略阻止了此请求。如果存在下列情况，将出现此问题:<br/>1.未配置请求的文件扩展名的处理程序映射。<br/>2.没有为网站或应用或应用程序配置相应的MIME类型。|\n\n## 5xx:服务器错误\n\n| HTTP状态码 | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 500        | 内部服务器错误。很多服务器端错误都有可能导致此错误消息。事件查看器日志包含更详细的错误原因。此外，你可以禁用友好HTTP错误消息以便收到详细的错误说明。IIS定义了几个不同的500错误，用于指示更为具体的错误原因，详见500状态码。 |\n| 501        | 页眉值指定了未实现的配置。                                   |\n| 502        | Web服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关(与请求无关)。IIS定义了几个不同的502错误，用于指示更为具体的错误原因，详见502状态码。 |\n| 503        | 目前服务器无法使用，一般是应为服务器超载或停止维护。         |\n| 504        | 网关超时。                                                   |\n| 505        | HTTP版本不受支持。                                           |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"HTTP状态码","published":1,"updated":"2023-08-10T09:37:02.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw920007fswofmg12udj","content":"<h1 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h1><h2 id=\"1xx-信息提示\"><a href=\"#1xx-信息提示\" class=\"headerlink\" title=\"1xx:信息提示\"></a>1xx:信息提示</h2><p>这类状态代码标识临时的响应。客户端在收到常规响应之前，应准备接受一个或多个1xx响应。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100</td>\n<td>继续</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n</tr>\n</tbody></table>\n<h2 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx:成功\"></a>2xx:成功</h2><p>这类状态代码表明服务器成功地接受了客户端请求。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>200</td>\n<td>确定。客户端请求已成功。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非权威性信息。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>重置内容。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>部分内容。表明已部分下载了一个文件。可以续传损坏的下载，或者将下载拆分为多个并发的流。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>多状态(WebDAV)。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出多少个子请求。</td>\n</tr>\n</tbody></table>\n<h2 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx:重定向\"></a>3xx:重定向</h2><p>客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复请求。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>301</td>\n<td>已永久移动。此请求和之后所有的请求应该转到制定的URI。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>对象已移动。对于基于表单的身份验证，此消息通常表示为“对象已移动”。请求的资源临时驻留在不同的URI。由于重定向有时可能会改变。客户端将来在请求时应该继续使用 RequestURI。只有在CacheControl或Expires标题字段中指示，此响应才能够缓存。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>未修改。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>临时重定向</td>\n</tr>\n</tbody></table>\n<h2 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx:客户端错误\"></a>4xx:客户端错误</h2><p>发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>400</td>\n<td>错误的请求。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>访问被拒绝。IIS定义了几个不同的401错误，用于指示更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示。详见401状态码。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器拒绝请求。可以理解为没有权限访问此网站，服务器能够收到请求但拒绝提供服务。IIS定义了几个不同的403错误，用于指示更为具体的错误原因，详见403状态码。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>服务器找不到请求的网页。例如，访问网站中不存在的页面，或者原有页面被移走或删除，则可能会出现该状态码。IIS定义了几个不同的404错误，用于只是更为具体的错误原因，详见404状态码。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>用来访问本页面的HTTP谓词不被允许(方法不被允许)。当客户端向运行IIS的服务器发送一个HTTP请求，并且该请求包含服务器无法识别的HTTTP动词时，就会发生此错误，若要解决此问题，请确保客户端的请求使用与HTTP rfc兼容的HTTP动词。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>客户端浏览器不接受所请求页面的MIME类型。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>要求进行代理身份验证。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>前提条件失败。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>请求实体太大。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求URI太长。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>不支持的媒体类型。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>无法满足请求的范围。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>执行失败。</td>\n</tr>\n<tr>\n<td>423</td>\n<td>锁定的错误。</td>\n</tr>\n</tbody></table>\n<h2 id=\"401状态码\"><a href=\"#401状态码\" class=\"headerlink\" title=\"401状态码\"></a>401状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>401.1</td>\n<td>用户名或密码无效导致登录失败。</td>\n</tr>\n<tr>\n<td>401.2</td>\n<td>服务器配置导致登录失败。</td>\n</tr>\n<tr>\n<td>401.3</td>\n<td>由于ACL对资源的限制而未获得授权。表示存在NTFS权限问题。即使您对试图访问的文件具备相应的权限，也可能发生此错误。例如，如果IUSR账户无权访问C:WinntSystem32Inetsrv目录，您会看到这个错误</td>\n</tr>\n<tr>\n<td>401.4</td>\n<td>筛选器授权失败</td>\n</tr>\n<tr>\n<td>401.5</td>\n<td>ISAPI&#x2F;CGI应用程序授权失败。</td>\n</tr>\n<tr>\n<td>401.7</td>\n<td>由Web服务器上的URL验证策略拒绝访问。这个错误代码为IIS 6.0所专用。</td>\n</tr>\n</tbody></table>\n<h2 id=\"403状态码\"><a href=\"#403状态码\" class=\"headerlink\" title=\"403状态码\"></a>403状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>403.1</td>\n<td>执行访问被禁止。可能原因：<br />您没有足够的执行许可。例如，如果试图访问的 ASP 页所在的目录权限设为 “无”，或者，试图执行的 CGI 脚本所在的目录权限为 “只允许脚本”，将出现此错误消息。若要修改执行权限，请在 Microsoft 管理控制台（MMC）中右击目录，然后依次单击 “属性” 和 “目录” 选项卡，确保为试图访问的内容设置适当的执行权限。<br />您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击 “属性”、“目录” 选项卡和 “配置”，然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。</td>\n</tr>\n<tr>\n<td>403.2</td>\n<td>读访问被禁止。验证是否已将 IIS 设置为允许对目录进行读访问。另外，如果您正在使用默认文件，请验证该文件是否存在。</td>\n</tr>\n<tr>\n<td>403.3</td>\n<td>写访问被禁止。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。</td>\n</tr>\n<tr>\n<td>403.4</td>\n<td>要求SSL禁用要求安全通道选项，或使用HTTPS代替HTTP来访问该页面</td>\n</tr>\n<tr>\n<td>403.5</td>\n<td>要求SSL128.禁用要求128位加密选项，或使用支持128位加密的浏览器以查看该页面，</td>\n</tr>\n<tr>\n<td>403.6</td>\n<td>IP地址被拒绝。您已经将服务器配置为拒绝访问您当前的IP地址。</td>\n</tr>\n<tr>\n<td>403.7</td>\n<td>要求客户端证书。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。</td>\n</tr>\n<tr>\n<td>403.8</td>\n<td>站点访问被拒绝。您已经为用来访问服务器的域设置了域名限制</td>\n</tr>\n<tr>\n<td>403.9</td>\n<td>用户数过多。与该服务器链接的用户数量超过了您设置的连接限制。注意：Microsoft Windows 2000 Professional和Windows XP Professional 自动设置了在IIS上最多10个连接的限制。您无法更改此限制</td>\n</tr>\n<tr>\n<td>403.10</td>\n<td>配置无效。</td>\n</tr>\n<tr>\n<td>403.11</td>\n<td>密码更改。</td>\n</tr>\n<tr>\n<td>403.12</td>\n<td>拒绝访问映射表。您要访问的页面要求提供客户端证书。但是，映射到该客户端证书的用户ID已经拒绝访问该文件。</td>\n</tr>\n<tr>\n<td>403.13</td>\n<td>客户端证书被吊销。</td>\n</tr>\n<tr>\n<td>403.14</td>\n<td>拒绝目录列表。</td>\n</tr>\n<tr>\n<td>403.15</td>\n<td>超出客户端访问许可。</td>\n</tr>\n<tr>\n<td>403.16</td>\n<td>客户端证书不受信任或无效</td>\n</tr>\n<tr>\n<td>403.17</td>\n<td>客户端证书已过期或尚未生效</td>\n</tr>\n<tr>\n<td>403.18</td>\n<td>在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。</td>\n</tr>\n<tr>\n<td>403.19</td>\n<td>不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用</td>\n</tr>\n<tr>\n<td>403.20</td>\n<td>Passport登录失败。这个错误代码为IIS6.0所专用。</td>\n</tr>\n</tbody></table>\n<h2 id=\"404状态码\"><a href=\"#404状态码\" class=\"headerlink\" title=\"404状态码\"></a>404状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>404.0</td>\n<td>没有找到文件或目录</td>\n</tr>\n<tr>\n<td>404.1</td>\n<td>无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的IP地址不接受来自请求所用端口的请求。</td>\n</tr>\n<tr>\n<td>404.2</td>\n<td>Web服务扩展锁定策略阻止本请求。在IIS6.0中，表示Web服务扩展列表中已经阻止了该请求。</td>\n</tr>\n<tr>\n<td>404.3</td>\n<td>MIME映射策略阻止了此请求。如果存在下列情况，将出现此问题:<br/>1.未配置请求的文件扩展名的处理程序映射。<br/>2.没有为网站或应用或应用程序配置相应的MIME类型。</td>\n</tr>\n</tbody></table>\n<h2 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx:服务器错误\"></a>5xx:服务器错误</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>500</td>\n<td>内部服务器错误。很多服务器端错误都有可能导致此错误消息。事件查看器日志包含更详细的错误原因。此外，你可以禁用友好HTTP错误消息以便收到详细的错误说明。IIS定义了几个不同的500错误，用于指示更为具体的错误原因，详见500状态码。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>页眉值指定了未实现的配置。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Web服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关(与请求无关)。IIS定义了几个不同的502错误，用于指示更为具体的错误原因，详见502状态码。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>目前服务器无法使用，一般是应为服务器超载或停止维护。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>网关超时。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP版本不受支持。</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h1><h2 id=\"1xx-信息提示\"><a href=\"#1xx-信息提示\" class=\"headerlink\" title=\"1xx:信息提示\"></a>1xx:信息提示</h2><p>这类状态代码标识临时的响应。客户端在收到常规响应之前，应准备接受一个或多个1xx响应。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100</td>\n<td>继续</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n</tr>\n</tbody></table>\n<h2 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx:成功\"></a>2xx:成功</h2><p>这类状态代码表明服务器成功地接受了客户端请求。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>200</td>\n<td>确定。客户端请求已成功。</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建。</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受。</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非权威性信息。</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容。</td>\n</tr>\n<tr>\n<td>205</td>\n<td>重置内容。</td>\n</tr>\n<tr>\n<td>206</td>\n<td>部分内容。表明已部分下载了一个文件。可以续传损坏的下载，或者将下载拆分为多个并发的流。</td>\n</tr>\n<tr>\n<td>207</td>\n<td>多状态(WebDAV)。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出多少个子请求。</td>\n</tr>\n</tbody></table>\n<h2 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx:重定向\"></a>3xx:重定向</h2><p>客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复请求。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>301</td>\n<td>已永久移动。此请求和之后所有的请求应该转到制定的URI。</td>\n</tr>\n<tr>\n<td>302</td>\n<td>对象已移动。对于基于表单的身份验证，此消息通常表示为“对象已移动”。请求的资源临时驻留在不同的URI。由于重定向有时可能会改变。客户端将来在请求时应该继续使用 RequestURI。只有在CacheControl或Expires标题字段中指示，此响应才能够缓存。</td>\n</tr>\n<tr>\n<td>304</td>\n<td>未修改。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。</td>\n</tr>\n<tr>\n<td>307</td>\n<td>临时重定向</td>\n</tr>\n</tbody></table>\n<h2 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx:客户端错误\"></a>4xx:客户端错误</h2><p>发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。</p>\n<table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>400</td>\n<td>错误的请求。</td>\n</tr>\n<tr>\n<td>401</td>\n<td>访问被拒绝。IIS定义了几个不同的401错误，用于指示更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在IIS日志中显示。详见401状态码。</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器拒绝请求。可以理解为没有权限访问此网站，服务器能够收到请求但拒绝提供服务。IIS定义了几个不同的403错误，用于指示更为具体的错误原因，详见403状态码。</td>\n</tr>\n<tr>\n<td>404</td>\n<td>服务器找不到请求的网页。例如，访问网站中不存在的页面，或者原有页面被移走或删除，则可能会出现该状态码。IIS定义了几个不同的404错误，用于只是更为具体的错误原因，详见404状态码。</td>\n</tr>\n<tr>\n<td>405</td>\n<td>用来访问本页面的HTTP谓词不被允许(方法不被允许)。当客户端向运行IIS的服务器发送一个HTTP请求，并且该请求包含服务器无法识别的HTTTP动词时，就会发生此错误，若要解决此问题，请确保客户端的请求使用与HTTP rfc兼容的HTTP动词。</td>\n</tr>\n<tr>\n<td>406</td>\n<td>客户端浏览器不接受所请求页面的MIME类型。</td>\n</tr>\n<tr>\n<td>407</td>\n<td>要求进行代理身份验证。</td>\n</tr>\n<tr>\n<td>412</td>\n<td>前提条件失败。</td>\n</tr>\n<tr>\n<td>413</td>\n<td>请求实体太大。</td>\n</tr>\n<tr>\n<td>414</td>\n<td>请求URI太长。</td>\n</tr>\n<tr>\n<td>415</td>\n<td>不支持的媒体类型。</td>\n</tr>\n<tr>\n<td>416</td>\n<td>无法满足请求的范围。</td>\n</tr>\n<tr>\n<td>417</td>\n<td>执行失败。</td>\n</tr>\n<tr>\n<td>423</td>\n<td>锁定的错误。</td>\n</tr>\n</tbody></table>\n<h2 id=\"401状态码\"><a href=\"#401状态码\" class=\"headerlink\" title=\"401状态码\"></a>401状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>401.1</td>\n<td>用户名或密码无效导致登录失败。</td>\n</tr>\n<tr>\n<td>401.2</td>\n<td>服务器配置导致登录失败。</td>\n</tr>\n<tr>\n<td>401.3</td>\n<td>由于ACL对资源的限制而未获得授权。表示存在NTFS权限问题。即使您对试图访问的文件具备相应的权限，也可能发生此错误。例如，如果IUSR账户无权访问C:WinntSystem32Inetsrv目录，您会看到这个错误</td>\n</tr>\n<tr>\n<td>401.4</td>\n<td>筛选器授权失败</td>\n</tr>\n<tr>\n<td>401.5</td>\n<td>ISAPI&#x2F;CGI应用程序授权失败。</td>\n</tr>\n<tr>\n<td>401.7</td>\n<td>由Web服务器上的URL验证策略拒绝访问。这个错误代码为IIS 6.0所专用。</td>\n</tr>\n</tbody></table>\n<h2 id=\"403状态码\"><a href=\"#403状态码\" class=\"headerlink\" title=\"403状态码\"></a>403状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>403.1</td>\n<td>执行访问被禁止。可能原因：<br />您没有足够的执行许可。例如，如果试图访问的 ASP 页所在的目录权限设为 “无”，或者，试图执行的 CGI 脚本所在的目录权限为 “只允许脚本”，将出现此错误消息。若要修改执行权限，请在 Microsoft 管理控制台（MMC）中右击目录，然后依次单击 “属性” 和 “目录” 选项卡，确保为试图访问的内容设置适当的执行权限。<br />您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击 “属性”、“目录” 选项卡和 “配置”，然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。</td>\n</tr>\n<tr>\n<td>403.2</td>\n<td>读访问被禁止。验证是否已将 IIS 设置为允许对目录进行读访问。另外，如果您正在使用默认文件，请验证该文件是否存在。</td>\n</tr>\n<tr>\n<td>403.3</td>\n<td>写访问被禁止。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。</td>\n</tr>\n<tr>\n<td>403.4</td>\n<td>要求SSL禁用要求安全通道选项，或使用HTTPS代替HTTP来访问该页面</td>\n</tr>\n<tr>\n<td>403.5</td>\n<td>要求SSL128.禁用要求128位加密选项，或使用支持128位加密的浏览器以查看该页面，</td>\n</tr>\n<tr>\n<td>403.6</td>\n<td>IP地址被拒绝。您已经将服务器配置为拒绝访问您当前的IP地址。</td>\n</tr>\n<tr>\n<td>403.7</td>\n<td>要求客户端证书。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。</td>\n</tr>\n<tr>\n<td>403.8</td>\n<td>站点访问被拒绝。您已经为用来访问服务器的域设置了域名限制</td>\n</tr>\n<tr>\n<td>403.9</td>\n<td>用户数过多。与该服务器链接的用户数量超过了您设置的连接限制。注意：Microsoft Windows 2000 Professional和Windows XP Professional 自动设置了在IIS上最多10个连接的限制。您无法更改此限制</td>\n</tr>\n<tr>\n<td>403.10</td>\n<td>配置无效。</td>\n</tr>\n<tr>\n<td>403.11</td>\n<td>密码更改。</td>\n</tr>\n<tr>\n<td>403.12</td>\n<td>拒绝访问映射表。您要访问的页面要求提供客户端证书。但是，映射到该客户端证书的用户ID已经拒绝访问该文件。</td>\n</tr>\n<tr>\n<td>403.13</td>\n<td>客户端证书被吊销。</td>\n</tr>\n<tr>\n<td>403.14</td>\n<td>拒绝目录列表。</td>\n</tr>\n<tr>\n<td>403.15</td>\n<td>超出客户端访问许可。</td>\n</tr>\n<tr>\n<td>403.16</td>\n<td>客户端证书不受信任或无效</td>\n</tr>\n<tr>\n<td>403.17</td>\n<td>客户端证书已过期或尚未生效</td>\n</tr>\n<tr>\n<td>403.18</td>\n<td>在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。</td>\n</tr>\n<tr>\n<td>403.19</td>\n<td>不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用</td>\n</tr>\n<tr>\n<td>403.20</td>\n<td>Passport登录失败。这个错误代码为IIS6.0所专用。</td>\n</tr>\n</tbody></table>\n<h2 id=\"404状态码\"><a href=\"#404状态码\" class=\"headerlink\" title=\"404状态码\"></a>404状态码</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>404.0</td>\n<td>没有找到文件或目录</td>\n</tr>\n<tr>\n<td>404.1</td>\n<td>无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的IP地址不接受来自请求所用端口的请求。</td>\n</tr>\n<tr>\n<td>404.2</td>\n<td>Web服务扩展锁定策略阻止本请求。在IIS6.0中，表示Web服务扩展列表中已经阻止了该请求。</td>\n</tr>\n<tr>\n<td>404.3</td>\n<td>MIME映射策略阻止了此请求。如果存在下列情况，将出现此问题:<br/>1.未配置请求的文件扩展名的处理程序映射。<br/>2.没有为网站或应用或应用程序配置相应的MIME类型。</td>\n</tr>\n</tbody></table>\n<h2 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx:服务器错误\"></a>5xx:服务器错误</h2><table>\n<thead>\n<tr>\n<th>HTTP状态码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>500</td>\n<td>内部服务器错误。很多服务器端错误都有可能导致此错误消息。事件查看器日志包含更详细的错误原因。此外，你可以禁用友好HTTP错误消息以便收到详细的错误说明。IIS定义了几个不同的500错误，用于指示更为具体的错误原因，详见500状态码。</td>\n</tr>\n<tr>\n<td>501</td>\n<td>页眉值指定了未实现的配置。</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Web服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关(与请求无关)。IIS定义了几个不同的502错误，用于指示更为具体的错误原因，详见502状态码。</td>\n</tr>\n<tr>\n<td>503</td>\n<td>目前服务器无法使用，一般是应为服务器超载或停止维护。</td>\n</tr>\n<tr>\n<td>504</td>\n<td>网关超时。</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP版本不受支持。</td>\n</tr>\n</tbody></table>\n"},{"title":"Java基础","date":"2023-01-05T03:18:57.000Z","cover":"/img/images/Java.jpg","_content":"\n# JAVA基础\n\n### 一、什么是JAVA\n\nSun公司在1995年向外发布推广的一款面向对象的高级程序设计语言\n\n其主要应用于互联网后端服务器开发，大数据，安卓，网页，游戏等领域\n\n### 二、JAVA语言技术体系\n\n1. JavaSE(Java Platform Standard Edition)\n\n   Java标准版，主要包含Java基础语法，主要用于开发桌面软件及游戏\n\n   \n\n2. JavaME(Java Platform Micro Edition)\n\n   Java微型版，主要用于开发移动端设备和嵌入式设备的软件，如手机、pda、机顶盒、车载等\n\n   \n\n3. JavaEE(Java Platform Enterprise Edition)\n\n   Java企业版，主要用于开发互联网企业后台服务器端，为企业级开发提供解决方案\n\n   企业级软件：\n\n   公司：OA、ERP、CRM、SNS、财务、人事考勤....\n\n   学校：学生管理系统、宿舍管理系统、考试系统....\n\n   互联网：百度，京东，淘宝，B站....\n\n   其他：教育、视频、直播、电信、电力、金融、电商\n\n### 三、Java语言特点\n\n1. 应用面广\n2. Java简单易学（相对于C/C++）\n3. 面向对象(更符合我们看待事务特点)\n4. 跨平台(一处编译，处处运行)\n5. 多线程(提升系统的运行性能和效率)\n6. 分布式(解决高并发，高可用，高性能问题)\n7. 健壮性(强类型、垃圾回收、异常处理)\n8. 安全性\n9. 开源\n\n### 四、Java开发环境搭建\n\n1. JVM\n\n   Java Virtual Machine\n\n   Java虚拟机\n\n   Java程序是运行在虚拟机之上，JVM是Java程序能够实现跨平台的基础\n\n   \n\n2. JRE\n\n   Java Runtime Environment\n\n   Java运行时环境\n\n   JRE=JVM+运行时需要的环境\n\n   \n\n3. JDK\n\n   Java Develop Kit\n\n   Java 开发工具包\n\n   提供给Java开发人员使用的，其中包含Java开发需要的软件\n\n   JDK=JRE+Java开发工具\n\n\n\n### 五、环境变量配置\n\n1. 新建JAVA_HOME\n\n   变量名：JAVA_HOME\n\n   变量值：填写JDK 安装目录\n\n2. 新建CLASSPATH\n\n   变量名：CLASSPATH\n\n   变量值：.\n\n   ​\t\t.;%JAVA_HOME%\\lib\n\n   ​\t\t.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar\n\n3. 找到Path\n\n   新建：%JAVA_HOME%\\bin\n\n   新建：%JAVA_HOME%\\jre\\bin\n\n测试环境变量是否配置成功：\n\n1. win+R打开运行窗口\n2. 输入cmd。点击确定打开命令行窗口\n3. 输入javac或者java -version\n4. 显示日志或者版本号则表明配置成功，不显示则表示配置失败\n\n\n\n### 六、跨平台\n\n因为有了JVM，同一份字节码文件可以在三个不同的平台上都能运行，这样就实现了Java程序的跨平\n\n\n\n### 七、第一个Java程序\n\n1. Java项目的目录结构\n\n   Java Project\n\n   Java工程，Java项目，可以理解为是一个总文件夹\n\n   JRE System Library\n\n   > Java运行环境(系统库)\n\n   src\n\n   > 编写Java源代码的位置\n\n   bin\n\n   > 用于存储编译后的.class字节码文件\n\n2. Package\n\n   包，创建在src下面，可以理解为是一个子文件夹\n\n3. Class\n\n   类，创建在Package下面，就是一个Java源文件\n\n4. Java程序运行方式\n\n   4.1 菜单栏点击绿色箭头\n\n   4.2 右键-->Run As-->Java Application\n\n   4.3 Ctrl+F11\n\n5. Java中注释\n\n6. 注释：对Java代码起到一个解释说明的作用，不参与编译和运行过程，相当于产品说明书\n\n   单行注释：//\n\n   多行注释：/*\n\n   ​\t\t*/\n\n   文档注释：/**\n\n   ​\t\t*/\n\n   > 注意：main函数，程序执行的入口\n   >\n   > public static void main(String[] args){}\n   >\n   > 注意：输出语句\n   >\n   > System.out.println(\"要输出的内容\");\n\n7. 基本语法规范\n\n   7.1大小写严格区分\n\n   7.2中英文严格区分（所有阔符号如为\n\n   7.3括号必须成对出现\n\n   7.4没行代码结束之后必须以分号结尾\n\n   7.5大括号标识一个结构，结尾不用打分号\n\n8. 进制\n\n   1. 二进制：\n\n      逢二进一\n\n      二进制转十进制\n\n      二进制 权（2^n)\n\n   2. 十进制：\n\n      逢十进一\n\n      十进制转二进制 短除法    \n\n   3. 八进制：                \n\n      逢八进一              \n\n   4. 十六进制：\n\n      逢十六进一\n\n   | 10进制 | 2进制 | 8进制 | 16进制 |\n   | ------ | ----- | ----- | ------ |\n   | 0      | 0000  | 0     | 0      |\n   | 1      | 0001  | 1     | 1      |\n   | 2      | 0010  | 2     | 2      |\n   | 3      | 0011  | 3     | 3      |\n   | 4      | 0100  | 4     | 4      |\n   | 5      | 0101  | 5     | 5      |\n   | 6      | 0110  | 6     | 6      |\n   | 7      | 0111  | 7     | 7      |\n   | 8      | 1000  | 10    | 8      |\n   | 9      | 1001  | 11    | 9      |\n   | 10     | 1010  | 12    | A      |\n   | 11     | 1011  | 13    | B      |\n   | 12     | 1100  | 14    | C      |\n   | 13     | 1101  | 15    | D      |\n   | 14     | 1110  | 16    | E      |\n   | 15     | 1111  | 17    | F      |\n   | 16     | 10000 | 20    | 10     |\n\n   在计算机中所有的数据(图片、音频、文本等资源)都是以2进制补码形式进行存储\n\n   根据原码计算补码：\n\n   1. 原码和补码是以0开头的数字表示正数，以1开头的数字表示负数，最前面1位是符号位\n\n   2. 正数的补码和他的原码是相同的\n\n   3. 负数的补码是他的原码符号位不变，其他位取反再加1\n\n      如果数据超出4位补码所能表示的范畴，\n\n      超出8位采用补码来进行表示，\n\n      超出8位采用16位\n\n      超出16位采用\n\n   原码：\n\n   十进制 7 ==二进制0111；-7 ==10000111，最高位表示符号位\n\n   反码：\n\n   正数和原码一样，负数除去最高位其余位取反，例如 -7 == 1 1111000\n\n   补码：\n\n   正数和原码一样，负数-->补码等于反码加1;例如 -7 ==反码 1 1111000 + 1 ==1 1111001\n\n   总结：\n\n   4位2进制补码最多可以表示2^4个数\n\n   范围-2^3---->2^3-1\n\n   8位2进制补码最多可以表示2^8个数\n\n   范围-2^8--->2^8-1\n\n   16位2进制补码最多可以表示2^16个数\n\n   范围-2^15--->2^15-1\n\n   32位2进制补码最多可以表示2^31个数\n\n   范围-2^31--->2^31-1\n\n   64位2进制补码最多可以表示2^64个数\n\n   范围-2^63--->2^63-1\n\n   在计算机中1个0或者1个1被称为叫1位\n\n   用 1 bit 表示,bit是计算机最小的数据存储单元\n\n   8位2进制补码通常被称为1个字节,用1byte来进行表示，是计算机中最小的操作单元\n\n   1byte = 8bit\n\n   1kb = 1024byte\n\n   1mb = 1024kb\n\n   1gb = 1024mb\n\n9. 变量\n\n   1. 什么是变量\n\n      对应的是内存中的一块存储空间，可以用来存储一个值变量可以进行命名，可以通过变量名来操作变量中所存储的值变量中所存储的值是可以改变的\n\n   2. 变量的使用\n\n      定义一个变量，类型为int，名称为X    int = 10；\n\n      将10赋值给X\n\n      = 理解为赋值，将右侧的值赋值给左侧的变量\n\n   3. 变量得定义和赋值\n\n      定义：也叫声明，在内存中开辟了一块空间\n\n      赋值：往往这块空间中存储一个数据\n\n   4. 变量的作用域范围\n\n      从变量的定义的地方开始，到他所属代码块的结束\n\n      离开作用域范围后，该变量将被系统回收（无效了）\n\n   5. 变量的命名规范\n\n      - 强制性命名规范（不遵守就报错）\n      - 建议性命名规范（不遵守不会报错，但是不专业）\n\n10. 数据类型\n\n    - 八种基本类型\n\n      1. 整数类型（有范围）\n\n         1.1 byte  字节型 一个字节8位，范围  -2^7~2^7-1\n\n         1.2 short 短整型 两个字节16位，范围 -2^15~2^15-1\n\n         1.3 int  整型 四个字节32位，范围 -2^31~2^31-1\n\n         1.4 long 长整型 八个字节64位，范围 -2^63~2^63-1\n\n         ​\t如果右侧值超出了int最大值或最小值范围必须在数字后面带上L或者l\n\n         ​\t其中一个整数变成long类型，结果值就是long类型\n\n         在Java种，int是整数的默认类型\n\n         将一个整数赋值给byte类型变量时，会去掉前面3个字节，保留最后一个字节，所以右侧整数值不能超过byte范围\n\n         将一个整数赋值给short类型变量时，会去掉前面2个字节保留最后2个字节，所以右侧整数值不能超过short范围\n\n         将一个整数赋值给long类型变量时\n\n         如果右侧整数值超过了int的范围，必须带上L或l，将右侧默认的32值改为64\n\n         如果右侧整数数值诶有超出int范围，可以带上L或者l也可以不带，如果不带，整数前面补上32个0，负数前面补上32个1一般建议long类型都带上L或者l\n\n      2. 小数类型\n\n         2.1 float\n\n         ​\t单精度浮点\n\n         ​\t32位，一个符号位，23个尾数位，8个指数位\n\n         2.2 double\n\n         ​\t双精度浮点\n\n         ​\t64位，一个符号位，52个尾数位，11个指数位\n\n         ​\t浮点数默认时double -->加上F或者f将右侧浮点数变为flaot类型 \n\n      3. 字符类型\n\n         char: 主要用于存储Java中的单个字符，其本质上存储的是一个16位无符号位(从0开始，最前面一位不表示符号）的整数，其范围[0~65535],使用char定义字符时，必须使用单引号引起来。且单引号中只能定义一个字符\n\n         ​\t编码：\n\n         ​\t给计算机中每个字符编一个数字，在计算机中存储这个字符时，实质上存储的是该字符对应的数字，再取出该数字时，再参考编码表，将该数字转化成字符\n\n         ​\tASCII编码\n      \n         ​\t只收录了英文字母和数字以及其他符号，范围时0-127,是单字节编码\n      \n         ​\tUnicode编码\n      \n         ​\t统一码，万国码\n      \n         ​\t科学家统计了世界上几乎所有国家的语言文字，符号以及括号等，给每个字符都进行统一的编码，Unicode编码采用的是固定的双字节编码。范围0-65535，完全兼容ASCII编码\n      \n         Java中的char类型参考的就是Unicode编码表\n      \n         使用一个4位16进制Unicode编码来表示一个字符 例如：'\\u0064'\n      \n         \n      \n      4. 布尔类型\n      \n         boolean，用于表示真和假\n         \n         该类型只有两个值，true和false，true表示真，false表示假，该类型一般用于判断\n         \n      5. String 字符串类型\n      \n         字符：\n      \n         ​\t只能用于存储单个字符，使用单引号引起来\n      \n         字符串：\n      \n         ​\t可以用于同时存储一道多个字符，使用双引号引起来\n      \n         ​\t字符串可以和任意类型的变量之间使用+做拼接，拼接完成后的结果还是一个字符串\n      \n         两侧都不是字符串时，+就是加法运算\n         \n      6. 类型转换\n      \n         一般只会发生在整数裂隙和浮点类型之间，char字符类型只跟int整形之间转换，且都需要强转\n      \n         byte->short->int->long->float->double\n      \n         ​       \n\n11. 运算符\n\n    1. 算术运算符\n\n       加号\t减号\t乘号\t除号\t自加\t自减\n\n       X++:后加加 先赋值，后自身加1\n\n       ++X:前加加 先自身加1，后赋值\n\n       X--:后减减 先赋值 后自身减1\n\n       --X:前减减 先自身减1 后赋值\n\n       | int a = 10; | a++ =10;  | a = 11  |\n       | ----------- | --------- | ------- |\n       | int a = 10; | ++a = 11; | a = 11; |\n       | int a = 10; | a-- = 10; | a = 9;  |\n       | int a = 10; | --a = 11; | a = 9;  |\n\n       \n\n    2. 比较运算符\n\n       小于号\t大于号\t小于等于号\t大于等于号\t等号\t不等于号\n\n    3. 赋值运算符\n\n       =\t+=\t-=\t*=\t/=\t%=\n\n    4. 逻辑运算符\n\n       && : 逻辑与：&&并且（左右两边只能时布尔类型表达式）左侧表达式一&&右侧表达式二只有当布尔表达式一和布尔表达式二都是true的时候结果才是true，任何一个表达式的值为False 结果都是false\n\n       短路与：false && 布尔表达式\n\n       逻辑与运算，如果左侧表达式计算结果为false那么右侧表达式二无论时true还是false结果都是False,此时右侧布尔表达式二值不参计算\n\n       || :逻辑或 左侧表达式一 || 右侧表达式二\t只要左侧布尔表达式一和右侧表达式二任意一个值为true结果就是true只有当两个表达式都是false的时候，结果才是false。\n\n       短路或：true || 表达式二\n\n       逻辑或运算，如果左侧布尔值表达式计算结果为true，那么布尔表达式二的值无论时true还是false结果都是true此时右侧表达式不参与计算。 \t\n\n       ！：逻辑非 ！后跟一个布尔表达式，非true就是false。非false就是true\n\n       逻辑与的优先级高于逻辑或\n\n    5. 三项运算符\n\n       ?:\n\n    6. 不常用——————位运算符\n\n       &  位与   1 true   0 false   按位求与\n\n       |  位或   1 true   0 false   按位求或\n\n       ~  位非   1变0     0变1\n\n       ^  异或   相同取0    不同取1\n\n    7. 位移运算符\n\n       \\>> 带符号右移\t正数右移左侧补0，负数右移左侧补1\n       \n       \\>>> 无符号右移   正数负数右移，左侧补0\n       \n       \\<< 带符号左移    正数负数左移，右侧补0\n\n12. 分支\n\n    **if**\n\n    如果布尔表达式判断位true则执行大括号中代码，如果为false则不执行\n\n    不论时true还是false都不影响后续带啊吗执行\n\n    ```java\n    if（布尔表达式）{\n    \t\t代码块\n    }\n    ```\n\n    如果布尔表达式为true则则执行i放后面的大号中的代码块yiruguo weil false,则执行else后面的大括号中代码块2\n\n    如果i发或者else后面大括号中有一块代码可以省略大括号\n\n    多层嵌套\n\n    if（布尔表达式）{代码块一}else if(布尔表达式){代码块二}\n\n    从上往下逐一判断所有if中的布尔表达式，只要有一个布尔表达式为true，就执行后面大括号中代码，执行完成后九立即跳出整个分支判断，后续的布尔表达式不在判断，如果所有布尔表达式判断为false，则执行else中代码块\n\n    **switch_case**\n\n    从上往下逐一和switch的变量进行匹配，如果匹配上了就执行case后面的代码块，如果碰到break就跳出整个分支判断，如果没有break就继续往下执行，知道碰到一个break再跳出如果所有case后面的值都没有匹配上联络就执行default下面的代码块。\n\n    swicth 后面小括号中允许的变量类型\n\n    jdk vetsion<=1.6\n\n    byte short int char enum\n\n    jdk version>=1.7\n\n    byte  short int char enum String\n\n    ```java\n    switch(变量){\n            case 值：\n                代码块\n                break；\n            case 值2：\n                break；\n            default:\n            \tbreak;\n    }\n    ```\n    \n    \n    \n13. 循环\n\n    重复的去执行某一段代码  \n\n    **for**\n\n    ```java\n    for(初始化表达式；布尔表达式；修改循环体变量){\n    \t循环体\n    }\n    ```\n\n    布尔表达式为true则执行循环体，为false跳出循环\n\n    死循环：布尔表达式不写或者第二个表达式为true或者第三个表达式没有\n\n    **while**\n\n    ```java\n    while(布尔表达式){\n        循环体\n    }\n    ```\n\n    先判断，后执行循环体\n\n    **do_while**\n\n    ```java\n    do{\n        循环体\n    } while (布尔表达式)\n    ```\n\n    先执行一次循环体，再判断是否继续执行\n\n14. 数组\n\n    1. 概念\n\n       对应内存中一块连续的储存空间，主要用于存储多个连续且类型相同的数据，数据中的每个数据叫做数组的元素\n\n    2. 定义和赋值\n\n       静态初始化只能在定义的时候赋值\n\n       动态初始化支持先定义后赋值\n\n    3. 特点\n\n       数组长度一旦确定就无能改变了\n\n       可以通过下标来获取或修改数组中的元素\n\n       数组中元素的下标从左到右，从0开始每次递增，最小下标0，最大下标length-1\n\n    4. 数组扩容\n\n       因为数组的长度是不可变的，所以扩容实质上创新的长度不一样的数组，然后原来的数组中的元素复制到新的数组中\n\n       1. 带返回值\n\n          新数组 = Arrays.copyOf(原数组，新数组的长度)\n\n       2. 不带返回值\n\n          System.arraycopy(原数组，数组开始复制元素的下标，新数组，往新数组第几个下标位置开始放元素，从原数组复制几个元素到新数组)；\n\n       ```java\n       System.arraycopy(Object src,int srcPos,Object dest, int destPos,int length)\n       ```\n\n       Object src  原数组   int srcPos 原数组开始复制元素的下标\n\n       Object dest 新数组   int destPos 往新数组第几个下标位置开始放元素\n\n       int length  从原数组复制几个元素复制到新数组\n\n    5. 二维数组\n\n       二维数组遍历，外层循环控制二维数组中的一位数组的下标，内层循环控制一位数组中元素的下标\n\n    6. 数组的遍历\n\n       通过元素的下标遍历，下标范围0~length\n\n       for循环遍历\n\n       for~each迭代器\n\n    7. 数组元素排序\n\n       将数组中元素按顺序从小到大或者 从大到小进行排序\n\n       1. 冒泡排序\n\n          思想：第一次比较相邻的两个元素，若前面的元素比后面的元素大则交换，没一趟比较完成后，都能从剩下元素中选出一个最大值\n\n       2. 插入排序\n\n          思想：将数组分为有序和无序两堆，每次从无序数组中取出第一个元素和有序数组 中的元素从后往前逐个比较，若比他小则交换，若比他大则停止交换\n\n       3. 选择排序\n\n          思想：每次从待排序的数组中选出一个最小值，将其放在已经排序好的数组的最后面，直到所有元素都排序完成\n\n       4. 快速排序\n       \n       5. 桶排序\n\n14. 函数\n\n    1. 什么是函数\n    \n       对代码块的提取和封装，并对其进行命名，也就是函数名，然后通过函数名可以对函数的调用，函数存在的目的是为了减少重复代码，实现代码复用\n    \n    2. 函数的定义\n    \n       返回值类型\n    \n       如果函数执行完成后需要给调用者一个返回值那么返回值类型就必须于结果值类型相同，同时在函数的最后通过return结果值\n    \n       如果函数执行完成后不需要返回结果给调用者，那么返回值类型就写void代表无返回们同时函数中不能写return标识函数到此结束\n    \n       return返回值\n    \n       将函数计算的结果返回调用者，同时函数执行到此结束\n    \n       return\n    \n       指标是函数执行到此结束\n    \n       命名规范和变量名相同\n    \n       形参，形式参数\n    \n       形参的作用就是规定传给函数的值必须是什么类型，在函数调用时会将实参值赋给形参\n       \n    3. 函数重载\n    \n       同名不同参\n    \n       一个类中多个函数之间函数名称相同但是参数列表不同但是参数列表不同，与返回值无关\n    \n    4. 函数的可变参数\n    \n       定义一个函数，用于计算若干个整数的和传入几个整数，就将几个整数的和加起来，然后返回给调用者\n    \n       语法：add(int... arr)\n    \n       在调用add()函数时可以传入0到多个实参数值，在函数内部可变参数可以当做是数组来使用，可以进行遍历获取长度使用下标\n    \n       注意：\n    \n       1. 一个函数中最多只能有一个可变参数\n       2. 如果有其他形参时，可变参数必须放在最后\n    \n    5. 函数递归\n    \n       注意：\n    \n       1. 递归必须指定结束条件，否则就会报错StackOverFlowError错误，栈内存溢出\n       2. 递归的效率非常低一般不建议使用\n    \n       递归的常见使用场景\n    \n       1. 求一个数的阶乘\n       2. 求一个数的累加和\n       3. 求斐波那契数列\n       4. 文件夹遍历\n       5. 二叉树\n    \n16. 标识符\n\n    有程序员自己定义的包名、类名、变量名、函数名，需要满足一定的规范\n\n    1. 强制性规范\n    2. 建议性规范\n\n","source":"_posts/JAVA基础.md","raw":"---\ntitle: Java基础\ndate: 2023-01-05 11:18:57\ntags: Java\ncategories: Java\ncover: /img/images/Java.jpg\n---\n\n# JAVA基础\n\n### 一、什么是JAVA\n\nSun公司在1995年向外发布推广的一款面向对象的高级程序设计语言\n\n其主要应用于互联网后端服务器开发，大数据，安卓，网页，游戏等领域\n\n### 二、JAVA语言技术体系\n\n1. JavaSE(Java Platform Standard Edition)\n\n   Java标准版，主要包含Java基础语法，主要用于开发桌面软件及游戏\n\n   \n\n2. JavaME(Java Platform Micro Edition)\n\n   Java微型版，主要用于开发移动端设备和嵌入式设备的软件，如手机、pda、机顶盒、车载等\n\n   \n\n3. JavaEE(Java Platform Enterprise Edition)\n\n   Java企业版，主要用于开发互联网企业后台服务器端，为企业级开发提供解决方案\n\n   企业级软件：\n\n   公司：OA、ERP、CRM、SNS、财务、人事考勤....\n\n   学校：学生管理系统、宿舍管理系统、考试系统....\n\n   互联网：百度，京东，淘宝，B站....\n\n   其他：教育、视频、直播、电信、电力、金融、电商\n\n### 三、Java语言特点\n\n1. 应用面广\n2. Java简单易学（相对于C/C++）\n3. 面向对象(更符合我们看待事务特点)\n4. 跨平台(一处编译，处处运行)\n5. 多线程(提升系统的运行性能和效率)\n6. 分布式(解决高并发，高可用，高性能问题)\n7. 健壮性(强类型、垃圾回收、异常处理)\n8. 安全性\n9. 开源\n\n### 四、Java开发环境搭建\n\n1. JVM\n\n   Java Virtual Machine\n\n   Java虚拟机\n\n   Java程序是运行在虚拟机之上，JVM是Java程序能够实现跨平台的基础\n\n   \n\n2. JRE\n\n   Java Runtime Environment\n\n   Java运行时环境\n\n   JRE=JVM+运行时需要的环境\n\n   \n\n3. JDK\n\n   Java Develop Kit\n\n   Java 开发工具包\n\n   提供给Java开发人员使用的，其中包含Java开发需要的软件\n\n   JDK=JRE+Java开发工具\n\n\n\n### 五、环境变量配置\n\n1. 新建JAVA_HOME\n\n   变量名：JAVA_HOME\n\n   变量值：填写JDK 安装目录\n\n2. 新建CLASSPATH\n\n   变量名：CLASSPATH\n\n   变量值：.\n\n   ​\t\t.;%JAVA_HOME%\\lib\n\n   ​\t\t.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar\n\n3. 找到Path\n\n   新建：%JAVA_HOME%\\bin\n\n   新建：%JAVA_HOME%\\jre\\bin\n\n测试环境变量是否配置成功：\n\n1. win+R打开运行窗口\n2. 输入cmd。点击确定打开命令行窗口\n3. 输入javac或者java -version\n4. 显示日志或者版本号则表明配置成功，不显示则表示配置失败\n\n\n\n### 六、跨平台\n\n因为有了JVM，同一份字节码文件可以在三个不同的平台上都能运行，这样就实现了Java程序的跨平\n\n\n\n### 七、第一个Java程序\n\n1. Java项目的目录结构\n\n   Java Project\n\n   Java工程，Java项目，可以理解为是一个总文件夹\n\n   JRE System Library\n\n   > Java运行环境(系统库)\n\n   src\n\n   > 编写Java源代码的位置\n\n   bin\n\n   > 用于存储编译后的.class字节码文件\n\n2. Package\n\n   包，创建在src下面，可以理解为是一个子文件夹\n\n3. Class\n\n   类，创建在Package下面，就是一个Java源文件\n\n4. Java程序运行方式\n\n   4.1 菜单栏点击绿色箭头\n\n   4.2 右键-->Run As-->Java Application\n\n   4.3 Ctrl+F11\n\n5. Java中注释\n\n6. 注释：对Java代码起到一个解释说明的作用，不参与编译和运行过程，相当于产品说明书\n\n   单行注释：//\n\n   多行注释：/*\n\n   ​\t\t*/\n\n   文档注释：/**\n\n   ​\t\t*/\n\n   > 注意：main函数，程序执行的入口\n   >\n   > public static void main(String[] args){}\n   >\n   > 注意：输出语句\n   >\n   > System.out.println(\"要输出的内容\");\n\n7. 基本语法规范\n\n   7.1大小写严格区分\n\n   7.2中英文严格区分（所有阔符号如为\n\n   7.3括号必须成对出现\n\n   7.4没行代码结束之后必须以分号结尾\n\n   7.5大括号标识一个结构，结尾不用打分号\n\n8. 进制\n\n   1. 二进制：\n\n      逢二进一\n\n      二进制转十进制\n\n      二进制 权（2^n)\n\n   2. 十进制：\n\n      逢十进一\n\n      十进制转二进制 短除法    \n\n   3. 八进制：                \n\n      逢八进一              \n\n   4. 十六进制：\n\n      逢十六进一\n\n   | 10进制 | 2进制 | 8进制 | 16进制 |\n   | ------ | ----- | ----- | ------ |\n   | 0      | 0000  | 0     | 0      |\n   | 1      | 0001  | 1     | 1      |\n   | 2      | 0010  | 2     | 2      |\n   | 3      | 0011  | 3     | 3      |\n   | 4      | 0100  | 4     | 4      |\n   | 5      | 0101  | 5     | 5      |\n   | 6      | 0110  | 6     | 6      |\n   | 7      | 0111  | 7     | 7      |\n   | 8      | 1000  | 10    | 8      |\n   | 9      | 1001  | 11    | 9      |\n   | 10     | 1010  | 12    | A      |\n   | 11     | 1011  | 13    | B      |\n   | 12     | 1100  | 14    | C      |\n   | 13     | 1101  | 15    | D      |\n   | 14     | 1110  | 16    | E      |\n   | 15     | 1111  | 17    | F      |\n   | 16     | 10000 | 20    | 10     |\n\n   在计算机中所有的数据(图片、音频、文本等资源)都是以2进制补码形式进行存储\n\n   根据原码计算补码：\n\n   1. 原码和补码是以0开头的数字表示正数，以1开头的数字表示负数，最前面1位是符号位\n\n   2. 正数的补码和他的原码是相同的\n\n   3. 负数的补码是他的原码符号位不变，其他位取反再加1\n\n      如果数据超出4位补码所能表示的范畴，\n\n      超出8位采用补码来进行表示，\n\n      超出8位采用16位\n\n      超出16位采用\n\n   原码：\n\n   十进制 7 ==二进制0111；-7 ==10000111，最高位表示符号位\n\n   反码：\n\n   正数和原码一样，负数除去最高位其余位取反，例如 -7 == 1 1111000\n\n   补码：\n\n   正数和原码一样，负数-->补码等于反码加1;例如 -7 ==反码 1 1111000 + 1 ==1 1111001\n\n   总结：\n\n   4位2进制补码最多可以表示2^4个数\n\n   范围-2^3---->2^3-1\n\n   8位2进制补码最多可以表示2^8个数\n\n   范围-2^8--->2^8-1\n\n   16位2进制补码最多可以表示2^16个数\n\n   范围-2^15--->2^15-1\n\n   32位2进制补码最多可以表示2^31个数\n\n   范围-2^31--->2^31-1\n\n   64位2进制补码最多可以表示2^64个数\n\n   范围-2^63--->2^63-1\n\n   在计算机中1个0或者1个1被称为叫1位\n\n   用 1 bit 表示,bit是计算机最小的数据存储单元\n\n   8位2进制补码通常被称为1个字节,用1byte来进行表示，是计算机中最小的操作单元\n\n   1byte = 8bit\n\n   1kb = 1024byte\n\n   1mb = 1024kb\n\n   1gb = 1024mb\n\n9. 变量\n\n   1. 什么是变量\n\n      对应的是内存中的一块存储空间，可以用来存储一个值变量可以进行命名，可以通过变量名来操作变量中所存储的值变量中所存储的值是可以改变的\n\n   2. 变量的使用\n\n      定义一个变量，类型为int，名称为X    int = 10；\n\n      将10赋值给X\n\n      = 理解为赋值，将右侧的值赋值给左侧的变量\n\n   3. 变量得定义和赋值\n\n      定义：也叫声明，在内存中开辟了一块空间\n\n      赋值：往往这块空间中存储一个数据\n\n   4. 变量的作用域范围\n\n      从变量的定义的地方开始，到他所属代码块的结束\n\n      离开作用域范围后，该变量将被系统回收（无效了）\n\n   5. 变量的命名规范\n\n      - 强制性命名规范（不遵守就报错）\n      - 建议性命名规范（不遵守不会报错，但是不专业）\n\n10. 数据类型\n\n    - 八种基本类型\n\n      1. 整数类型（有范围）\n\n         1.1 byte  字节型 一个字节8位，范围  -2^7~2^7-1\n\n         1.2 short 短整型 两个字节16位，范围 -2^15~2^15-1\n\n         1.3 int  整型 四个字节32位，范围 -2^31~2^31-1\n\n         1.4 long 长整型 八个字节64位，范围 -2^63~2^63-1\n\n         ​\t如果右侧值超出了int最大值或最小值范围必须在数字后面带上L或者l\n\n         ​\t其中一个整数变成long类型，结果值就是long类型\n\n         在Java种，int是整数的默认类型\n\n         将一个整数赋值给byte类型变量时，会去掉前面3个字节，保留最后一个字节，所以右侧整数值不能超过byte范围\n\n         将一个整数赋值给short类型变量时，会去掉前面2个字节保留最后2个字节，所以右侧整数值不能超过short范围\n\n         将一个整数赋值给long类型变量时\n\n         如果右侧整数值超过了int的范围，必须带上L或l，将右侧默认的32值改为64\n\n         如果右侧整数数值诶有超出int范围，可以带上L或者l也可以不带，如果不带，整数前面补上32个0，负数前面补上32个1一般建议long类型都带上L或者l\n\n      2. 小数类型\n\n         2.1 float\n\n         ​\t单精度浮点\n\n         ​\t32位，一个符号位，23个尾数位，8个指数位\n\n         2.2 double\n\n         ​\t双精度浮点\n\n         ​\t64位，一个符号位，52个尾数位，11个指数位\n\n         ​\t浮点数默认时double -->加上F或者f将右侧浮点数变为flaot类型 \n\n      3. 字符类型\n\n         char: 主要用于存储Java中的单个字符，其本质上存储的是一个16位无符号位(从0开始，最前面一位不表示符号）的整数，其范围[0~65535],使用char定义字符时，必须使用单引号引起来。且单引号中只能定义一个字符\n\n         ​\t编码：\n\n         ​\t给计算机中每个字符编一个数字，在计算机中存储这个字符时，实质上存储的是该字符对应的数字，再取出该数字时，再参考编码表，将该数字转化成字符\n\n         ​\tASCII编码\n      \n         ​\t只收录了英文字母和数字以及其他符号，范围时0-127,是单字节编码\n      \n         ​\tUnicode编码\n      \n         ​\t统一码，万国码\n      \n         ​\t科学家统计了世界上几乎所有国家的语言文字，符号以及括号等，给每个字符都进行统一的编码，Unicode编码采用的是固定的双字节编码。范围0-65535，完全兼容ASCII编码\n      \n         Java中的char类型参考的就是Unicode编码表\n      \n         使用一个4位16进制Unicode编码来表示一个字符 例如：'\\u0064'\n      \n         \n      \n      4. 布尔类型\n      \n         boolean，用于表示真和假\n         \n         该类型只有两个值，true和false，true表示真，false表示假，该类型一般用于判断\n         \n      5. String 字符串类型\n      \n         字符：\n      \n         ​\t只能用于存储单个字符，使用单引号引起来\n      \n         字符串：\n      \n         ​\t可以用于同时存储一道多个字符，使用双引号引起来\n      \n         ​\t字符串可以和任意类型的变量之间使用+做拼接，拼接完成后的结果还是一个字符串\n      \n         两侧都不是字符串时，+就是加法运算\n         \n      6. 类型转换\n      \n         一般只会发生在整数裂隙和浮点类型之间，char字符类型只跟int整形之间转换，且都需要强转\n      \n         byte->short->int->long->float->double\n      \n         ​       \n\n11. 运算符\n\n    1. 算术运算符\n\n       加号\t减号\t乘号\t除号\t自加\t自减\n\n       X++:后加加 先赋值，后自身加1\n\n       ++X:前加加 先自身加1，后赋值\n\n       X--:后减减 先赋值 后自身减1\n\n       --X:前减减 先自身减1 后赋值\n\n       | int a = 10; | a++ =10;  | a = 11  |\n       | ----------- | --------- | ------- |\n       | int a = 10; | ++a = 11; | a = 11; |\n       | int a = 10; | a-- = 10; | a = 9;  |\n       | int a = 10; | --a = 11; | a = 9;  |\n\n       \n\n    2. 比较运算符\n\n       小于号\t大于号\t小于等于号\t大于等于号\t等号\t不等于号\n\n    3. 赋值运算符\n\n       =\t+=\t-=\t*=\t/=\t%=\n\n    4. 逻辑运算符\n\n       && : 逻辑与：&&并且（左右两边只能时布尔类型表达式）左侧表达式一&&右侧表达式二只有当布尔表达式一和布尔表达式二都是true的时候结果才是true，任何一个表达式的值为False 结果都是false\n\n       短路与：false && 布尔表达式\n\n       逻辑与运算，如果左侧表达式计算结果为false那么右侧表达式二无论时true还是false结果都是False,此时右侧布尔表达式二值不参计算\n\n       || :逻辑或 左侧表达式一 || 右侧表达式二\t只要左侧布尔表达式一和右侧表达式二任意一个值为true结果就是true只有当两个表达式都是false的时候，结果才是false。\n\n       短路或：true || 表达式二\n\n       逻辑或运算，如果左侧布尔值表达式计算结果为true，那么布尔表达式二的值无论时true还是false结果都是true此时右侧表达式不参与计算。 \t\n\n       ！：逻辑非 ！后跟一个布尔表达式，非true就是false。非false就是true\n\n       逻辑与的优先级高于逻辑或\n\n    5. 三项运算符\n\n       ?:\n\n    6. 不常用——————位运算符\n\n       &  位与   1 true   0 false   按位求与\n\n       |  位或   1 true   0 false   按位求或\n\n       ~  位非   1变0     0变1\n\n       ^  异或   相同取0    不同取1\n\n    7. 位移运算符\n\n       \\>> 带符号右移\t正数右移左侧补0，负数右移左侧补1\n       \n       \\>>> 无符号右移   正数负数右移，左侧补0\n       \n       \\<< 带符号左移    正数负数左移，右侧补0\n\n12. 分支\n\n    **if**\n\n    如果布尔表达式判断位true则执行大括号中代码，如果为false则不执行\n\n    不论时true还是false都不影响后续带啊吗执行\n\n    ```java\n    if（布尔表达式）{\n    \t\t代码块\n    }\n    ```\n\n    如果布尔表达式为true则则执行i放后面的大号中的代码块yiruguo weil false,则执行else后面的大括号中代码块2\n\n    如果i发或者else后面大括号中有一块代码可以省略大括号\n\n    多层嵌套\n\n    if（布尔表达式）{代码块一}else if(布尔表达式){代码块二}\n\n    从上往下逐一判断所有if中的布尔表达式，只要有一个布尔表达式为true，就执行后面大括号中代码，执行完成后九立即跳出整个分支判断，后续的布尔表达式不在判断，如果所有布尔表达式判断为false，则执行else中代码块\n\n    **switch_case**\n\n    从上往下逐一和switch的变量进行匹配，如果匹配上了就执行case后面的代码块，如果碰到break就跳出整个分支判断，如果没有break就继续往下执行，知道碰到一个break再跳出如果所有case后面的值都没有匹配上联络就执行default下面的代码块。\n\n    swicth 后面小括号中允许的变量类型\n\n    jdk vetsion<=1.6\n\n    byte short int char enum\n\n    jdk version>=1.7\n\n    byte  short int char enum String\n\n    ```java\n    switch(变量){\n            case 值：\n                代码块\n                break；\n            case 值2：\n                break；\n            default:\n            \tbreak;\n    }\n    ```\n    \n    \n    \n13. 循环\n\n    重复的去执行某一段代码  \n\n    **for**\n\n    ```java\n    for(初始化表达式；布尔表达式；修改循环体变量){\n    \t循环体\n    }\n    ```\n\n    布尔表达式为true则执行循环体，为false跳出循环\n\n    死循环：布尔表达式不写或者第二个表达式为true或者第三个表达式没有\n\n    **while**\n\n    ```java\n    while(布尔表达式){\n        循环体\n    }\n    ```\n\n    先判断，后执行循环体\n\n    **do_while**\n\n    ```java\n    do{\n        循环体\n    } while (布尔表达式)\n    ```\n\n    先执行一次循环体，再判断是否继续执行\n\n14. 数组\n\n    1. 概念\n\n       对应内存中一块连续的储存空间，主要用于存储多个连续且类型相同的数据，数据中的每个数据叫做数组的元素\n\n    2. 定义和赋值\n\n       静态初始化只能在定义的时候赋值\n\n       动态初始化支持先定义后赋值\n\n    3. 特点\n\n       数组长度一旦确定就无能改变了\n\n       可以通过下标来获取或修改数组中的元素\n\n       数组中元素的下标从左到右，从0开始每次递增，最小下标0，最大下标length-1\n\n    4. 数组扩容\n\n       因为数组的长度是不可变的，所以扩容实质上创新的长度不一样的数组，然后原来的数组中的元素复制到新的数组中\n\n       1. 带返回值\n\n          新数组 = Arrays.copyOf(原数组，新数组的长度)\n\n       2. 不带返回值\n\n          System.arraycopy(原数组，数组开始复制元素的下标，新数组，往新数组第几个下标位置开始放元素，从原数组复制几个元素到新数组)；\n\n       ```java\n       System.arraycopy(Object src,int srcPos,Object dest, int destPos,int length)\n       ```\n\n       Object src  原数组   int srcPos 原数组开始复制元素的下标\n\n       Object dest 新数组   int destPos 往新数组第几个下标位置开始放元素\n\n       int length  从原数组复制几个元素复制到新数组\n\n    5. 二维数组\n\n       二维数组遍历，外层循环控制二维数组中的一位数组的下标，内层循环控制一位数组中元素的下标\n\n    6. 数组的遍历\n\n       通过元素的下标遍历，下标范围0~length\n\n       for循环遍历\n\n       for~each迭代器\n\n    7. 数组元素排序\n\n       将数组中元素按顺序从小到大或者 从大到小进行排序\n\n       1. 冒泡排序\n\n          思想：第一次比较相邻的两个元素，若前面的元素比后面的元素大则交换，没一趟比较完成后，都能从剩下元素中选出一个最大值\n\n       2. 插入排序\n\n          思想：将数组分为有序和无序两堆，每次从无序数组中取出第一个元素和有序数组 中的元素从后往前逐个比较，若比他小则交换，若比他大则停止交换\n\n       3. 选择排序\n\n          思想：每次从待排序的数组中选出一个最小值，将其放在已经排序好的数组的最后面，直到所有元素都排序完成\n\n       4. 快速排序\n       \n       5. 桶排序\n\n14. 函数\n\n    1. 什么是函数\n    \n       对代码块的提取和封装，并对其进行命名，也就是函数名，然后通过函数名可以对函数的调用，函数存在的目的是为了减少重复代码，实现代码复用\n    \n    2. 函数的定义\n    \n       返回值类型\n    \n       如果函数执行完成后需要给调用者一个返回值那么返回值类型就必须于结果值类型相同，同时在函数的最后通过return结果值\n    \n       如果函数执行完成后不需要返回结果给调用者，那么返回值类型就写void代表无返回们同时函数中不能写return标识函数到此结束\n    \n       return返回值\n    \n       将函数计算的结果返回调用者，同时函数执行到此结束\n    \n       return\n    \n       指标是函数执行到此结束\n    \n       命名规范和变量名相同\n    \n       形参，形式参数\n    \n       形参的作用就是规定传给函数的值必须是什么类型，在函数调用时会将实参值赋给形参\n       \n    3. 函数重载\n    \n       同名不同参\n    \n       一个类中多个函数之间函数名称相同但是参数列表不同但是参数列表不同，与返回值无关\n    \n    4. 函数的可变参数\n    \n       定义一个函数，用于计算若干个整数的和传入几个整数，就将几个整数的和加起来，然后返回给调用者\n    \n       语法：add(int... arr)\n    \n       在调用add()函数时可以传入0到多个实参数值，在函数内部可变参数可以当做是数组来使用，可以进行遍历获取长度使用下标\n    \n       注意：\n    \n       1. 一个函数中最多只能有一个可变参数\n       2. 如果有其他形参时，可变参数必须放在最后\n    \n    5. 函数递归\n    \n       注意：\n    \n       1. 递归必须指定结束条件，否则就会报错StackOverFlowError错误，栈内存溢出\n       2. 递归的效率非常低一般不建议使用\n    \n       递归的常见使用场景\n    \n       1. 求一个数的阶乘\n       2. 求一个数的累加和\n       3. 求斐波那契数列\n       4. 文件夹遍历\n       5. 二叉树\n    \n16. 标识符\n\n    有程序员自己定义的包名、类名、变量名、函数名，需要满足一定的规范\n\n    1. 强制性规范\n    2. 建议性规范\n\n","slug":"JAVA基础","published":1,"updated":"2023-08-10T09:48:49.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw940009fswoa7vf9h1a","content":"<h1 id=\"JAVA基础\"><a href=\"#JAVA基础\" class=\"headerlink\" title=\"JAVA基础\"></a>JAVA基础</h1><h3 id=\"一、什么是JAVA\"><a href=\"#一、什么是JAVA\" class=\"headerlink\" title=\"一、什么是JAVA\"></a>一、什么是JAVA</h3><p>Sun公司在1995年向外发布推广的一款面向对象的高级程序设计语言</p>\n<p>其主要应用于互联网后端服务器开发，大数据，安卓，网页，游戏等领域</p>\n<h3 id=\"二、JAVA语言技术体系\"><a href=\"#二、JAVA语言技术体系\" class=\"headerlink\" title=\"二、JAVA语言技术体系\"></a>二、JAVA语言技术体系</h3><ol>\n<li><p>JavaSE(Java Platform Standard Edition)</p>\n<p>Java标准版，主要包含Java基础语法，主要用于开发桌面软件及游戏</p>\n</li>\n<li><p>JavaME(Java Platform Micro Edition)</p>\n<p>Java微型版，主要用于开发移动端设备和嵌入式设备的软件，如手机、pda、机顶盒、车载等</p>\n</li>\n<li><p>JavaEE(Java Platform Enterprise Edition)</p>\n<p>Java企业版，主要用于开发互联网企业后台服务器端，为企业级开发提供解决方案</p>\n<p>企业级软件：</p>\n<p>公司：OA、ERP、CRM、SNS、财务、人事考勤….</p>\n<p>学校：学生管理系统、宿舍管理系统、考试系统….</p>\n<p>互联网：百度，京东，淘宝，B站….</p>\n<p>其他：教育、视频、直播、电信、电力、金融、电商</p>\n</li>\n</ol>\n<h3 id=\"三、Java语言特点\"><a href=\"#三、Java语言特点\" class=\"headerlink\" title=\"三、Java语言特点\"></a>三、Java语言特点</h3><ol>\n<li>应用面广</li>\n<li>Java简单易学（相对于C&#x2F;C++）</li>\n<li>面向对象(更符合我们看待事务特点)</li>\n<li>跨平台(一处编译，处处运行)</li>\n<li>多线程(提升系统的运行性能和效率)</li>\n<li>分布式(解决高并发，高可用，高性能问题)</li>\n<li>健壮性(强类型、垃圾回收、异常处理)</li>\n<li>安全性</li>\n<li>开源</li>\n</ol>\n<h3 id=\"四、Java开发环境搭建\"><a href=\"#四、Java开发环境搭建\" class=\"headerlink\" title=\"四、Java开发环境搭建\"></a>四、Java开发环境搭建</h3><ol>\n<li><p>JVM</p>\n<p>Java Virtual Machine</p>\n<p>Java虚拟机</p>\n<p>Java程序是运行在虚拟机之上，JVM是Java程序能够实现跨平台的基础</p>\n</li>\n<li><p>JRE</p>\n<p>Java Runtime Environment</p>\n<p>Java运行时环境</p>\n<p>JRE&#x3D;JVM+运行时需要的环境</p>\n</li>\n<li><p>JDK</p>\n<p>Java Develop Kit</p>\n<p>Java 开发工具包</p>\n<p>提供给Java开发人员使用的，其中包含Java开发需要的软件</p>\n<p>JDK&#x3D;JRE+Java开发工具</p>\n</li>\n</ol>\n<h3 id=\"五、环境变量配置\"><a href=\"#五、环境变量配置\" class=\"headerlink\" title=\"五、环境变量配置\"></a>五、环境变量配置</h3><ol>\n<li><p>新建JAVA_HOME</p>\n<p>变量名：JAVA_HOME</p>\n<p>变量值：填写JDK 安装目录</p>\n</li>\n<li><p>新建CLASSPATH</p>\n<p>变量名：CLASSPATH</p>\n<p>变量值：.</p>\n<p>​\t\t.;%JAVA_HOME%\\lib</p>\n<p>​\t\t.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar</p>\n</li>\n<li><p>找到Path</p>\n<p>新建：%JAVA_HOME%\\bin</p>\n<p>新建：%JAVA_HOME%\\jre\\bin</p>\n</li>\n</ol>\n<p>测试环境变量是否配置成功：</p>\n<ol>\n<li>win+R打开运行窗口</li>\n<li>输入cmd。点击确定打开命令行窗口</li>\n<li>输入javac或者java -version</li>\n<li>显示日志或者版本号则表明配置成功，不显示则表示配置失败</li>\n</ol>\n<h3 id=\"六、跨平台\"><a href=\"#六、跨平台\" class=\"headerlink\" title=\"六、跨平台\"></a>六、跨平台</h3><p>因为有了JVM，同一份字节码文件可以在三个不同的平台上都能运行，这样就实现了Java程序的跨平</p>\n<h3 id=\"七、第一个Java程序\"><a href=\"#七、第一个Java程序\" class=\"headerlink\" title=\"七、第一个Java程序\"></a>七、第一个Java程序</h3><ol>\n<li><p>Java项目的目录结构</p>\n<p>Java Project</p>\n<p>Java工程，Java项目，可以理解为是一个总文件夹</p>\n<p>JRE System Library</p>\n<blockquote>\n<p>Java运行环境(系统库)</p>\n</blockquote>\n<p>src</p>\n<blockquote>\n<p>编写Java源代码的位置</p>\n</blockquote>\n<p>bin</p>\n<blockquote>\n<p>用于存储编译后的.class字节码文件</p>\n</blockquote>\n</li>\n<li><p>Package</p>\n<p>包，创建在src下面，可以理解为是一个子文件夹</p>\n</li>\n<li><p>Class</p>\n<p>类，创建在Package下面，就是一个Java源文件</p>\n</li>\n<li><p>Java程序运行方式</p>\n<p>4.1 菜单栏点击绿色箭头</p>\n<p>4.2 右键–&gt;Run As–&gt;Java Application</p>\n<p>4.3 Ctrl+F11</p>\n</li>\n<li><p>Java中注释</p>\n</li>\n<li><p>注释：对Java代码起到一个解释说明的作用，不参与编译和运行过程，相当于产品说明书</p>\n<p>单行注释：&#x2F;&#x2F;</p>\n<p>多行注释：&#x2F;*</p>\n<p>​\t\t*&#x2F;</p>\n<p>文档注释：&#x2F;**</p>\n<p>​\t\t*&#x2F;</p>\n<blockquote>\n<p>注意：main函数，程序执行的入口</p>\n<p>public static void main(String[] args){}</p>\n<p>注意：输出语句</p>\n<p>System.out.println(“要输出的内容”);</p>\n</blockquote>\n</li>\n<li><p>基本语法规范</p>\n<p>7.1大小写严格区分</p>\n<p>7.2中英文严格区分（所有阔符号如为</p>\n<p>7.3括号必须成对出现</p>\n<p>7.4没行代码结束之后必须以分号结尾</p>\n<p>7.5大括号标识一个结构，结尾不用打分号</p>\n</li>\n<li><p>进制</p>\n<ol>\n<li><p>二进制：</p>\n<p>逢二进一</p>\n<p>二进制转十进制</p>\n<p>二进制 权（2^n)</p>\n</li>\n<li><p>十进制：</p>\n<p>逢十进一</p>\n<p>十进制转二进制 短除法    </p>\n</li>\n<li><p>八进制：                </p>\n<p>逢八进一              </p>\n</li>\n<li><p>十六进制：</p>\n<p>逢十六进一</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>10进制</th>\n<th>2进制</th>\n<th>8进制</th>\n<th>16进制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0000</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0001</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0010</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0011</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n<td>0100</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0101</td>\n<td>5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>6</td>\n<td>0110</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>7</td>\n<td>0111</td>\n<td>7</td>\n<td>7</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1000</td>\n<td>10</td>\n<td>8</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>11</td>\n<td>9</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1010</td>\n<td>12</td>\n<td>A</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1011</td>\n<td>13</td>\n<td>B</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1100</td>\n<td>14</td>\n<td>C</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1101</td>\n<td>15</td>\n<td>D</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1110</td>\n<td>16</td>\n<td>E</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1111</td>\n<td>17</td>\n<td>F</td>\n</tr>\n<tr>\n<td>16</td>\n<td>10000</td>\n<td>20</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p>在计算机中所有的数据(图片、音频、文本等资源)都是以2进制补码形式进行存储</p>\n<p>根据原码计算补码：</p>\n<ol>\n<li><p>原码和补码是以0开头的数字表示正数，以1开头的数字表示负数，最前面1位是符号位</p>\n</li>\n<li><p>正数的补码和他的原码是相同的</p>\n</li>\n<li><p>负数的补码是他的原码符号位不变，其他位取反再加1</p>\n<p>如果数据超出4位补码所能表示的范畴，</p>\n<p>超出8位采用补码来进行表示，</p>\n<p>超出8位采用16位</p>\n<p>超出16位采用</p>\n</li>\n</ol>\n<p>原码：</p>\n<p>十进制 7 &#x3D;&#x3D;二进制0111；-7 &#x3D;&#x3D;10000111，最高位表示符号位</p>\n<p>反码：</p>\n<p>正数和原码一样，负数除去最高位其余位取反，例如 -7 &#x3D;&#x3D; 1 1111000</p>\n<p>补码：</p>\n<p>正数和原码一样，负数–&gt;补码等于反码加1;例如 -7 &#x3D;&#x3D;反码 1 1111000 + 1 &#x3D;&#x3D;1 1111001</p>\n<p>总结：</p>\n<p>4位2进制补码最多可以表示2^4个数</p>\n<p>范围-2^3—-&gt;2^3-1</p>\n<p>8位2进制补码最多可以表示2^8个数</p>\n<p>范围-2^8—&gt;2^8-1</p>\n<p>16位2进制补码最多可以表示2^16个数</p>\n<p>范围-2^15—&gt;2^15-1</p>\n<p>32位2进制补码最多可以表示2^31个数</p>\n<p>范围-2^31—&gt;2^31-1</p>\n<p>64位2进制补码最多可以表示2^64个数</p>\n<p>范围-2^63—&gt;2^63-1</p>\n<p>在计算机中1个0或者1个1被称为叫1位</p>\n<p>用 1 bit 表示,bit是计算机最小的数据存储单元</p>\n<p>8位2进制补码通常被称为1个字节,用1byte来进行表示，是计算机中最小的操作单元</p>\n<p>1byte &#x3D; 8bit</p>\n<p>1kb &#x3D; 1024byte</p>\n<p>1mb &#x3D; 1024kb</p>\n<p>1gb &#x3D; 1024mb</p>\n</li>\n<li><p>变量</p>\n<ol>\n<li><p>什么是变量</p>\n<p>对应的是内存中的一块存储空间，可以用来存储一个值变量可以进行命名，可以通过变量名来操作变量中所存储的值变量中所存储的值是可以改变的</p>\n</li>\n<li><p>变量的使用</p>\n<p>定义一个变量，类型为int，名称为X    int &#x3D; 10；</p>\n<p>将10赋值给X</p>\n<p>&#x3D; 理解为赋值，将右侧的值赋值给左侧的变量</p>\n</li>\n<li><p>变量得定义和赋值</p>\n<p>定义：也叫声明，在内存中开辟了一块空间</p>\n<p>赋值：往往这块空间中存储一个数据</p>\n</li>\n<li><p>变量的作用域范围</p>\n<p>从变量的定义的地方开始，到他所属代码块的结束</p>\n<p>离开作用域范围后，该变量将被系统回收（无效了）</p>\n</li>\n<li><p>变量的命名规范</p>\n<ul>\n<li>强制性命名规范（不遵守就报错）</li>\n<li>建议性命名规范（不遵守不会报错，但是不专业）</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>数据类型</p>\n<ul>\n<li><p>八种基本类型</p>\n<ol>\n<li><p>整数类型（有范围）</p>\n<p>1.1 byte  字节型 一个字节8位，范围  -2^7~2^7-1</p>\n<p>1.2 short 短整型 两个字节16位，范围 -2^15~2^15-1</p>\n<p>1.3 int  整型 四个字节32位，范围 -2^31~2^31-1</p>\n<p>1.4 long 长整型 八个字节64位，范围 -2^63~2^63-1</p>\n<p>​\t如果右侧值超出了int最大值或最小值范围必须在数字后面带上L或者l</p>\n<p>​\t其中一个整数变成long类型，结果值就是long类型</p>\n<p>在Java种，int是整数的默认类型</p>\n<p>将一个整数赋值给byte类型变量时，会去掉前面3个字节，保留最后一个字节，所以右侧整数值不能超过byte范围</p>\n<p>将一个整数赋值给short类型变量时，会去掉前面2个字节保留最后2个字节，所以右侧整数值不能超过short范围</p>\n<p>将一个整数赋值给long类型变量时</p>\n<p>如果右侧整数值超过了int的范围，必须带上L或l，将右侧默认的32值改为64</p>\n<p>如果右侧整数数值诶有超出int范围，可以带上L或者l也可以不带，如果不带，整数前面补上32个0，负数前面补上32个1一般建议long类型都带上L或者l</p>\n</li>\n<li><p>小数类型</p>\n<p>2.1 float</p>\n<p>​\t单精度浮点</p>\n<p>​\t32位，一个符号位，23个尾数位，8个指数位</p>\n<p>2.2 double</p>\n<p>​\t双精度浮点</p>\n<p>​\t64位，一个符号位，52个尾数位，11个指数位</p>\n<p>​\t浮点数默认时double –&gt;加上F或者f将右侧浮点数变为flaot类型 </p>\n</li>\n<li><p>字符类型</p>\n<p>char: 主要用于存储Java中的单个字符，其本质上存储的是一个16位无符号位(从0开始，最前面一位不表示符号）的整数，其范围[0~65535],使用char定义字符时，必须使用单引号引起来。且单引号中只能定义一个字符</p>\n<p>​\t编码：</p>\n<p>​\t给计算机中每个字符编一个数字，在计算机中存储这个字符时，实质上存储的是该字符对应的数字，再取出该数字时，再参考编码表，将该数字转化成字符</p>\n<p>​\tASCII编码</p>\n<p>​\t只收录了英文字母和数字以及其他符号，范围时0-127,是单字节编码</p>\n<p>​\tUnicode编码</p>\n<p>​\t统一码，万国码</p>\n<p>​\t科学家统计了世界上几乎所有国家的语言文字，符号以及括号等，给每个字符都进行统一的编码，Unicode编码采用的是固定的双字节编码。范围0-65535，完全兼容ASCII编码</p>\n<p>Java中的char类型参考的就是Unicode编码表</p>\n<p>使用一个4位16进制Unicode编码来表示一个字符 例如：’\\u0064’</p>\n</li>\n<li><p>布尔类型</p>\n<p>boolean，用于表示真和假</p>\n<p>该类型只有两个值，true和false，true表示真，false表示假，该类型一般用于判断</p>\n</li>\n<li><p>String 字符串类型</p>\n<p>字符：</p>\n<p>​\t只能用于存储单个字符，使用单引号引起来</p>\n<p>字符串：</p>\n<p>​\t可以用于同时存储一道多个字符，使用双引号引起来</p>\n<p>​\t字符串可以和任意类型的变量之间使用+做拼接，拼接完成后的结果还是一个字符串</p>\n<p>两侧都不是字符串时，+就是加法运算</p>\n</li>\n<li><p>类型转换</p>\n<p>一般只会发生在整数裂隙和浮点类型之间，char字符类型只跟int整形之间转换，且都需要强转</p>\n<p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>运算符</p>\n<ol>\n<li><p>算术运算符</p>\n<p>加号\t减号\t乘号\t除号\t自加\t自减</p>\n<p>X++:后加加 先赋值，后自身加1</p>\n<p>++X:前加加 先自身加1，后赋值</p>\n<p>X–:后减减 先赋值 后自身减1</p>\n<p>–X:前减减 先自身减1 后赋值</p>\n<table>\n<thead>\n<tr>\n<th>int a &#x3D; 10;</th>\n<th>a++ &#x3D;10;</th>\n<th>a &#x3D; 11</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int a &#x3D; 10;</td>\n<td>++a &#x3D; 11;</td>\n<td>a &#x3D; 11;</td>\n</tr>\n<tr>\n<td>int a &#x3D; 10;</td>\n<td>a– &#x3D; 10;</td>\n<td>a &#x3D; 9;</td>\n</tr>\n<tr>\n<td>int a &#x3D; 10;</td>\n<td>–a &#x3D; 11;</td>\n<td>a &#x3D; 9;</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>比较运算符</p>\n<p>小于号\t大于号\t小于等于号\t大于等于号\t等号\t不等于号</p>\n</li>\n<li><p>赋值运算符</p>\n<p>&#x3D;\t+&#x3D;\t-&#x3D;\t*&#x3D;\t&#x2F;&#x3D;\t%&#x3D;</p>\n</li>\n<li><p>逻辑运算符</p>\n<p>&amp;&amp; : 逻辑与：&amp;&amp;并且（左右两边只能时布尔类型表达式）左侧表达式一&amp;&amp;右侧表达式二只有当布尔表达式一和布尔表达式二都是true的时候结果才是true，任何一个表达式的值为False 结果都是false</p>\n<p>短路与：false &amp;&amp; 布尔表达式</p>\n<p>逻辑与运算，如果左侧表达式计算结果为false那么右侧表达式二无论时true还是false结果都是False,此时右侧布尔表达式二值不参计算</p>\n<p>|| :逻辑或 左侧表达式一 || 右侧表达式二\t只要左侧布尔表达式一和右侧表达式二任意一个值为true结果就是true只有当两个表达式都是false的时候，结果才是false。</p>\n<p>短路或：true || 表达式二</p>\n<p>逻辑或运算，如果左侧布尔值表达式计算结果为true，那么布尔表达式二的值无论时true还是false结果都是true此时右侧表达式不参与计算。 \t</p>\n<p>！：逻辑非 ！后跟一个布尔表达式，非true就是false。非false就是true</p>\n<p>逻辑与的优先级高于逻辑或</p>\n</li>\n<li><p>三项运算符</p>\n<p>?:</p>\n</li>\n<li><p>不常用——————位运算符</p>\n<p>&amp;  位与   1 true   0 false   按位求与</p>\n<p>|  位或   1 true   0 false   按位求或</p>\n<p>~  位非   1变0     0变1</p>\n<p>^  异或   相同取0    不同取1</p>\n</li>\n<li><p>位移运算符</p>\n<p>&gt;&gt; 带符号右移\t正数右移左侧补0，负数右移左侧补1</p>\n<p>&gt;&gt;&gt; 无符号右移   正数负数右移，左侧补0</p>\n<p>&lt;&lt; 带符号左移    正数负数左移，右侧补0</p>\n</li>\n</ol>\n</li>\n<li><p>分支</p>\n<p><strong>if</strong></p>\n<p>如果布尔表达式判断位true则执行大括号中代码，如果为false则不执行</p>\n<p>不论时true还是false都不影响后续带啊吗执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（布尔表达式）&#123;</span><br><span class=\"line\">\t\t代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果布尔表达式为true则则执行i放后面的大号中的代码块yiruguo weil false,则执行else后面的大括号中代码块2</p>\n<p>如果i发或者else后面大括号中有一块代码可以省略大括号</p>\n<p>多层嵌套</p>\n<p>if（布尔表达式）{代码块一}else if(布尔表达式){代码块二}</p>\n<p>从上往下逐一判断所有if中的布尔表达式，只要有一个布尔表达式为true，就执行后面大括号中代码，执行完成后九立即跳出整个分支判断，后续的布尔表达式不在判断，如果所有布尔表达式判断为false，则执行else中代码块</p>\n<p><strong>switch_case</strong></p>\n<p>从上往下逐一和switch的变量进行匹配，如果匹配上了就执行case后面的代码块，如果碰到break就跳出整个分支判断，如果没有break就继续往下执行，知道碰到一个break再跳出如果所有case后面的值都没有匹配上联络就执行default下面的代码块。</p>\n<p>swicth 后面小括号中允许的变量类型</p>\n<p>jdk vetsion&lt;&#x3D;1.6</p>\n<p>byte short int char enum</p>\n<p>jdk version&gt;&#x3D;1.7</p>\n<p>byte  short int char enum String</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(变量)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> 值：</span><br><span class=\"line\">            代码块</span><br><span class=\"line\">            <span class=\"keyword\">break</span>；</span><br><span class=\"line\">        <span class=\"keyword\">case</span> 值<span class=\"number\">2</span>：</span><br><span class=\"line\">            <span class=\"keyword\">break</span>；</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>循环</p>\n<p>重复的去执行某一段代码  </p>\n<p><strong>for</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(初始化表达式；布尔表达式；修改循环体变量)&#123;</span><br><span class=\"line\">\t循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>布尔表达式为true则执行循环体，为false跳出循环</p>\n<p>死循环：布尔表达式不写或者第二个表达式为true或者第三个表达式没有</p>\n<p><strong>while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(布尔表达式)&#123;</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先判断，后执行循环体</p>\n<p><strong>do_while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (布尔表达式)</span><br></pre></td></tr></table></figure>\n\n<p>先执行一次循环体，再判断是否继续执行</p>\n</li>\n<li><p>数组</p>\n<ol>\n<li><p>概念</p>\n<p>对应内存中一块连续的储存空间，主要用于存储多个连续且类型相同的数据，数据中的每个数据叫做数组的元素</p>\n</li>\n<li><p>定义和赋值</p>\n<p>静态初始化只能在定义的时候赋值</p>\n<p>动态初始化支持先定义后赋值</p>\n</li>\n<li><p>特点</p>\n<p>数组长度一旦确定就无能改变了</p>\n<p>可以通过下标来获取或修改数组中的元素</p>\n<p>数组中元素的下标从左到右，从0开始每次递增，最小下标0，最大下标length-1</p>\n</li>\n<li><p>数组扩容</p>\n<p>因为数组的长度是不可变的，所以扩容实质上创新的长度不一样的数组，然后原来的数组中的元素复制到新的数组中</p>\n<ol>\n<li><p>带返回值</p>\n<p>新数组 &#x3D; Arrays.copyOf(原数组，新数组的长度)</p>\n</li>\n<li><p>不带返回值</p>\n<p>System.arraycopy(原数组，数组开始复制元素的下标，新数组，往新数组第几个下标位置开始放元素，从原数组复制几个元素到新数组)；</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.arraycopy(Object src,<span class=\"type\">int</span> srcPos,Object dest, <span class=\"type\">int</span> destPos,<span class=\"type\">int</span> length)</span><br></pre></td></tr></table></figure>\n\n<p>Object src  原数组   int srcPos 原数组开始复制元素的下标</p>\n<p>Object dest 新数组   int destPos 往新数组第几个下标位置开始放元素</p>\n<p>int length  从原数组复制几个元素复制到新数组</p>\n</li>\n<li><p>二维数组</p>\n<p>二维数组遍历，外层循环控制二维数组中的一位数组的下标，内层循环控制一位数组中元素的下标</p>\n</li>\n<li><p>数组的遍历</p>\n<p>通过元素的下标遍历，下标范围0~length</p>\n<p>for循环遍历</p>\n<p>for~each迭代器</p>\n</li>\n<li><p>数组元素排序</p>\n<p>将数组中元素按顺序从小到大或者 从大到小进行排序</p>\n<ol>\n<li><p>冒泡排序</p>\n<p>思想：第一次比较相邻的两个元素，若前面的元素比后面的元素大则交换，没一趟比较完成后，都能从剩下元素中选出一个最大值</p>\n</li>\n<li><p>插入排序</p>\n<p>思想：将数组分为有序和无序两堆，每次从无序数组中取出第一个元素和有序数组 中的元素从后往前逐个比较，若比他小则交换，若比他大则停止交换</p>\n</li>\n<li><p>选择排序</p>\n<p>思想：每次从待排序的数组中选出一个最小值，将其放在已经排序好的数组的最后面，直到所有元素都排序完成</p>\n</li>\n<li><p>快速排序</p>\n</li>\n<li><p>桶排序</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>函数</p>\n<ol>\n<li><p>什么是函数</p>\n<p>对代码块的提取和封装，并对其进行命名，也就是函数名，然后通过函数名可以对函数的调用，函数存在的目的是为了减少重复代码，实现代码复用</p>\n</li>\n<li><p>函数的定义</p>\n<p>返回值类型</p>\n<p>如果函数执行完成后需要给调用者一个返回值那么返回值类型就必须于结果值类型相同，同时在函数的最后通过return结果值</p>\n<p>如果函数执行完成后不需要返回结果给调用者，那么返回值类型就写void代表无返回们同时函数中不能写return标识函数到此结束</p>\n<p>return返回值</p>\n<p>将函数计算的结果返回调用者，同时函数执行到此结束</p>\n<p>return</p>\n<p>指标是函数执行到此结束</p>\n<p>命名规范和变量名相同</p>\n<p>形参，形式参数</p>\n<p>形参的作用就是规定传给函数的值必须是什么类型，在函数调用时会将实参值赋给形参</p>\n</li>\n<li><p>函数重载</p>\n<p>同名不同参</p>\n<p>一个类中多个函数之间函数名称相同但是参数列表不同但是参数列表不同，与返回值无关</p>\n</li>\n<li><p>函数的可变参数</p>\n<p>定义一个函数，用于计算若干个整数的和传入几个整数，就将几个整数的和加起来，然后返回给调用者</p>\n<p>语法：add(int… arr)</p>\n<p>在调用add()函数时可以传入0到多个实参数值，在函数内部可变参数可以当做是数组来使用，可以进行遍历获取长度使用下标</p>\n<p>注意：</p>\n<ol>\n<li>一个函数中最多只能有一个可变参数</li>\n<li>如果有其他形参时，可变参数必须放在最后</li>\n</ol>\n</li>\n<li><p>函数递归</p>\n<p>注意：</p>\n<ol>\n<li>递归必须指定结束条件，否则就会报错StackOverFlowError错误，栈内存溢出</li>\n<li>递归的效率非常低一般不建议使用</li>\n</ol>\n<p>递归的常见使用场景</p>\n<ol>\n<li>求一个数的阶乘</li>\n<li>求一个数的累加和</li>\n<li>求斐波那契数列</li>\n<li>文件夹遍历</li>\n<li>二叉树</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>标识符</p>\n<p>有程序员自己定义的包名、类名、变量名、函数名，需要满足一定的规范</p>\n<ol>\n<li>强制性规范</li>\n<li>建议性规范</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"JAVA基础\"><a href=\"#JAVA基础\" class=\"headerlink\" title=\"JAVA基础\"></a>JAVA基础</h1><h3 id=\"一、什么是JAVA\"><a href=\"#一、什么是JAVA\" class=\"headerlink\" title=\"一、什么是JAVA\"></a>一、什么是JAVA</h3><p>Sun公司在1995年向外发布推广的一款面向对象的高级程序设计语言</p>\n<p>其主要应用于互联网后端服务器开发，大数据，安卓，网页，游戏等领域</p>\n<h3 id=\"二、JAVA语言技术体系\"><a href=\"#二、JAVA语言技术体系\" class=\"headerlink\" title=\"二、JAVA语言技术体系\"></a>二、JAVA语言技术体系</h3><ol>\n<li><p>JavaSE(Java Platform Standard Edition)</p>\n<p>Java标准版，主要包含Java基础语法，主要用于开发桌面软件及游戏</p>\n</li>\n<li><p>JavaME(Java Platform Micro Edition)</p>\n<p>Java微型版，主要用于开发移动端设备和嵌入式设备的软件，如手机、pda、机顶盒、车载等</p>\n</li>\n<li><p>JavaEE(Java Platform Enterprise Edition)</p>\n<p>Java企业版，主要用于开发互联网企业后台服务器端，为企业级开发提供解决方案</p>\n<p>企业级软件：</p>\n<p>公司：OA、ERP、CRM、SNS、财务、人事考勤….</p>\n<p>学校：学生管理系统、宿舍管理系统、考试系统….</p>\n<p>互联网：百度，京东，淘宝，B站….</p>\n<p>其他：教育、视频、直播、电信、电力、金融、电商</p>\n</li>\n</ol>\n<h3 id=\"三、Java语言特点\"><a href=\"#三、Java语言特点\" class=\"headerlink\" title=\"三、Java语言特点\"></a>三、Java语言特点</h3><ol>\n<li>应用面广</li>\n<li>Java简单易学（相对于C&#x2F;C++）</li>\n<li>面向对象(更符合我们看待事务特点)</li>\n<li>跨平台(一处编译，处处运行)</li>\n<li>多线程(提升系统的运行性能和效率)</li>\n<li>分布式(解决高并发，高可用，高性能问题)</li>\n<li>健壮性(强类型、垃圾回收、异常处理)</li>\n<li>安全性</li>\n<li>开源</li>\n</ol>\n<h3 id=\"四、Java开发环境搭建\"><a href=\"#四、Java开发环境搭建\" class=\"headerlink\" title=\"四、Java开发环境搭建\"></a>四、Java开发环境搭建</h3><ol>\n<li><p>JVM</p>\n<p>Java Virtual Machine</p>\n<p>Java虚拟机</p>\n<p>Java程序是运行在虚拟机之上，JVM是Java程序能够实现跨平台的基础</p>\n</li>\n<li><p>JRE</p>\n<p>Java Runtime Environment</p>\n<p>Java运行时环境</p>\n<p>JRE&#x3D;JVM+运行时需要的环境</p>\n</li>\n<li><p>JDK</p>\n<p>Java Develop Kit</p>\n<p>Java 开发工具包</p>\n<p>提供给Java开发人员使用的，其中包含Java开发需要的软件</p>\n<p>JDK&#x3D;JRE+Java开发工具</p>\n</li>\n</ol>\n<h3 id=\"五、环境变量配置\"><a href=\"#五、环境变量配置\" class=\"headerlink\" title=\"五、环境变量配置\"></a>五、环境变量配置</h3><ol>\n<li><p>新建JAVA_HOME</p>\n<p>变量名：JAVA_HOME</p>\n<p>变量值：填写JDK 安装目录</p>\n</li>\n<li><p>新建CLASSPATH</p>\n<p>变量名：CLASSPATH</p>\n<p>变量值：.</p>\n<p>​\t\t.;%JAVA_HOME%\\lib</p>\n<p>​\t\t.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar</p>\n</li>\n<li><p>找到Path</p>\n<p>新建：%JAVA_HOME%\\bin</p>\n<p>新建：%JAVA_HOME%\\jre\\bin</p>\n</li>\n</ol>\n<p>测试环境变量是否配置成功：</p>\n<ol>\n<li>win+R打开运行窗口</li>\n<li>输入cmd。点击确定打开命令行窗口</li>\n<li>输入javac或者java -version</li>\n<li>显示日志或者版本号则表明配置成功，不显示则表示配置失败</li>\n</ol>\n<h3 id=\"六、跨平台\"><a href=\"#六、跨平台\" class=\"headerlink\" title=\"六、跨平台\"></a>六、跨平台</h3><p>因为有了JVM，同一份字节码文件可以在三个不同的平台上都能运行，这样就实现了Java程序的跨平</p>\n<h3 id=\"七、第一个Java程序\"><a href=\"#七、第一个Java程序\" class=\"headerlink\" title=\"七、第一个Java程序\"></a>七、第一个Java程序</h3><ol>\n<li><p>Java项目的目录结构</p>\n<p>Java Project</p>\n<p>Java工程，Java项目，可以理解为是一个总文件夹</p>\n<p>JRE System Library</p>\n<blockquote>\n<p>Java运行环境(系统库)</p>\n</blockquote>\n<p>src</p>\n<blockquote>\n<p>编写Java源代码的位置</p>\n</blockquote>\n<p>bin</p>\n<blockquote>\n<p>用于存储编译后的.class字节码文件</p>\n</blockquote>\n</li>\n<li><p>Package</p>\n<p>包，创建在src下面，可以理解为是一个子文件夹</p>\n</li>\n<li><p>Class</p>\n<p>类，创建在Package下面，就是一个Java源文件</p>\n</li>\n<li><p>Java程序运行方式</p>\n<p>4.1 菜单栏点击绿色箭头</p>\n<p>4.2 右键–&gt;Run As–&gt;Java Application</p>\n<p>4.3 Ctrl+F11</p>\n</li>\n<li><p>Java中注释</p>\n</li>\n<li><p>注释：对Java代码起到一个解释说明的作用，不参与编译和运行过程，相当于产品说明书</p>\n<p>单行注释：&#x2F;&#x2F;</p>\n<p>多行注释：&#x2F;*</p>\n<p>​\t\t*&#x2F;</p>\n<p>文档注释：&#x2F;**</p>\n<p>​\t\t*&#x2F;</p>\n<blockquote>\n<p>注意：main函数，程序执行的入口</p>\n<p>public static void main(String[] args){}</p>\n<p>注意：输出语句</p>\n<p>System.out.println(“要输出的内容”);</p>\n</blockquote>\n</li>\n<li><p>基本语法规范</p>\n<p>7.1大小写严格区分</p>\n<p>7.2中英文严格区分（所有阔符号如为</p>\n<p>7.3括号必须成对出现</p>\n<p>7.4没行代码结束之后必须以分号结尾</p>\n<p>7.5大括号标识一个结构，结尾不用打分号</p>\n</li>\n<li><p>进制</p>\n<ol>\n<li><p>二进制：</p>\n<p>逢二进一</p>\n<p>二进制转十进制</p>\n<p>二进制 权（2^n)</p>\n</li>\n<li><p>十进制：</p>\n<p>逢十进一</p>\n<p>十进制转二进制 短除法    </p>\n</li>\n<li><p>八进制：                </p>\n<p>逢八进一              </p>\n</li>\n<li><p>十六进制：</p>\n<p>逢十六进一</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>10进制</th>\n<th>2进制</th>\n<th>8进制</th>\n<th>16进制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0000</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0001</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0010</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0011</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n<td>0100</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0101</td>\n<td>5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>6</td>\n<td>0110</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>7</td>\n<td>0111</td>\n<td>7</td>\n<td>7</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1000</td>\n<td>10</td>\n<td>8</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1001</td>\n<td>11</td>\n<td>9</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1010</td>\n<td>12</td>\n<td>A</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1011</td>\n<td>13</td>\n<td>B</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1100</td>\n<td>14</td>\n<td>C</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1101</td>\n<td>15</td>\n<td>D</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1110</td>\n<td>16</td>\n<td>E</td>\n</tr>\n<tr>\n<td>15</td>\n<td>1111</td>\n<td>17</td>\n<td>F</td>\n</tr>\n<tr>\n<td>16</td>\n<td>10000</td>\n<td>20</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p>在计算机中所有的数据(图片、音频、文本等资源)都是以2进制补码形式进行存储</p>\n<p>根据原码计算补码：</p>\n<ol>\n<li><p>原码和补码是以0开头的数字表示正数，以1开头的数字表示负数，最前面1位是符号位</p>\n</li>\n<li><p>正数的补码和他的原码是相同的</p>\n</li>\n<li><p>负数的补码是他的原码符号位不变，其他位取反再加1</p>\n<p>如果数据超出4位补码所能表示的范畴，</p>\n<p>超出8位采用补码来进行表示，</p>\n<p>超出8位采用16位</p>\n<p>超出16位采用</p>\n</li>\n</ol>\n<p>原码：</p>\n<p>十进制 7 &#x3D;&#x3D;二进制0111；-7 &#x3D;&#x3D;10000111，最高位表示符号位</p>\n<p>反码：</p>\n<p>正数和原码一样，负数除去最高位其余位取反，例如 -7 &#x3D;&#x3D; 1 1111000</p>\n<p>补码：</p>\n<p>正数和原码一样，负数–&gt;补码等于反码加1;例如 -7 &#x3D;&#x3D;反码 1 1111000 + 1 &#x3D;&#x3D;1 1111001</p>\n<p>总结：</p>\n<p>4位2进制补码最多可以表示2^4个数</p>\n<p>范围-2^3—-&gt;2^3-1</p>\n<p>8位2进制补码最多可以表示2^8个数</p>\n<p>范围-2^8—&gt;2^8-1</p>\n<p>16位2进制补码最多可以表示2^16个数</p>\n<p>范围-2^15—&gt;2^15-1</p>\n<p>32位2进制补码最多可以表示2^31个数</p>\n<p>范围-2^31—&gt;2^31-1</p>\n<p>64位2进制补码最多可以表示2^64个数</p>\n<p>范围-2^63—&gt;2^63-1</p>\n<p>在计算机中1个0或者1个1被称为叫1位</p>\n<p>用 1 bit 表示,bit是计算机最小的数据存储单元</p>\n<p>8位2进制补码通常被称为1个字节,用1byte来进行表示，是计算机中最小的操作单元</p>\n<p>1byte &#x3D; 8bit</p>\n<p>1kb &#x3D; 1024byte</p>\n<p>1mb &#x3D; 1024kb</p>\n<p>1gb &#x3D; 1024mb</p>\n</li>\n<li><p>变量</p>\n<ol>\n<li><p>什么是变量</p>\n<p>对应的是内存中的一块存储空间，可以用来存储一个值变量可以进行命名，可以通过变量名来操作变量中所存储的值变量中所存储的值是可以改变的</p>\n</li>\n<li><p>变量的使用</p>\n<p>定义一个变量，类型为int，名称为X    int &#x3D; 10；</p>\n<p>将10赋值给X</p>\n<p>&#x3D; 理解为赋值，将右侧的值赋值给左侧的变量</p>\n</li>\n<li><p>变量得定义和赋值</p>\n<p>定义：也叫声明，在内存中开辟了一块空间</p>\n<p>赋值：往往这块空间中存储一个数据</p>\n</li>\n<li><p>变量的作用域范围</p>\n<p>从变量的定义的地方开始，到他所属代码块的结束</p>\n<p>离开作用域范围后，该变量将被系统回收（无效了）</p>\n</li>\n<li><p>变量的命名规范</p>\n<ul>\n<li>强制性命名规范（不遵守就报错）</li>\n<li>建议性命名规范（不遵守不会报错，但是不专业）</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>数据类型</p>\n<ul>\n<li><p>八种基本类型</p>\n<ol>\n<li><p>整数类型（有范围）</p>\n<p>1.1 byte  字节型 一个字节8位，范围  -2^7~2^7-1</p>\n<p>1.2 short 短整型 两个字节16位，范围 -2^15~2^15-1</p>\n<p>1.3 int  整型 四个字节32位，范围 -2^31~2^31-1</p>\n<p>1.4 long 长整型 八个字节64位，范围 -2^63~2^63-1</p>\n<p>​\t如果右侧值超出了int最大值或最小值范围必须在数字后面带上L或者l</p>\n<p>​\t其中一个整数变成long类型，结果值就是long类型</p>\n<p>在Java种，int是整数的默认类型</p>\n<p>将一个整数赋值给byte类型变量时，会去掉前面3个字节，保留最后一个字节，所以右侧整数值不能超过byte范围</p>\n<p>将一个整数赋值给short类型变量时，会去掉前面2个字节保留最后2个字节，所以右侧整数值不能超过short范围</p>\n<p>将一个整数赋值给long类型变量时</p>\n<p>如果右侧整数值超过了int的范围，必须带上L或l，将右侧默认的32值改为64</p>\n<p>如果右侧整数数值诶有超出int范围，可以带上L或者l也可以不带，如果不带，整数前面补上32个0，负数前面补上32个1一般建议long类型都带上L或者l</p>\n</li>\n<li><p>小数类型</p>\n<p>2.1 float</p>\n<p>​\t单精度浮点</p>\n<p>​\t32位，一个符号位，23个尾数位，8个指数位</p>\n<p>2.2 double</p>\n<p>​\t双精度浮点</p>\n<p>​\t64位，一个符号位，52个尾数位，11个指数位</p>\n<p>​\t浮点数默认时double –&gt;加上F或者f将右侧浮点数变为flaot类型 </p>\n</li>\n<li><p>字符类型</p>\n<p>char: 主要用于存储Java中的单个字符，其本质上存储的是一个16位无符号位(从0开始，最前面一位不表示符号）的整数，其范围[0~65535],使用char定义字符时，必须使用单引号引起来。且单引号中只能定义一个字符</p>\n<p>​\t编码：</p>\n<p>​\t给计算机中每个字符编一个数字，在计算机中存储这个字符时，实质上存储的是该字符对应的数字，再取出该数字时，再参考编码表，将该数字转化成字符</p>\n<p>​\tASCII编码</p>\n<p>​\t只收录了英文字母和数字以及其他符号，范围时0-127,是单字节编码</p>\n<p>​\tUnicode编码</p>\n<p>​\t统一码，万国码</p>\n<p>​\t科学家统计了世界上几乎所有国家的语言文字，符号以及括号等，给每个字符都进行统一的编码，Unicode编码采用的是固定的双字节编码。范围0-65535，完全兼容ASCII编码</p>\n<p>Java中的char类型参考的就是Unicode编码表</p>\n<p>使用一个4位16进制Unicode编码来表示一个字符 例如：’\\u0064’</p>\n</li>\n<li><p>布尔类型</p>\n<p>boolean，用于表示真和假</p>\n<p>该类型只有两个值，true和false，true表示真，false表示假，该类型一般用于判断</p>\n</li>\n<li><p>String 字符串类型</p>\n<p>字符：</p>\n<p>​\t只能用于存储单个字符，使用单引号引起来</p>\n<p>字符串：</p>\n<p>​\t可以用于同时存储一道多个字符，使用双引号引起来</p>\n<p>​\t字符串可以和任意类型的变量之间使用+做拼接，拼接完成后的结果还是一个字符串</p>\n<p>两侧都不是字符串时，+就是加法运算</p>\n</li>\n<li><p>类型转换</p>\n<p>一般只会发生在整数裂隙和浮点类型之间，char字符类型只跟int整形之间转换，且都需要强转</p>\n<p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>运算符</p>\n<ol>\n<li><p>算术运算符</p>\n<p>加号\t减号\t乘号\t除号\t自加\t自减</p>\n<p>X++:后加加 先赋值，后自身加1</p>\n<p>++X:前加加 先自身加1，后赋值</p>\n<p>X–:后减减 先赋值 后自身减1</p>\n<p>–X:前减减 先自身减1 后赋值</p>\n<table>\n<thead>\n<tr>\n<th>int a &#x3D; 10;</th>\n<th>a++ &#x3D;10;</th>\n<th>a &#x3D; 11</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int a &#x3D; 10;</td>\n<td>++a &#x3D; 11;</td>\n<td>a &#x3D; 11;</td>\n</tr>\n<tr>\n<td>int a &#x3D; 10;</td>\n<td>a– &#x3D; 10;</td>\n<td>a &#x3D; 9;</td>\n</tr>\n<tr>\n<td>int a &#x3D; 10;</td>\n<td>–a &#x3D; 11;</td>\n<td>a &#x3D; 9;</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>比较运算符</p>\n<p>小于号\t大于号\t小于等于号\t大于等于号\t等号\t不等于号</p>\n</li>\n<li><p>赋值运算符</p>\n<p>&#x3D;\t+&#x3D;\t-&#x3D;\t*&#x3D;\t&#x2F;&#x3D;\t%&#x3D;</p>\n</li>\n<li><p>逻辑运算符</p>\n<p>&amp;&amp; : 逻辑与：&amp;&amp;并且（左右两边只能时布尔类型表达式）左侧表达式一&amp;&amp;右侧表达式二只有当布尔表达式一和布尔表达式二都是true的时候结果才是true，任何一个表达式的值为False 结果都是false</p>\n<p>短路与：false &amp;&amp; 布尔表达式</p>\n<p>逻辑与运算，如果左侧表达式计算结果为false那么右侧表达式二无论时true还是false结果都是False,此时右侧布尔表达式二值不参计算</p>\n<p>|| :逻辑或 左侧表达式一 || 右侧表达式二\t只要左侧布尔表达式一和右侧表达式二任意一个值为true结果就是true只有当两个表达式都是false的时候，结果才是false。</p>\n<p>短路或：true || 表达式二</p>\n<p>逻辑或运算，如果左侧布尔值表达式计算结果为true，那么布尔表达式二的值无论时true还是false结果都是true此时右侧表达式不参与计算。 \t</p>\n<p>！：逻辑非 ！后跟一个布尔表达式，非true就是false。非false就是true</p>\n<p>逻辑与的优先级高于逻辑或</p>\n</li>\n<li><p>三项运算符</p>\n<p>?:</p>\n</li>\n<li><p>不常用——————位运算符</p>\n<p>&amp;  位与   1 true   0 false   按位求与</p>\n<p>|  位或   1 true   0 false   按位求或</p>\n<p>~  位非   1变0     0变1</p>\n<p>^  异或   相同取0    不同取1</p>\n</li>\n<li><p>位移运算符</p>\n<p>&gt;&gt; 带符号右移\t正数右移左侧补0，负数右移左侧补1</p>\n<p>&gt;&gt;&gt; 无符号右移   正数负数右移，左侧补0</p>\n<p>&lt;&lt; 带符号左移    正数负数左移，右侧补0</p>\n</li>\n</ol>\n</li>\n<li><p>分支</p>\n<p><strong>if</strong></p>\n<p>如果布尔表达式判断位true则执行大括号中代码，如果为false则不执行</p>\n<p>不论时true还是false都不影响后续带啊吗执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（布尔表达式）&#123;</span><br><span class=\"line\">\t\t代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果布尔表达式为true则则执行i放后面的大号中的代码块yiruguo weil false,则执行else后面的大括号中代码块2</p>\n<p>如果i发或者else后面大括号中有一块代码可以省略大括号</p>\n<p>多层嵌套</p>\n<p>if（布尔表达式）{代码块一}else if(布尔表达式){代码块二}</p>\n<p>从上往下逐一判断所有if中的布尔表达式，只要有一个布尔表达式为true，就执行后面大括号中代码，执行完成后九立即跳出整个分支判断，后续的布尔表达式不在判断，如果所有布尔表达式判断为false，则执行else中代码块</p>\n<p><strong>switch_case</strong></p>\n<p>从上往下逐一和switch的变量进行匹配，如果匹配上了就执行case后面的代码块，如果碰到break就跳出整个分支判断，如果没有break就继续往下执行，知道碰到一个break再跳出如果所有case后面的值都没有匹配上联络就执行default下面的代码块。</p>\n<p>swicth 后面小括号中允许的变量类型</p>\n<p>jdk vetsion&lt;&#x3D;1.6</p>\n<p>byte short int char enum</p>\n<p>jdk version&gt;&#x3D;1.7</p>\n<p>byte  short int char enum String</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(变量)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> 值：</span><br><span class=\"line\">            代码块</span><br><span class=\"line\">            <span class=\"keyword\">break</span>；</span><br><span class=\"line\">        <span class=\"keyword\">case</span> 值<span class=\"number\">2</span>：</span><br><span class=\"line\">            <span class=\"keyword\">break</span>；</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>循环</p>\n<p>重复的去执行某一段代码  </p>\n<p><strong>for</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(初始化表达式；布尔表达式；修改循环体变量)&#123;</span><br><span class=\"line\">\t循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>布尔表达式为true则执行循环体，为false跳出循环</p>\n<p>死循环：布尔表达式不写或者第二个表达式为true或者第三个表达式没有</p>\n<p><strong>while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(布尔表达式)&#123;</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先判断，后执行循环体</p>\n<p><strong>do_while</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">    循环体</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (布尔表达式)</span><br></pre></td></tr></table></figure>\n\n<p>先执行一次循环体，再判断是否继续执行</p>\n</li>\n<li><p>数组</p>\n<ol>\n<li><p>概念</p>\n<p>对应内存中一块连续的储存空间，主要用于存储多个连续且类型相同的数据，数据中的每个数据叫做数组的元素</p>\n</li>\n<li><p>定义和赋值</p>\n<p>静态初始化只能在定义的时候赋值</p>\n<p>动态初始化支持先定义后赋值</p>\n</li>\n<li><p>特点</p>\n<p>数组长度一旦确定就无能改变了</p>\n<p>可以通过下标来获取或修改数组中的元素</p>\n<p>数组中元素的下标从左到右，从0开始每次递增，最小下标0，最大下标length-1</p>\n</li>\n<li><p>数组扩容</p>\n<p>因为数组的长度是不可变的，所以扩容实质上创新的长度不一样的数组，然后原来的数组中的元素复制到新的数组中</p>\n<ol>\n<li><p>带返回值</p>\n<p>新数组 &#x3D; Arrays.copyOf(原数组，新数组的长度)</p>\n</li>\n<li><p>不带返回值</p>\n<p>System.arraycopy(原数组，数组开始复制元素的下标，新数组，往新数组第几个下标位置开始放元素，从原数组复制几个元素到新数组)；</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.arraycopy(Object src,<span class=\"type\">int</span> srcPos,Object dest, <span class=\"type\">int</span> destPos,<span class=\"type\">int</span> length)</span><br></pre></td></tr></table></figure>\n\n<p>Object src  原数组   int srcPos 原数组开始复制元素的下标</p>\n<p>Object dest 新数组   int destPos 往新数组第几个下标位置开始放元素</p>\n<p>int length  从原数组复制几个元素复制到新数组</p>\n</li>\n<li><p>二维数组</p>\n<p>二维数组遍历，外层循环控制二维数组中的一位数组的下标，内层循环控制一位数组中元素的下标</p>\n</li>\n<li><p>数组的遍历</p>\n<p>通过元素的下标遍历，下标范围0~length</p>\n<p>for循环遍历</p>\n<p>for~each迭代器</p>\n</li>\n<li><p>数组元素排序</p>\n<p>将数组中元素按顺序从小到大或者 从大到小进行排序</p>\n<ol>\n<li><p>冒泡排序</p>\n<p>思想：第一次比较相邻的两个元素，若前面的元素比后面的元素大则交换，没一趟比较完成后，都能从剩下元素中选出一个最大值</p>\n</li>\n<li><p>插入排序</p>\n<p>思想：将数组分为有序和无序两堆，每次从无序数组中取出第一个元素和有序数组 中的元素从后往前逐个比较，若比他小则交换，若比他大则停止交换</p>\n</li>\n<li><p>选择排序</p>\n<p>思想：每次从待排序的数组中选出一个最小值，将其放在已经排序好的数组的最后面，直到所有元素都排序完成</p>\n</li>\n<li><p>快速排序</p>\n</li>\n<li><p>桶排序</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>函数</p>\n<ol>\n<li><p>什么是函数</p>\n<p>对代码块的提取和封装，并对其进行命名，也就是函数名，然后通过函数名可以对函数的调用，函数存在的目的是为了减少重复代码，实现代码复用</p>\n</li>\n<li><p>函数的定义</p>\n<p>返回值类型</p>\n<p>如果函数执行完成后需要给调用者一个返回值那么返回值类型就必须于结果值类型相同，同时在函数的最后通过return结果值</p>\n<p>如果函数执行完成后不需要返回结果给调用者，那么返回值类型就写void代表无返回们同时函数中不能写return标识函数到此结束</p>\n<p>return返回值</p>\n<p>将函数计算的结果返回调用者，同时函数执行到此结束</p>\n<p>return</p>\n<p>指标是函数执行到此结束</p>\n<p>命名规范和变量名相同</p>\n<p>形参，形式参数</p>\n<p>形参的作用就是规定传给函数的值必须是什么类型，在函数调用时会将实参值赋给形参</p>\n</li>\n<li><p>函数重载</p>\n<p>同名不同参</p>\n<p>一个类中多个函数之间函数名称相同但是参数列表不同但是参数列表不同，与返回值无关</p>\n</li>\n<li><p>函数的可变参数</p>\n<p>定义一个函数，用于计算若干个整数的和传入几个整数，就将几个整数的和加起来，然后返回给调用者</p>\n<p>语法：add(int… arr)</p>\n<p>在调用add()函数时可以传入0到多个实参数值，在函数内部可变参数可以当做是数组来使用，可以进行遍历获取长度使用下标</p>\n<p>注意：</p>\n<ol>\n<li>一个函数中最多只能有一个可变参数</li>\n<li>如果有其他形参时，可变参数必须放在最后</li>\n</ol>\n</li>\n<li><p>函数递归</p>\n<p>注意：</p>\n<ol>\n<li>递归必须指定结束条件，否则就会报错StackOverFlowError错误，栈内存溢出</li>\n<li>递归的效率非常低一般不建议使用</li>\n</ol>\n<p>递归的常见使用场景</p>\n<ol>\n<li>求一个数的阶乘</li>\n<li>求一个数的累加和</li>\n<li>求斐波那契数列</li>\n<li>文件夹遍历</li>\n<li>二叉树</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>标识符</p>\n<p>有程序员自己定义的包名、类名、变量名、函数名，需要满足一定的规范</p>\n<ol>\n<li>强制性规范</li>\n<li>建议性规范</li>\n</ol>\n</li>\n</ol>\n"},{"title":"JDBC","date":"2023-02-02T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# JDBC\n\n### 一、什么是JDBC\n\n​\tJava DataBase Connectivity\n\n​\t使用Java代码连接并操作数据库的一套技术解决方案\n\n### 二、JDBC工作原理\n\n1. JDBC技术标准制定了一套标准接口，在接口中定义了访问并操作数据库的通用API，这些API主要包括连接数据库，以及对数据表进行增删改查等抽象方法\n\n2. 各大数据库厂商根据JDBC技术标准制定的接口来编写实现类，实现接口中各种抽象方法，并将接口和这些实现类封装成一个jar包，提供给程序开发人员使用\n\n3. 开发人员将jar包下载下来，导入到自己的项目中，在项目中使用接口来实现对数据库的访问操作，根据java多态底层会自动去调用实现类中重写的方法\n\n   使用接口编程的好处：\n\n   可以让java以相同的方式去访问不同的数据库，以实现与具体数据库无关的java操作\n\n### 三、JDBC使用步骤\n\n1. 反射加载mysql驱动\n\n   > Class.forName(\"com.mysql.cj.jdbc.Driver\")\n\n2. 连接数据库(指定IP、端口号、账号、密码、库名)\n\n   > Connection conn = DriverManager.getConnection(url,username,passsword)\n\n3. 预编译sql语句(创建一个sql语句对象)\n\n   > PreparedStatement ps = conn.prepareStatement(sql)\n\n4. 执行sql语句\n\n   > 如果sql语句有？占位符，需要给占位符赋值\n   >\n   > ps.setXXX(占位符顺序，给占位符赋值)\n   >\n   > 执行DML语句，返回受影响的行数\n   >\n   > int rows = ps.executeUpdate();\n   >\n   > 执行DQL查询语句，返回ResultSet结果集\n   >\n   > ResultSet rs = ps.executeQuery();\n   >\n   > 结果集处理：\n   >\n   > rs.next()      判断结果集有没有下一行数据\n   >\n   > rs.getXXX(列名/列序号)    根据列名或者列序号取值，如果有别名，查询取别名\n\n5. 释放资源\n\n   后打开的先释放\n\n### 四、Statement和PreparedStatement有什么区别\n\n1. Statement 先以字符串方式拼接sql语句，然后再编译执行，又可能会造成sql注入\n2. PreparedStatement 是先预编译sql语句，预编译时允许sql带上？占位符，然后再给占位符赋值，给占位符赋的值都会加上双引号，所以不会造成sql语句注入\n3. PreparedStatement只需要编译一次，而Statement每次执行都需要编译，因此PreparedStatement效率更高 \n4. 如果传入的是数据库对象，如列名、表名、库名时必须使用Statement，如果传入耳朵是表中的数据，建议都采用PreparedStatement\n\n### 五、JDBC执行事务\n\n​\t通过Connection连接数据库来控制事务\n\n1. setAutoCommit(false);     开启事务\n2. commit();                 提交事务\n3. rollback();               回滚事务\n\n### 六、JDBC获取数据库元数据\n\n​\t元数据：用于描述数据的数据，例如xml和json\n\n```json\n{\n\t\"id\":1,\n\t\"name\":\"张三\"\n}\n```\n\n1. 数据库元数据\n\n   DatabaseMetaData data = conn.getMetaData();\n\n2. 表元数据\n\n   ResultSetMetaData rsd = rs.getMetaData();\n\n","source":"_posts/JDBC.md","raw":"---\ntitle: JDBC\ndate: 2023-02-02 11:18:57\ntags: Java\ncategories: Java\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# JDBC\n\n### 一、什么是JDBC\n\n​\tJava DataBase Connectivity\n\n​\t使用Java代码连接并操作数据库的一套技术解决方案\n\n### 二、JDBC工作原理\n\n1. JDBC技术标准制定了一套标准接口，在接口中定义了访问并操作数据库的通用API，这些API主要包括连接数据库，以及对数据表进行增删改查等抽象方法\n\n2. 各大数据库厂商根据JDBC技术标准制定的接口来编写实现类，实现接口中各种抽象方法，并将接口和这些实现类封装成一个jar包，提供给程序开发人员使用\n\n3. 开发人员将jar包下载下来，导入到自己的项目中，在项目中使用接口来实现对数据库的访问操作，根据java多态底层会自动去调用实现类中重写的方法\n\n   使用接口编程的好处：\n\n   可以让java以相同的方式去访问不同的数据库，以实现与具体数据库无关的java操作\n\n### 三、JDBC使用步骤\n\n1. 反射加载mysql驱动\n\n   > Class.forName(\"com.mysql.cj.jdbc.Driver\")\n\n2. 连接数据库(指定IP、端口号、账号、密码、库名)\n\n   > Connection conn = DriverManager.getConnection(url,username,passsword)\n\n3. 预编译sql语句(创建一个sql语句对象)\n\n   > PreparedStatement ps = conn.prepareStatement(sql)\n\n4. 执行sql语句\n\n   > 如果sql语句有？占位符，需要给占位符赋值\n   >\n   > ps.setXXX(占位符顺序，给占位符赋值)\n   >\n   > 执行DML语句，返回受影响的行数\n   >\n   > int rows = ps.executeUpdate();\n   >\n   > 执行DQL查询语句，返回ResultSet结果集\n   >\n   > ResultSet rs = ps.executeQuery();\n   >\n   > 结果集处理：\n   >\n   > rs.next()      判断结果集有没有下一行数据\n   >\n   > rs.getXXX(列名/列序号)    根据列名或者列序号取值，如果有别名，查询取别名\n\n5. 释放资源\n\n   后打开的先释放\n\n### 四、Statement和PreparedStatement有什么区别\n\n1. Statement 先以字符串方式拼接sql语句，然后再编译执行，又可能会造成sql注入\n2. PreparedStatement 是先预编译sql语句，预编译时允许sql带上？占位符，然后再给占位符赋值，给占位符赋的值都会加上双引号，所以不会造成sql语句注入\n3. PreparedStatement只需要编译一次，而Statement每次执行都需要编译，因此PreparedStatement效率更高 \n4. 如果传入的是数据库对象，如列名、表名、库名时必须使用Statement，如果传入耳朵是表中的数据，建议都采用PreparedStatement\n\n### 五、JDBC执行事务\n\n​\t通过Connection连接数据库来控制事务\n\n1. setAutoCommit(false);     开启事务\n2. commit();                 提交事务\n3. rollback();               回滚事务\n\n### 六、JDBC获取数据库元数据\n\n​\t元数据：用于描述数据的数据，例如xml和json\n\n```json\n{\n\t\"id\":1,\n\t\"name\":\"张三\"\n}\n```\n\n1. 数据库元数据\n\n   DatabaseMetaData data = conn.getMetaData();\n\n2. 表元数据\n\n   ResultSetMetaData rsd = rs.getMetaData();\n\n","slug":"JDBC","published":1,"updated":"2023-08-10T09:50:24.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw96000bfswocfbafswy","content":"<h1 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h1><h3 id=\"一、什么是JDBC\"><a href=\"#一、什么是JDBC\" class=\"headerlink\" title=\"一、什么是JDBC\"></a>一、什么是JDBC</h3><p>​\tJava DataBase Connectivity</p>\n<p>​\t使用Java代码连接并操作数据库的一套技术解决方案</p>\n<h3 id=\"二、JDBC工作原理\"><a href=\"#二、JDBC工作原理\" class=\"headerlink\" title=\"二、JDBC工作原理\"></a>二、JDBC工作原理</h3><ol>\n<li><p>JDBC技术标准制定了一套标准接口，在接口中定义了访问并操作数据库的通用API，这些API主要包括连接数据库，以及对数据表进行增删改查等抽象方法</p>\n</li>\n<li><p>各大数据库厂商根据JDBC技术标准制定的接口来编写实现类，实现接口中各种抽象方法，并将接口和这些实现类封装成一个jar包，提供给程序开发人员使用</p>\n</li>\n<li><p>开发人员将jar包下载下来，导入到自己的项目中，在项目中使用接口来实现对数据库的访问操作，根据java多态底层会自动去调用实现类中重写的方法</p>\n<p>使用接口编程的好处：</p>\n<p>可以让java以相同的方式去访问不同的数据库，以实现与具体数据库无关的java操作</p>\n</li>\n</ol>\n<h3 id=\"三、JDBC使用步骤\"><a href=\"#三、JDBC使用步骤\" class=\"headerlink\" title=\"三、JDBC使用步骤\"></a>三、JDBC使用步骤</h3><ol>\n<li><p>反射加载mysql驱动</p>\n<blockquote>\n<p>Class.forName(“com.mysql.cj.jdbc.Driver”)</p>\n</blockquote>\n</li>\n<li><p>连接数据库(指定IP、端口号、账号、密码、库名)</p>\n<blockquote>\n<p>Connection conn &#x3D; DriverManager.getConnection(url,username,passsword)</p>\n</blockquote>\n</li>\n<li><p>预编译sql语句(创建一个sql语句对象)</p>\n<blockquote>\n<p>PreparedStatement ps &#x3D; conn.prepareStatement(sql)</p>\n</blockquote>\n</li>\n<li><p>执行sql语句</p>\n<blockquote>\n<p>如果sql语句有？占位符，需要给占位符赋值</p>\n<p>ps.setXXX(占位符顺序，给占位符赋值)</p>\n<p>执行DML语句，返回受影响的行数</p>\n<p>int rows &#x3D; ps.executeUpdate();</p>\n<p>执行DQL查询语句，返回ResultSet结果集</p>\n<p>ResultSet rs &#x3D; ps.executeQuery();</p>\n<p>结果集处理：</p>\n<p>rs.next()      判断结果集有没有下一行数据</p>\n<p>rs.getXXX(列名&#x2F;列序号)    根据列名或者列序号取值，如果有别名，查询取别名</p>\n</blockquote>\n</li>\n<li><p>释放资源</p>\n<p>后打开的先释放</p>\n</li>\n</ol>\n<h3 id=\"四、Statement和PreparedStatement有什么区别\"><a href=\"#四、Statement和PreparedStatement有什么区别\" class=\"headerlink\" title=\"四、Statement和PreparedStatement有什么区别\"></a>四、Statement和PreparedStatement有什么区别</h3><ol>\n<li>Statement 先以字符串方式拼接sql语句，然后再编译执行，又可能会造成sql注入</li>\n<li>PreparedStatement 是先预编译sql语句，预编译时允许sql带上？占位符，然后再给占位符赋值，给占位符赋的值都会加上双引号，所以不会造成sql语句注入</li>\n<li>PreparedStatement只需要编译一次，而Statement每次执行都需要编译，因此PreparedStatement效率更高 </li>\n<li>如果传入的是数据库对象，如列名、表名、库名时必须使用Statement，如果传入耳朵是表中的数据，建议都采用PreparedStatement</li>\n</ol>\n<h3 id=\"五、JDBC执行事务\"><a href=\"#五、JDBC执行事务\" class=\"headerlink\" title=\"五、JDBC执行事务\"></a>五、JDBC执行事务</h3><p>​\t通过Connection连接数据库来控制事务</p>\n<ol>\n<li>setAutoCommit(false);     开启事务</li>\n<li>commit();                 提交事务</li>\n<li>rollback();               回滚事务</li>\n</ol>\n<h3 id=\"六、JDBC获取数据库元数据\"><a href=\"#六、JDBC获取数据库元数据\" class=\"headerlink\" title=\"六、JDBC获取数据库元数据\"></a>六、JDBC获取数据库元数据</h3><p>​\t元数据：用于描述数据的数据，例如xml和json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t<span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;张三&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>数据库元数据</p>\n<p>DatabaseMetaData data &#x3D; conn.getMetaData();</p>\n</li>\n<li><p>表元数据</p>\n<p>ResultSetMetaData rsd &#x3D; rs.getMetaData();</p>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h1><h3 id=\"一、什么是JDBC\"><a href=\"#一、什么是JDBC\" class=\"headerlink\" title=\"一、什么是JDBC\"></a>一、什么是JDBC</h3><p>​\tJava DataBase Connectivity</p>\n<p>​\t使用Java代码连接并操作数据库的一套技术解决方案</p>\n<h3 id=\"二、JDBC工作原理\"><a href=\"#二、JDBC工作原理\" class=\"headerlink\" title=\"二、JDBC工作原理\"></a>二、JDBC工作原理</h3><ol>\n<li><p>JDBC技术标准制定了一套标准接口，在接口中定义了访问并操作数据库的通用API，这些API主要包括连接数据库，以及对数据表进行增删改查等抽象方法</p>\n</li>\n<li><p>各大数据库厂商根据JDBC技术标准制定的接口来编写实现类，实现接口中各种抽象方法，并将接口和这些实现类封装成一个jar包，提供给程序开发人员使用</p>\n</li>\n<li><p>开发人员将jar包下载下来，导入到自己的项目中，在项目中使用接口来实现对数据库的访问操作，根据java多态底层会自动去调用实现类中重写的方法</p>\n<p>使用接口编程的好处：</p>\n<p>可以让java以相同的方式去访问不同的数据库，以实现与具体数据库无关的java操作</p>\n</li>\n</ol>\n<h3 id=\"三、JDBC使用步骤\"><a href=\"#三、JDBC使用步骤\" class=\"headerlink\" title=\"三、JDBC使用步骤\"></a>三、JDBC使用步骤</h3><ol>\n<li><p>反射加载mysql驱动</p>\n<blockquote>\n<p>Class.forName(“com.mysql.cj.jdbc.Driver”)</p>\n</blockquote>\n</li>\n<li><p>连接数据库(指定IP、端口号、账号、密码、库名)</p>\n<blockquote>\n<p>Connection conn &#x3D; DriverManager.getConnection(url,username,passsword)</p>\n</blockquote>\n</li>\n<li><p>预编译sql语句(创建一个sql语句对象)</p>\n<blockquote>\n<p>PreparedStatement ps &#x3D; conn.prepareStatement(sql)</p>\n</blockquote>\n</li>\n<li><p>执行sql语句</p>\n<blockquote>\n<p>如果sql语句有？占位符，需要给占位符赋值</p>\n<p>ps.setXXX(占位符顺序，给占位符赋值)</p>\n<p>执行DML语句，返回受影响的行数</p>\n<p>int rows &#x3D; ps.executeUpdate();</p>\n<p>执行DQL查询语句，返回ResultSet结果集</p>\n<p>ResultSet rs &#x3D; ps.executeQuery();</p>\n<p>结果集处理：</p>\n<p>rs.next()      判断结果集有没有下一行数据</p>\n<p>rs.getXXX(列名&#x2F;列序号)    根据列名或者列序号取值，如果有别名，查询取别名</p>\n</blockquote>\n</li>\n<li><p>释放资源</p>\n<p>后打开的先释放</p>\n</li>\n</ol>\n<h3 id=\"四、Statement和PreparedStatement有什么区别\"><a href=\"#四、Statement和PreparedStatement有什么区别\" class=\"headerlink\" title=\"四、Statement和PreparedStatement有什么区别\"></a>四、Statement和PreparedStatement有什么区别</h3><ol>\n<li>Statement 先以字符串方式拼接sql语句，然后再编译执行，又可能会造成sql注入</li>\n<li>PreparedStatement 是先预编译sql语句，预编译时允许sql带上？占位符，然后再给占位符赋值，给占位符赋的值都会加上双引号，所以不会造成sql语句注入</li>\n<li>PreparedStatement只需要编译一次，而Statement每次执行都需要编译，因此PreparedStatement效率更高 </li>\n<li>如果传入的是数据库对象，如列名、表名、库名时必须使用Statement，如果传入耳朵是表中的数据，建议都采用PreparedStatement</li>\n</ol>\n<h3 id=\"五、JDBC执行事务\"><a href=\"#五、JDBC执行事务\" class=\"headerlink\" title=\"五、JDBC执行事务\"></a>五、JDBC执行事务</h3><p>​\t通过Connection连接数据库来控制事务</p>\n<ol>\n<li>setAutoCommit(false);     开启事务</li>\n<li>commit();                 提交事务</li>\n<li>rollback();               回滚事务</li>\n</ol>\n<h3 id=\"六、JDBC获取数据库元数据\"><a href=\"#六、JDBC获取数据库元数据\" class=\"headerlink\" title=\"六、JDBC获取数据库元数据\"></a>六、JDBC获取数据库元数据</h3><p>​\t元数据：用于描述数据的数据，例如xml和json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t<span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;张三&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>数据库元数据</p>\n<p>DatabaseMetaData data &#x3D; conn.getMetaData();</p>\n</li>\n<li><p>表元数据</p>\n<p>ResultSetMetaData rsd &#x3D; rs.getMetaData();</p>\n</li>\n</ol>\n"},{"title":"Java常用API","date":"2023-01-06T03:18:57.000Z","cover":"/img/images/computer.jpg","_content":"\n# API\n\napplication programming interface\n\n应用程序编程接口，学习Java官方已经定义好一些类或接口\n\n1. 如何学习一个API\n\n   1. 这个类是什么\n   2. 这个类有什么作用\n   3. 如何创建这个类的对象\n   4. 这个类中有那些属性和方法，各有什么作用\n   5. 在那些情形下需要使用到这个类\n\n2. 怎样学好API\n\n   1. 查手册\n   2. 看源码\n\n3. 核心API\n\n   1. Object\n   2. 字符序列:String/StringBuilder/StringBuffer\n   3. 包装类:Byte/Short/Integer/Long/Float/Double/Boolean/Character\n   4. 时间日期：Data/Calendar/LocalDate/LocalTime/LocatDateTime\n   5. 集合容器：Collection/Map\n   6. 数据结构：数组/链表/树/栈/队列/哈希表/图/堆\n   7. 异常：Exception/Error\n   8. 文件：File/\n   9. IO流：字节流/字符流/输入/输出\n   10. 线程：Thread\n   11. 网络编程：Socket\n\n4. **Java.lang包**\n\n   语言包，使用该包下面的类都不需要导包\n\n   1. **Java.long.Object**\n\n      所有类的顶层父类，如果一个类没有继承其他类，默认会继承Object类，给所有的类提供一些公共的方法，让子类去继承或重写\n\n   2. **toString**\n\n      在Object类中该方法用于打印输出内存的哈希值，所有子类需要进行重写，重写之后可以显示对象的成员变量信息\n\n      在默认输出对象时，默认会调用对象的toString()方法\n\n      对象和字符串之间使用+做拼接时，默认会去调用对象的toString方法\n\n   3. **equals**\n\n      在Object类中,该方法默认比较的是两个对象的地址值，所有子类都需要进行重写，从而比骄两个对象的属性值，当属性值相同时就返回true，不同返回false\n\n      是为了让子类去重写后能够比较两个类的成员变量信息，如果两个对象的属性值相同，不管是否为同一对象，那么都因该返会true否则如果属性值不同就返回false，所以我们所有的子类都需要按照规定重写\n\n      > 面试题：equals和= = 有什么区别\n      >\n      > 1. 八种基本类型之间的比较都用 = =\n      > 2. 引用类型之间比较地址值，也就是判断两个对象是否为同一对象，也使用 = =\n      > 3. 判断一个对象是否为null，使用= = 或者！=\n      > 4. 在经过子类重写后equals（）可以用于判断两个对象的属性值是否相同，如果没有重写equals（）默认比较的还是地址值\n      \n   4. **Java.long.String**\n   \n      1. 字符串，用于表示一串字，字符串的本质是一个字符数组char[]\n   \n      2. 字符串特点：字符串是一个常量，一旦定义后内容（长度，大小）不可改变，如果字符串内容变了，一定是创建新的字符串对象\n   \n         原因：字符串采用的是char[]数组做存储而char[]数组使用了private final修饰符，并且没有对外界提供公开的方法来修改这个数组\n   \n      3. 字符串对象的创建\n   \n         1. 使用构造方法来创建对象\n   \n            当使用构造方法创建对象时，首先会去检查字符串常量池中是否有这个字符串对象，如果没有就先在池中创建一个，然后复制到堆中，如果池中有这个对象，就就直接将池中这个对象复制到堆中，然后栈中的引用指向堆中的对象\n   \n         2. 利用字符串拼接创建对象\n   \n            字符串和其他任意类型之间可以使用+做拼接，拼接完成后的结果还是一个字符串\n   \n            > Java编译器优化：\n            >\n            > 如果右侧参与拼接的全部都是字符串字面值，在编译期间就已经确定他的结果，那么Java编译器在编译期间直接将右侧字符串字面值全部拼接在一起，然后再运行\n   \n            ```java\n            String s1 = \"abc\";\n            String s2 = \"ab\";\n            String s3 = s2+\"c\";\n            System.out,println(s1.equals(s3));//true\n            System.out,println(s1==s3);//false\n            ```\n   \n            在编译期间无法确定值是什么，只有到运行期间才会将值从变量中取出来，再参与拼接\n   \n      4. 字符串常量池\n   \n         当使用字符串字面值创建对象时，首先会去检查字符串常量池中有没有这个字符串对象，如果没有就在池中创建一个，然后栈中引用指向池中这个对象，如果有就不在创建，从而让对象可以得到复用，节省内存空间\n         \n      5. 字符串转为数组\n      \n         ```java\n         String s1 = \"abc\";\n         s1.toCharArray();\n         ```\n      \n      6. 字符串获取长度\n      \n         ```java\n         String s1 = \"abc\";\n         s1.charAt(index);\n         ```\n      \n      7. 字符串转大小写\n      \n         ```java\n         String s1 = \"abc\";\n         s1.toUpperCase();//大写\n         s1.toLowerCase()//小写\n         ```\n      \n      8. 判断字符串是否以指定的子串开头\n      \n         ```java\n         String s1 = \"abc\";\n         boolean f1 = s1.startWith(\"a\");\n         System.out.println(f1?\"是指定子串开头\":\"不是子串开头\");\n         ```\n      \n      9. 判断字符串是否指定的子串结尾\n      \n         ```java\n         String s1 = \"刘亦菲.jpg\";\n         boolean f2 = s1.endsWith(.jpg);\n         System.out.println(f2?\"s是指定的子串结尾\":\"不是指定的子串结尾\")\n         ```\n      \n      10. 获取指定子串的下标位置\n      \n         获取第一次出现的下标位置\n      \n         ```java\n         String s1 = \"adwadjjj jwdjwad\";\n         int index = s1.indexOf(\"wa\");\n         ```\n      \n         从指定下标位置开始向后查找\n      \n         ```java\n         String s1 = \"asdfghjklqwertyu\";\n         int index = s1.indexOf(\"er\",3);\n         ```\n      \n         获取指定子串最后一次出现的下标位置\n      \n         ```java\n         String s1 = \"qwetyuiop\";\n         int index = s1.lastIndexOf(\"i\");\n         ```\n      \n         截取子串\n      \n         从指定下标位置开始，截取到字符串的末尾\n      \n         ```java\n         String s1 = \"zxcvbnm\";\n         s1.substring(12);\n         ```\n      \n         包含开始下标位置，不包含结束下标位置\n      \n         截取范围[start,end]\n      \n         ```java\n         String s1 = \"qwertyuio\";\n         s1.substring(4,8)；\n         ----------------------\n         s1.substring(s1.indexOf(\"q\"),s1.indexOf(\"y\")+1)；\n         ```\n      \n      11. 判断是否包含指定子串\n      \n          ```java\n          String s1 = \"qwertyuiop\";\n          boolean f1 = s1.contains(\"yui\");\n          System.out.println(f4?\"包含:不包含\")\n          ```\n      \n      12. 判断是否为空字符串\n      \n          ```java\n          String s1 = \"\";\n          boolean f1 = s1.isEmpty();\n          System.out.println(f1?\"空字符串\":\"非空字符串\")；\n          ```\n      \n      13. 去除字符串两侧空白\n      \n          ```java\n          String s1 = \"  张三  \"；\n          s1.trim();\n          ```\n      \n      14. 忽略大小写比较\n      \n          ```java\n          String s1 = \"asdfhg\";\n          String s2 =\"ASDHG\";\n          S1.equalslgnoreCase(s2);\n          ```\n      \n      15. 字符串以分隔符拼接\n      \n          ```java\n          String s1 = String.join(\":\",\"张三\"，\"李四\",\"王五\")；\n          System.out.println(s1);\n          ```\n      \n      16. 将其他任意类型转为字符串类型\n      \n          基本类型\n      \n          ```java\n          int n = 100;\n          String s1 = String.valueOf(n);\n          ```\n      \n          引用类型\n      \n          ```Java\n          Point point = new Point(5,10);\n          String s1 = String.valueOf(point);\n          ```\n      \n   5. **正则表达式Regex**\n   \n      用于检测字符串是否符合某一特定规则的格式匹配工具，在Java中正则表达式是使用字符串来表示的\n   \n      点：任意一个字符\n   \n      \\d：任意一个数字字符\n   \n      \\w：任意一个单词字符（字母数字下滑线）\n   \n      \\s：空白（空白，换行）\n   \n      \\D：非数字字符\n   \n      \\W：非单词字符\n   \n      \\S：非空白字符\n   \n      \\[0~9]:任意一个数字字符\n   \n      \\[0~9a-zA-Z_]:任意一个数字字母下划线\n   \n      \\[abc]:a或b或c中任意一个字符\n   \n      \\[^abc]:排除abc外的其他任意字符\n   \n      ? :0个或1个\n   \n      \\+ :一个或多个\n   \n      \\* :0个或多个\n   \n      \\d{6}：必须是6位数字\n   \n      \\d{6，8}：最少6位，最多8位纯数字\n   \n      \\d{6,}:最少6位，最多不限\n   \n      \\d{，8}:最少不限，最多8位\n   \n      & ：并且\n   \n      | ：或者\n   \n   6. **字符串中跟正则表达式相关的3个API方法：**\n   \n      1. matches（string regex)\n   \n         检测字符串是否符号正则表达式制定的规则\n   \n      2. split(String regex)\n   \n         按照正则表达式的规则切分字符串\n   \n      3. replaceAll（String regex)\n   \n         按照正则表达式的规则替换字符串中能匹配上的子串\n   \n5. **java.lang.StringBuilder**\n\n   1. 可变字符串，比较适合用于对字符串进行频繁修改，无论修改（内容，大小，长度）多少次，都是原来那个对象，不会创建新的对象，其内部维护着一个可变的字符数组，节省系统内存\n\n   2. 构建对象\n\n      ```java\n      //无参构造默认初始化另一个16长度的字符数组\n      StringBuilder sb = new StringBuilder()；\n      //带参数构造方法，参数长度+16的长度数组\n      StringBuilder sb = new StringBuilder(\"abc\")；\n      ```\n\n   3. apped()追加内容\n\n      ```java\n      StringBuilder sb = new StringBuilder(\"abc\")；\n      sb.apped(\"def\");\n      System.out.println(sb);\n      ```\n\n   4. reverse()内容翻转\n\n   5. setCharAt(0,0)替换指定下标位置字符\n\n   6. delete(0,0)删除指定下标位置包前不包后[start,end)\n\n6. **java.lang.StringBuffer**\n\n   \n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaAPI.md","raw":"---\ntitle: Java常用API\ndate: 2023-01-06 11:18:57\ntags: Java\ncategories: Java\ncover: /img/images/computer.jpg\n---\n\n# API\n\napplication programming interface\n\n应用程序编程接口，学习Java官方已经定义好一些类或接口\n\n1. 如何学习一个API\n\n   1. 这个类是什么\n   2. 这个类有什么作用\n   3. 如何创建这个类的对象\n   4. 这个类中有那些属性和方法，各有什么作用\n   5. 在那些情形下需要使用到这个类\n\n2. 怎样学好API\n\n   1. 查手册\n   2. 看源码\n\n3. 核心API\n\n   1. Object\n   2. 字符序列:String/StringBuilder/StringBuffer\n   3. 包装类:Byte/Short/Integer/Long/Float/Double/Boolean/Character\n   4. 时间日期：Data/Calendar/LocalDate/LocalTime/LocatDateTime\n   5. 集合容器：Collection/Map\n   6. 数据结构：数组/链表/树/栈/队列/哈希表/图/堆\n   7. 异常：Exception/Error\n   8. 文件：File/\n   9. IO流：字节流/字符流/输入/输出\n   10. 线程：Thread\n   11. 网络编程：Socket\n\n4. **Java.lang包**\n\n   语言包，使用该包下面的类都不需要导包\n\n   1. **Java.long.Object**\n\n      所有类的顶层父类，如果一个类没有继承其他类，默认会继承Object类，给所有的类提供一些公共的方法，让子类去继承或重写\n\n   2. **toString**\n\n      在Object类中该方法用于打印输出内存的哈希值，所有子类需要进行重写，重写之后可以显示对象的成员变量信息\n\n      在默认输出对象时，默认会调用对象的toString()方法\n\n      对象和字符串之间使用+做拼接时，默认会去调用对象的toString方法\n\n   3. **equals**\n\n      在Object类中,该方法默认比较的是两个对象的地址值，所有子类都需要进行重写，从而比骄两个对象的属性值，当属性值相同时就返回true，不同返回false\n\n      是为了让子类去重写后能够比较两个类的成员变量信息，如果两个对象的属性值相同，不管是否为同一对象，那么都因该返会true否则如果属性值不同就返回false，所以我们所有的子类都需要按照规定重写\n\n      > 面试题：equals和= = 有什么区别\n      >\n      > 1. 八种基本类型之间的比较都用 = =\n      > 2. 引用类型之间比较地址值，也就是判断两个对象是否为同一对象，也使用 = =\n      > 3. 判断一个对象是否为null，使用= = 或者！=\n      > 4. 在经过子类重写后equals（）可以用于判断两个对象的属性值是否相同，如果没有重写equals（）默认比较的还是地址值\n      \n   4. **Java.long.String**\n   \n      1. 字符串，用于表示一串字，字符串的本质是一个字符数组char[]\n   \n      2. 字符串特点：字符串是一个常量，一旦定义后内容（长度，大小）不可改变，如果字符串内容变了，一定是创建新的字符串对象\n   \n         原因：字符串采用的是char[]数组做存储而char[]数组使用了private final修饰符，并且没有对外界提供公开的方法来修改这个数组\n   \n      3. 字符串对象的创建\n   \n         1. 使用构造方法来创建对象\n   \n            当使用构造方法创建对象时，首先会去检查字符串常量池中是否有这个字符串对象，如果没有就先在池中创建一个，然后复制到堆中，如果池中有这个对象，就就直接将池中这个对象复制到堆中，然后栈中的引用指向堆中的对象\n   \n         2. 利用字符串拼接创建对象\n   \n            字符串和其他任意类型之间可以使用+做拼接，拼接完成后的结果还是一个字符串\n   \n            > Java编译器优化：\n            >\n            > 如果右侧参与拼接的全部都是字符串字面值，在编译期间就已经确定他的结果，那么Java编译器在编译期间直接将右侧字符串字面值全部拼接在一起，然后再运行\n   \n            ```java\n            String s1 = \"abc\";\n            String s2 = \"ab\";\n            String s3 = s2+\"c\";\n            System.out,println(s1.equals(s3));//true\n            System.out,println(s1==s3);//false\n            ```\n   \n            在编译期间无法确定值是什么，只有到运行期间才会将值从变量中取出来，再参与拼接\n   \n      4. 字符串常量池\n   \n         当使用字符串字面值创建对象时，首先会去检查字符串常量池中有没有这个字符串对象，如果没有就在池中创建一个，然后栈中引用指向池中这个对象，如果有就不在创建，从而让对象可以得到复用，节省内存空间\n         \n      5. 字符串转为数组\n      \n         ```java\n         String s1 = \"abc\";\n         s1.toCharArray();\n         ```\n      \n      6. 字符串获取长度\n      \n         ```java\n         String s1 = \"abc\";\n         s1.charAt(index);\n         ```\n      \n      7. 字符串转大小写\n      \n         ```java\n         String s1 = \"abc\";\n         s1.toUpperCase();//大写\n         s1.toLowerCase()//小写\n         ```\n      \n      8. 判断字符串是否以指定的子串开头\n      \n         ```java\n         String s1 = \"abc\";\n         boolean f1 = s1.startWith(\"a\");\n         System.out.println(f1?\"是指定子串开头\":\"不是子串开头\");\n         ```\n      \n      9. 判断字符串是否指定的子串结尾\n      \n         ```java\n         String s1 = \"刘亦菲.jpg\";\n         boolean f2 = s1.endsWith(.jpg);\n         System.out.println(f2?\"s是指定的子串结尾\":\"不是指定的子串结尾\")\n         ```\n      \n      10. 获取指定子串的下标位置\n      \n         获取第一次出现的下标位置\n      \n         ```java\n         String s1 = \"adwadjjj jwdjwad\";\n         int index = s1.indexOf(\"wa\");\n         ```\n      \n         从指定下标位置开始向后查找\n      \n         ```java\n         String s1 = \"asdfghjklqwertyu\";\n         int index = s1.indexOf(\"er\",3);\n         ```\n      \n         获取指定子串最后一次出现的下标位置\n      \n         ```java\n         String s1 = \"qwetyuiop\";\n         int index = s1.lastIndexOf(\"i\");\n         ```\n      \n         截取子串\n      \n         从指定下标位置开始，截取到字符串的末尾\n      \n         ```java\n         String s1 = \"zxcvbnm\";\n         s1.substring(12);\n         ```\n      \n         包含开始下标位置，不包含结束下标位置\n      \n         截取范围[start,end]\n      \n         ```java\n         String s1 = \"qwertyuio\";\n         s1.substring(4,8)；\n         ----------------------\n         s1.substring(s1.indexOf(\"q\"),s1.indexOf(\"y\")+1)；\n         ```\n      \n      11. 判断是否包含指定子串\n      \n          ```java\n          String s1 = \"qwertyuiop\";\n          boolean f1 = s1.contains(\"yui\");\n          System.out.println(f4?\"包含:不包含\")\n          ```\n      \n      12. 判断是否为空字符串\n      \n          ```java\n          String s1 = \"\";\n          boolean f1 = s1.isEmpty();\n          System.out.println(f1?\"空字符串\":\"非空字符串\")；\n          ```\n      \n      13. 去除字符串两侧空白\n      \n          ```java\n          String s1 = \"  张三  \"；\n          s1.trim();\n          ```\n      \n      14. 忽略大小写比较\n      \n          ```java\n          String s1 = \"asdfhg\";\n          String s2 =\"ASDHG\";\n          S1.equalslgnoreCase(s2);\n          ```\n      \n      15. 字符串以分隔符拼接\n      \n          ```java\n          String s1 = String.join(\":\",\"张三\"，\"李四\",\"王五\")；\n          System.out.println(s1);\n          ```\n      \n      16. 将其他任意类型转为字符串类型\n      \n          基本类型\n      \n          ```java\n          int n = 100;\n          String s1 = String.valueOf(n);\n          ```\n      \n          引用类型\n      \n          ```Java\n          Point point = new Point(5,10);\n          String s1 = String.valueOf(point);\n          ```\n      \n   5. **正则表达式Regex**\n   \n      用于检测字符串是否符合某一特定规则的格式匹配工具，在Java中正则表达式是使用字符串来表示的\n   \n      点：任意一个字符\n   \n      \\d：任意一个数字字符\n   \n      \\w：任意一个单词字符（字母数字下滑线）\n   \n      \\s：空白（空白，换行）\n   \n      \\D：非数字字符\n   \n      \\W：非单词字符\n   \n      \\S：非空白字符\n   \n      \\[0~9]:任意一个数字字符\n   \n      \\[0~9a-zA-Z_]:任意一个数字字母下划线\n   \n      \\[abc]:a或b或c中任意一个字符\n   \n      \\[^abc]:排除abc外的其他任意字符\n   \n      ? :0个或1个\n   \n      \\+ :一个或多个\n   \n      \\* :0个或多个\n   \n      \\d{6}：必须是6位数字\n   \n      \\d{6，8}：最少6位，最多8位纯数字\n   \n      \\d{6,}:最少6位，最多不限\n   \n      \\d{，8}:最少不限，最多8位\n   \n      & ：并且\n   \n      | ：或者\n   \n   6. **字符串中跟正则表达式相关的3个API方法：**\n   \n      1. matches（string regex)\n   \n         检测字符串是否符号正则表达式制定的规则\n   \n      2. split(String regex)\n   \n         按照正则表达式的规则切分字符串\n   \n      3. replaceAll（String regex)\n   \n         按照正则表达式的规则替换字符串中能匹配上的子串\n   \n5. **java.lang.StringBuilder**\n\n   1. 可变字符串，比较适合用于对字符串进行频繁修改，无论修改（内容，大小，长度）多少次，都是原来那个对象，不会创建新的对象，其内部维护着一个可变的字符数组，节省系统内存\n\n   2. 构建对象\n\n      ```java\n      //无参构造默认初始化另一个16长度的字符数组\n      StringBuilder sb = new StringBuilder()；\n      //带参数构造方法，参数长度+16的长度数组\n      StringBuilder sb = new StringBuilder(\"abc\")；\n      ```\n\n   3. apped()追加内容\n\n      ```java\n      StringBuilder sb = new StringBuilder(\"abc\")；\n      sb.apped(\"def\");\n      System.out.println(sb);\n      ```\n\n   4. reverse()内容翻转\n\n   5. setCharAt(0,0)替换指定下标位置字符\n\n   6. delete(0,0)删除指定下标位置包前不包后[start,end)\n\n6. **java.lang.StringBuffer**\n\n   \n\n\n\n\n\n\n\n\n\n\n\n","slug":"JavaAPI","published":1,"updated":"2023-08-10T09:48:55.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw98000ffswo1jklh8k9","content":"<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>application programming interface</p>\n<p>应用程序编程接口，学习Java官方已经定义好一些类或接口</p>\n<ol>\n<li><p>如何学习一个API</p>\n<ol>\n<li>这个类是什么</li>\n<li>这个类有什么作用</li>\n<li>如何创建这个类的对象</li>\n<li>这个类中有那些属性和方法，各有什么作用</li>\n<li>在那些情形下需要使用到这个类</li>\n</ol>\n</li>\n<li><p>怎样学好API</p>\n<ol>\n<li>查手册</li>\n<li>看源码</li>\n</ol>\n</li>\n<li><p>核心API</p>\n<ol>\n<li>Object</li>\n<li>字符序列:String&#x2F;StringBuilder&#x2F;StringBuffer</li>\n<li>包装类:Byte&#x2F;Short&#x2F;Integer&#x2F;Long&#x2F;Float&#x2F;Double&#x2F;Boolean&#x2F;Character</li>\n<li>时间日期：Data&#x2F;Calendar&#x2F;LocalDate&#x2F;LocalTime&#x2F;LocatDateTime</li>\n<li>集合容器：Collection&#x2F;Map</li>\n<li>数据结构：数组&#x2F;链表&#x2F;树&#x2F;栈&#x2F;队列&#x2F;哈希表&#x2F;图&#x2F;堆</li>\n<li>异常：Exception&#x2F;Error</li>\n<li>文件：File&#x2F;</li>\n<li>IO流：字节流&#x2F;字符流&#x2F;输入&#x2F;输出</li>\n<li>线程：Thread</li>\n<li>网络编程：Socket</li>\n</ol>\n</li>\n<li><p><strong>Java.lang包</strong></p>\n<p>语言包，使用该包下面的类都不需要导包</p>\n<ol>\n<li><p><strong>Java.long.Object</strong></p>\n<p>所有类的顶层父类，如果一个类没有继承其他类，默认会继承Object类，给所有的类提供一些公共的方法，让子类去继承或重写</p>\n</li>\n<li><p><strong>toString</strong></p>\n<p>在Object类中该方法用于打印输出内存的哈希值，所有子类需要进行重写，重写之后可以显示对象的成员变量信息</p>\n<p>在默认输出对象时，默认会调用对象的toString()方法</p>\n<p>对象和字符串之间使用+做拼接时，默认会去调用对象的toString方法</p>\n</li>\n<li><p><strong>equals</strong></p>\n<p>在Object类中,该方法默认比较的是两个对象的地址值，所有子类都需要进行重写，从而比骄两个对象的属性值，当属性值相同时就返回true，不同返回false</p>\n<p>是为了让子类去重写后能够比较两个类的成员变量信息，如果两个对象的属性值相同，不管是否为同一对象，那么都因该返会true否则如果属性值不同就返回false，所以我们所有的子类都需要按照规定重写</p>\n<blockquote>\n<p>面试题：equals和&#x3D; &#x3D; 有什么区别</p>\n<ol>\n<li>八种基本类型之间的比较都用 &#x3D; &#x3D;</li>\n<li>引用类型之间比较地址值，也就是判断两个对象是否为同一对象，也使用 &#x3D; &#x3D;</li>\n<li>判断一个对象是否为null，使用&#x3D; &#x3D; 或者！&#x3D;</li>\n<li>在经过子类重写后equals（）可以用于判断两个对象的属性值是否相同，如果没有重写equals（）默认比较的还是地址值</li>\n</ol>\n</blockquote>\n</li>\n<li><p><strong>Java.long.String</strong></p>\n<ol>\n<li><p>字符串，用于表示一串字，字符串的本质是一个字符数组char[]</p>\n</li>\n<li><p>字符串特点：字符串是一个常量，一旦定义后内容（长度，大小）不可改变，如果字符串内容变了，一定是创建新的字符串对象</p>\n<p>原因：字符串采用的是char[]数组做存储而char[]数组使用了private final修饰符，并且没有对外界提供公开的方法来修改这个数组</p>\n</li>\n<li><p>字符串对象的创建</p>\n<ol>\n<li><p>使用构造方法来创建对象</p>\n<p>当使用构造方法创建对象时，首先会去检查字符串常量池中是否有这个字符串对象，如果没有就先在池中创建一个，然后复制到堆中，如果池中有这个对象，就就直接将池中这个对象复制到堆中，然后栈中的引用指向堆中的对象</p>\n</li>\n<li><p>利用字符串拼接创建对象</p>\n<p>字符串和其他任意类型之间可以使用+做拼接，拼接完成后的结果还是一个字符串</p>\n<blockquote>\n<p>Java编译器优化：</p>\n<p>如果右侧参与拼接的全部都是字符串字面值，在编译期间就已经确定他的结果，那么Java编译器在编译期间直接将右侧字符串字面值全部拼接在一起，然后再运行</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> s2+<span class=\"string\">&quot;c&quot;</span>;</span><br><span class=\"line\">System.out,println(s1.equals(s3));<span class=\"comment\">//true</span></span><br><span class=\"line\">System.out,println(s1==s3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>在编译期间无法确定值是什么，只有到运行期间才会将值从变量中取出来，再参与拼接</p>\n</li>\n</ol>\n</li>\n<li><p>字符串常量池</p>\n<p>当使用字符串字面值创建对象时，首先会去检查字符串常量池中有没有这个字符串对象，如果没有就在池中创建一个，然后栈中引用指向池中这个对象，如果有就不在创建，从而让对象可以得到复用，节省内存空间</p>\n</li>\n<li><p>字符串转为数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.toCharArray();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串获取长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.charAt(index);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串转大小写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.toUpperCase();<span class=\"comment\">//大写</span></span><br><span class=\"line\">s1.toLowerCase()<span class=\"comment\">//小写</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断字符串是否以指定的子串开头</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.startWith(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">System.out.println(f1?<span class=\"string\">&quot;是指定子串开头&quot;</span>:<span class=\"string\">&quot;不是子串开头&quot;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断字符串是否指定的子串结尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;刘亦菲.jpg&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f2</span> <span class=\"operator\">=</span> s1.endsWith(.jpg);</span><br><span class=\"line\">System.out.println(f2?<span class=\"string\">&quot;s是指定的子串结尾&quot;</span>:<span class=\"string\">&quot;不是指定的子串结尾&quot;</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取指定子串的下标位置</p>\n</li>\n</ol>\n<p>   获取第一次出现的下标位置</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;adwadjjj jwdjwad&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.indexOf(<span class=\"string\">&quot;wa&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   从指定下标位置开始向后查找</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;asdfghjklqwertyu&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.indexOf(<span class=\"string\">&quot;er&quot;</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   获取指定子串最后一次出现的下标位置</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwetyuiop&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.lastIndexOf(<span class=\"string\">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   截取子串</p>\n<p>   从指定下标位置开始，截取到字符串的末尾</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zxcvbnm&quot;</span>;</span><br><span class=\"line\">s1.substring(<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   包含开始下标位置，不包含结束下标位置</p>\n<p>   截取范围[start,end]</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwertyuio&quot;</span>;</span><br><span class=\"line\">s1.substring(<span class=\"number\">4</span>,<span class=\"number\">8</span>)；</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">s1.substring(s1.indexOf(<span class=\"string\">&quot;q&quot;</span>),s1.indexOf(<span class=\"string\">&quot;y&quot;</span>)+<span class=\"number\">1</span>)；</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><p>判断是否包含指定子串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwertyuiop&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.contains(<span class=\"string\">&quot;yui&quot;</span>);</span><br><span class=\"line\">System.out.println(f4?<span class=\"string\">&quot;包含:不包含&quot;</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断是否为空字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.isEmpty();</span><br><span class=\"line\">System.out.println(f1?<span class=\"string\">&quot;空字符串&quot;</span>:<span class=\"string\">&quot;非空字符串&quot;</span>)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>去除字符串两侧空白</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;  张三  &quot;</span>；</span><br><span class=\"line\">s1.trim();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>忽略大小写比较</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;asdfhg&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span><span class=\"string\">&quot;ASDHG&quot;</span>;</span><br><span class=\"line\">S1.equalslgnoreCase(s2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串以分隔符拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.join(<span class=\"string\">&quot;:&quot;</span>,<span class=\"string\">&quot;张三&quot;</span>，<span class=\"string\">&quot;李四&quot;</span>,<span class=\"string\">&quot;王五&quot;</span>)；</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将其他任意类型转为字符串类型</p>\n<p>基本类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.valueOf(n);</span><br></pre></td></tr></table></figure>\n\n<p>引用类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">5</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.valueOf(point);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>正则表达式Regex</strong></p>\n<p>用于检测字符串是否符合某一特定规则的格式匹配工具，在Java中正则表达式是使用字符串来表示的</p>\n<p>点：任意一个字符</p>\n<p>\\d：任意一个数字字符</p>\n<p>\\w：任意一个单词字符（字母数字下滑线）</p>\n<p>\\s：空白（空白，换行）</p>\n<p>\\D：非数字字符</p>\n<p>\\W：非单词字符</p>\n<p>\\S：非空白字符</p>\n<p>[0~9]:任意一个数字字符</p>\n<p>[0~9a-zA-Z_]:任意一个数字字母下划线</p>\n<p>[abc]:a或b或c中任意一个字符</p>\n<p>[^abc]:排除abc外的其他任意字符</p>\n<p>? :0个或1个</p>\n<p>+ :一个或多个</p>\n<p>* :0个或多个</p>\n<p>\\d{6}：必须是6位数字</p>\n<p>\\d{6，8}：最少6位，最多8位纯数字</p>\n<p>\\d{6,}:最少6位，最多不限</p>\n<p>\\d{，8}:最少不限，最多8位</p>\n<p>&amp; ：并且</p>\n<p>| ：或者</p>\n</li>\n<li><p><strong>字符串中跟正则表达式相关的3个API方法：</strong></p>\n<ol>\n<li><p>matches（string regex)</p>\n<p>检测字符串是否符号正则表达式制定的规则</p>\n</li>\n<li><p>split(String regex)</p>\n<p>按照正则表达式的规则切分字符串</p>\n</li>\n<li><p>replaceAll（String regex)</p>\n<p>按照正则表达式的规则替换字符串中能匹配上的子串</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>java.lang.StringBuilder</strong></p>\n<ol>\n<li><p>可变字符串，比较适合用于对字符串进行频繁修改，无论修改（内容，大小，长度）多少次，都是原来那个对象，不会创建新的对象，其内部维护着一个可变的字符数组，节省系统内存</p>\n</li>\n<li><p>构建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无参构造默认初始化另一个16长度的字符数组</span></span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>()；</span><br><span class=\"line\"><span class=\"comment\">//带参数构造方法，参数长度+16的长度数组</span></span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;abc&quot;</span>)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>apped()追加内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;abc&quot;</span>)；</span><br><span class=\"line\">sb.apped(<span class=\"string\">&quot;def&quot;</span>);</span><br><span class=\"line\">System.out.println(sb);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reverse()内容翻转</p>\n</li>\n<li><p>setCharAt(0,0)替换指定下标位置字符</p>\n</li>\n<li><p>delete(0,0)删除指定下标位置包前不包后[start,end)</p>\n</li>\n</ol>\n</li>\n<li><p><strong>java.lang.StringBuffer</strong></p>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>application programming interface</p>\n<p>应用程序编程接口，学习Java官方已经定义好一些类或接口</p>\n<ol>\n<li><p>如何学习一个API</p>\n<ol>\n<li>这个类是什么</li>\n<li>这个类有什么作用</li>\n<li>如何创建这个类的对象</li>\n<li>这个类中有那些属性和方法，各有什么作用</li>\n<li>在那些情形下需要使用到这个类</li>\n</ol>\n</li>\n<li><p>怎样学好API</p>\n<ol>\n<li>查手册</li>\n<li>看源码</li>\n</ol>\n</li>\n<li><p>核心API</p>\n<ol>\n<li>Object</li>\n<li>字符序列:String&#x2F;StringBuilder&#x2F;StringBuffer</li>\n<li>包装类:Byte&#x2F;Short&#x2F;Integer&#x2F;Long&#x2F;Float&#x2F;Double&#x2F;Boolean&#x2F;Character</li>\n<li>时间日期：Data&#x2F;Calendar&#x2F;LocalDate&#x2F;LocalTime&#x2F;LocatDateTime</li>\n<li>集合容器：Collection&#x2F;Map</li>\n<li>数据结构：数组&#x2F;链表&#x2F;树&#x2F;栈&#x2F;队列&#x2F;哈希表&#x2F;图&#x2F;堆</li>\n<li>异常：Exception&#x2F;Error</li>\n<li>文件：File&#x2F;</li>\n<li>IO流：字节流&#x2F;字符流&#x2F;输入&#x2F;输出</li>\n<li>线程：Thread</li>\n<li>网络编程：Socket</li>\n</ol>\n</li>\n<li><p><strong>Java.lang包</strong></p>\n<p>语言包，使用该包下面的类都不需要导包</p>\n<ol>\n<li><p><strong>Java.long.Object</strong></p>\n<p>所有类的顶层父类，如果一个类没有继承其他类，默认会继承Object类，给所有的类提供一些公共的方法，让子类去继承或重写</p>\n</li>\n<li><p><strong>toString</strong></p>\n<p>在Object类中该方法用于打印输出内存的哈希值，所有子类需要进行重写，重写之后可以显示对象的成员变量信息</p>\n<p>在默认输出对象时，默认会调用对象的toString()方法</p>\n<p>对象和字符串之间使用+做拼接时，默认会去调用对象的toString方法</p>\n</li>\n<li><p><strong>equals</strong></p>\n<p>在Object类中,该方法默认比较的是两个对象的地址值，所有子类都需要进行重写，从而比骄两个对象的属性值，当属性值相同时就返回true，不同返回false</p>\n<p>是为了让子类去重写后能够比较两个类的成员变量信息，如果两个对象的属性值相同，不管是否为同一对象，那么都因该返会true否则如果属性值不同就返回false，所以我们所有的子类都需要按照规定重写</p>\n<blockquote>\n<p>面试题：equals和&#x3D; &#x3D; 有什么区别</p>\n<ol>\n<li>八种基本类型之间的比较都用 &#x3D; &#x3D;</li>\n<li>引用类型之间比较地址值，也就是判断两个对象是否为同一对象，也使用 &#x3D; &#x3D;</li>\n<li>判断一个对象是否为null，使用&#x3D; &#x3D; 或者！&#x3D;</li>\n<li>在经过子类重写后equals（）可以用于判断两个对象的属性值是否相同，如果没有重写equals（）默认比较的还是地址值</li>\n</ol>\n</blockquote>\n</li>\n<li><p><strong>Java.long.String</strong></p>\n<ol>\n<li><p>字符串，用于表示一串字，字符串的本质是一个字符数组char[]</p>\n</li>\n<li><p>字符串特点：字符串是一个常量，一旦定义后内容（长度，大小）不可改变，如果字符串内容变了，一定是创建新的字符串对象</p>\n<p>原因：字符串采用的是char[]数组做存储而char[]数组使用了private final修饰符，并且没有对外界提供公开的方法来修改这个数组</p>\n</li>\n<li><p>字符串对象的创建</p>\n<ol>\n<li><p>使用构造方法来创建对象</p>\n<p>当使用构造方法创建对象时，首先会去检查字符串常量池中是否有这个字符串对象，如果没有就先在池中创建一个，然后复制到堆中，如果池中有这个对象，就就直接将池中这个对象复制到堆中，然后栈中的引用指向堆中的对象</p>\n</li>\n<li><p>利用字符串拼接创建对象</p>\n<p>字符串和其他任意类型之间可以使用+做拼接，拼接完成后的结果还是一个字符串</p>\n<blockquote>\n<p>Java编译器优化：</p>\n<p>如果右侧参与拼接的全部都是字符串字面值，在编译期间就已经确定他的结果，那么Java编译器在编译期间直接将右侧字符串字面值全部拼接在一起，然后再运行</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> s2+<span class=\"string\">&quot;c&quot;</span>;</span><br><span class=\"line\">System.out,println(s1.equals(s3));<span class=\"comment\">//true</span></span><br><span class=\"line\">System.out,println(s1==s3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>在编译期间无法确定值是什么，只有到运行期间才会将值从变量中取出来，再参与拼接</p>\n</li>\n</ol>\n</li>\n<li><p>字符串常量池</p>\n<p>当使用字符串字面值创建对象时，首先会去检查字符串常量池中有没有这个字符串对象，如果没有就在池中创建一个，然后栈中引用指向池中这个对象，如果有就不在创建，从而让对象可以得到复用，节省内存空间</p>\n</li>\n<li><p>字符串转为数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.toCharArray();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串获取长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.charAt(index);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串转大小写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">s1.toUpperCase();<span class=\"comment\">//大写</span></span><br><span class=\"line\">s1.toLowerCase()<span class=\"comment\">//小写</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断字符串是否以指定的子串开头</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.startWith(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">System.out.println(f1?<span class=\"string\">&quot;是指定子串开头&quot;</span>:<span class=\"string\">&quot;不是子串开头&quot;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断字符串是否指定的子串结尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;刘亦菲.jpg&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f2</span> <span class=\"operator\">=</span> s1.endsWith(.jpg);</span><br><span class=\"line\">System.out.println(f2?<span class=\"string\">&quot;s是指定的子串结尾&quot;</span>:<span class=\"string\">&quot;不是指定的子串结尾&quot;</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取指定子串的下标位置</p>\n</li>\n</ol>\n<p>   获取第一次出现的下标位置</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;adwadjjj jwdjwad&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.indexOf(<span class=\"string\">&quot;wa&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   从指定下标位置开始向后查找</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;asdfghjklqwertyu&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.indexOf(<span class=\"string\">&quot;er&quot;</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   获取指定子串最后一次出现的下标位置</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwetyuiop&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> s1.lastIndexOf(<span class=\"string\">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   截取子串</p>\n<p>   从指定下标位置开始，截取到字符串的末尾</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zxcvbnm&quot;</span>;</span><br><span class=\"line\">s1.substring(<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>   包含开始下标位置，不包含结束下标位置</p>\n<p>   截取范围[start,end]</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwertyuio&quot;</span>;</span><br><span class=\"line\">s1.substring(<span class=\"number\">4</span>,<span class=\"number\">8</span>)；</span><br><span class=\"line\">----------------------</span><br><span class=\"line\">s1.substring(s1.indexOf(<span class=\"string\">&quot;q&quot;</span>),s1.indexOf(<span class=\"string\">&quot;y&quot;</span>)+<span class=\"number\">1</span>)；</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><p>判断是否包含指定子串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;qwertyuiop&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.contains(<span class=\"string\">&quot;yui&quot;</span>);</span><br><span class=\"line\">System.out.println(f4?<span class=\"string\">&quot;包含:不包含&quot;</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断是否为空字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f1</span> <span class=\"operator\">=</span> s1.isEmpty();</span><br><span class=\"line\">System.out.println(f1?<span class=\"string\">&quot;空字符串&quot;</span>:<span class=\"string\">&quot;非空字符串&quot;</span>)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>去除字符串两侧空白</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;  张三  &quot;</span>；</span><br><span class=\"line\">s1.trim();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>忽略大小写比较</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;asdfhg&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span><span class=\"string\">&quot;ASDHG&quot;</span>;</span><br><span class=\"line\">S1.equalslgnoreCase(s2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串以分隔符拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.join(<span class=\"string\">&quot;:&quot;</span>,<span class=\"string\">&quot;张三&quot;</span>，<span class=\"string\">&quot;李四&quot;</span>,<span class=\"string\">&quot;王五&quot;</span>)；</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将其他任意类型转为字符串类型</p>\n<p>基本类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.valueOf(n);</span><br></pre></td></tr></table></figure>\n\n<p>引用类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">5</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> String.valueOf(point);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>正则表达式Regex</strong></p>\n<p>用于检测字符串是否符合某一特定规则的格式匹配工具，在Java中正则表达式是使用字符串来表示的</p>\n<p>点：任意一个字符</p>\n<p>\\d：任意一个数字字符</p>\n<p>\\w：任意一个单词字符（字母数字下滑线）</p>\n<p>\\s：空白（空白，换行）</p>\n<p>\\D：非数字字符</p>\n<p>\\W：非单词字符</p>\n<p>\\S：非空白字符</p>\n<p>[0~9]:任意一个数字字符</p>\n<p>[0~9a-zA-Z_]:任意一个数字字母下划线</p>\n<p>[abc]:a或b或c中任意一个字符</p>\n<p>[^abc]:排除abc外的其他任意字符</p>\n<p>? :0个或1个</p>\n<p>+ :一个或多个</p>\n<p>* :0个或多个</p>\n<p>\\d{6}：必须是6位数字</p>\n<p>\\d{6，8}：最少6位，最多8位纯数字</p>\n<p>\\d{6,}:最少6位，最多不限</p>\n<p>\\d{，8}:最少不限，最多8位</p>\n<p>&amp; ：并且</p>\n<p>| ：或者</p>\n</li>\n<li><p><strong>字符串中跟正则表达式相关的3个API方法：</strong></p>\n<ol>\n<li><p>matches（string regex)</p>\n<p>检测字符串是否符号正则表达式制定的规则</p>\n</li>\n<li><p>split(String regex)</p>\n<p>按照正则表达式的规则切分字符串</p>\n</li>\n<li><p>replaceAll（String regex)</p>\n<p>按照正则表达式的规则替换字符串中能匹配上的子串</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>java.lang.StringBuilder</strong></p>\n<ol>\n<li><p>可变字符串，比较适合用于对字符串进行频繁修改，无论修改（内容，大小，长度）多少次，都是原来那个对象，不会创建新的对象，其内部维护着一个可变的字符数组，节省系统内存</p>\n</li>\n<li><p>构建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无参构造默认初始化另一个16长度的字符数组</span></span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>()；</span><br><span class=\"line\"><span class=\"comment\">//带参数构造方法，参数长度+16的长度数组</span></span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;abc&quot;</span>)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>apped()追加内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;abc&quot;</span>)；</span><br><span class=\"line\">sb.apped(<span class=\"string\">&quot;def&quot;</span>);</span><br><span class=\"line\">System.out.println(sb);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reverse()内容翻转</p>\n</li>\n<li><p>setCharAt(0,0)替换指定下标位置字符</p>\n</li>\n<li><p>delete(0,0)删除指定下标位置包前不包后[start,end)</p>\n</li>\n</ol>\n</li>\n<li><p><strong>java.lang.StringBuffer</strong></p>\n</li>\n</ol>\n"},{"title":"Linux安装各种软件","date":"2023-04-18T03:18:57.000Z","cover":"/img/images/linux.jpg","_content":"\n## Linux安装MySQL\n\n> [MySQL](https://baike.baidu.com/item/MySQL/471251?fr=aladdin)是一种[关系型数据库](https://so.csdn.net/so/search?q=关系型数据库&spm=1001.2101.3001.7020)管理系统，\n\n**一、安装**\n\n1. 创建一个文件夹\n\n   > mkdir /soft/mysql\n   >\n   > cd /soft/mysql\n\n2. 解压mysql安装包\n\n   > mkdir mysql-8.0.30\n   >\n   > tar -xvf mysql-8.0.30-1.el7.....tar -C mysql-8.0.30\n\n3. rpm安装\n\n   > 切换到解压的mysql目录下，这些文件都是rpm安装包，需要下载openssl-devel插件\n   >\n   > yum install openssl-devel\n\n4. 安装rpm包\n\n   > 注意：一定要按照顺序\n   >\n   > rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm \n   >\n   > rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm \n   >\n   > rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm\n   > \n  \n   > 注意：在 Linux 中 MySQL 安装好了之后系统会自动的注册一个服务，服务名称叫做mysqld，所以可以通过以下命令操作 MySQL：\n   > \n   > 启动 MySQL 服务：systemctl start mysqld\n   >\n   > 重启 MySQL 服务：systemctl restart mysqld\n   >\n   > 关闭 MySQL 服务：systemctl stop mysqld\n\n5. 启动mysql服务 \n\n   > systemctl start mysqld\n\n5. 查看随机密码\n\n   > cat /var/log/mysqld.log\n\n5. 链接数据库\n\n   > mysql -u root -p\n\n**二、卸载**\n\n1. 停止mysql服务\n\n   > systemctl stop mysqld\n\n2. 查询Mysql的安装文件\n\n   > rpm -qa | grep -i mysql\n\n3. 跟据上述查询结果一条一条卸载所有Mysql安装包\n\n   > rpm -e 文件名 --nodeps\n\n4. 删除MySQL的数据存放目录\n\n   >  rm -rf /var/lib/mysql/\n\n5. 删除MySQL的配置文件备份\n\n   > rm -rf /etc/my.cnf.rpmsave\n\n**三、常用设置**\n\n1. 修改用户名密码\n\n   > ALTER  USER  'root'@'localhost'  IDENTIFIED BY '你的密码'\n\n2. 创建用户与权限分配\n\n   默认的 root 用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个新的账户，用于远程访问\n\n   > create user '用户名称'@'%' IDENTIFIED WITH mysql_native_password BY '密码';\n\n   > 创建完用户分配所有权限\n   >\n   > grant all on *.* to 'mike'@'%';\n\n3. 密码策略修改\n\n   1. 查询Mysql所有的密码相关策略\n\n      > show variables like 'validate_password%';\n\n   2. 变量名说明\n\n      >变量名说明：\n      >\n      >validate_password_check_user_name：关闭用户名验证，OFF/ON：关闭/开启，默认为OFF，即关闭；\n      >\n      >\n      >validate_password_dictionary_file：用于验证密码强度的字典文件路径；\n      >\n      >\n      >validate_password_length：密码最小长度，参数默认为8，它有最小值的限制，最小值为的计算方法为validate_password_number_count+validate_password_special_char_count +(2*validate_password_mixed_case_count) ，这就是为什么很多人搞不懂明明设置了长度为1，但是最后还是为4个的长度，所以这儿要注意；\n      >\n      >\n      >validate_password_mixed_case_count：密码至少要包含的小写字母个数和大写字母个数，默认为1个；\n      >\n      >\n      >validate_password_number_count：密码至少要包含的数字个数，默认为1个；\n      >\n      >\n      >validate_password_policy：密码强度检查等级，等级总共为：0/LOW、1/MEDIUM、2/STRONG 三种，默认为MEDIUM，即1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符；\n      >\n      >validate_password_special_char_count：密码至少要包含的特殊字符数，默认为1个；\n\n   3. 修改密码策略\n\n      先将密码策略修改为LOW\n\n      > set global validate_password_policy=0;\n\n      再将密码长度修改4位\n\n      >  set global validate_password_length=4;\n\n\n\n## Linux安装Java\n\n**一、安装**\n\n1. 创建java目录\n\n   > mkdir /usr/local/java/\n\n2. 解压下载好的Java安装包\n\n   > tar -zxvf jdk-8u341-linux-x64.tar.gz -C /usr/local/java/\n\n3. 配置环境变量\n\n   > vi /etc/profile\n\n   > export JAVA_HOME=/usr/local/java/jdk1.8.0_341\n   > export JRE_HOME=${JAVA_HOME}/jre\n   > export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\n   > export PATH=${JAVA_HOME}/bin:$PATH\n   \n4. 使环境变量生效\n\n   > source /etc/profile\n\n5. 添加软链接\n\n   > ln -s /usr/local/java/jdk1.8.0_341/bin/java /usr/bin/java\n\n6. 查看Java版本\n\n   > java -version\n\n**二、卸载**\n\n1. 查询java是否安装\n\n   > **rpm -qa |grep java**\n\n2. VM中查询Java列表\n\n   > rpm -qa | grep java\n\n3. 卸载Java\n\n   > yum remove openjdk\n\n4. 其他卸载命令\n\n   >rpm -e rpm -qa|gerp java 卸载\n   >\n   >rpm -e rpm -qa|gerp java --nodeps 强制卸载\n\n\n\n## Linux配置Tomcat\n\n**一、安装**\n\n1. 创建目录\n\n   > mkdir /usr/local/Tomcat\n\n2. 解压\n\n   > tar -zxvf Tomcat安装包\n\n3. 进入Tomcat的bin目录\n\n   > chmod 777 ./*  给文件提高至最高权限\n\n4. 配置环境变量\n\n   > vim /etc/profile \n\n   >\\#tomcat\n   >export TOMCAT_HOME=/usr/local/tomcat/apache-tomcat-9.0.65\n   >\n   >export CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.65\n\n5. 修改Tomcat启动分析脚本\n\n   > vim /usr/local/tomcat/apache-tomcat/bin/setclasspath.sh\n\n   > export JAVA_HOME=/usr/local/java/jdk1.8.0_341\n   >\n   > export JRE_HOME=${JAVA_HOME}/jre\n\n6. 启动Tomcat\n\n   > 进入Tomcat/bin目录\n   >\n   > ./startup.sh\n\n\n\n\n\n## Linux配置Node\n\n一、安装\n\n1. 创建目录\n\n   > mkdir /usr/local/node\n\n2. 解压Node安装包\n\n   > *tar* -xvf node-v16.15.0-linux-x64.tar.xz\n\n3. 配置环境变量\n\n   >*sudo v*im /etc/profile\n\n   > export NODE_HOME=/usr/local/nodejs \n   > export PATH=$NODE_HOME/bin:$PATH\n\n4. 让环境变量生效\n\n   > *source* /etc/profile\n\n5. 测试是否安装成功\n\n   > node -v\n\n\n\n## Linux安装Notepadqq\n\n**一、安装**\n\n> sudo add-apt-repository ppa:notepadqq-team/notepadqq \n>\n> sudo apt-get update \n>\n> sudo apt-get install notepadqq\n\n**二、卸载**\n\n> sudo apt-get remove notepadqq \n>\n> sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq\n","source":"_posts/Linux.md","raw":"---\ntitle: Linux安装各种软件\ndate: 2023-04-18 11:18:57\ntags: Linux\ncategories: Linux\ncover: /img/images/linux.jpg\n---\n\n## Linux安装MySQL\n\n> [MySQL](https://baike.baidu.com/item/MySQL/471251?fr=aladdin)是一种[关系型数据库](https://so.csdn.net/so/search?q=关系型数据库&spm=1001.2101.3001.7020)管理系统，\n\n**一、安装**\n\n1. 创建一个文件夹\n\n   > mkdir /soft/mysql\n   >\n   > cd /soft/mysql\n\n2. 解压mysql安装包\n\n   > mkdir mysql-8.0.30\n   >\n   > tar -xvf mysql-8.0.30-1.el7.....tar -C mysql-8.0.30\n\n3. rpm安装\n\n   > 切换到解压的mysql目录下，这些文件都是rpm安装包，需要下载openssl-devel插件\n   >\n   > yum install openssl-devel\n\n4. 安装rpm包\n\n   > 注意：一定要按照顺序\n   >\n   > rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm \n   >\n   > rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm \n   >\n   > rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm\n   >\n   > rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm\n   > \n  \n   > 注意：在 Linux 中 MySQL 安装好了之后系统会自动的注册一个服务，服务名称叫做mysqld，所以可以通过以下命令操作 MySQL：\n   > \n   > 启动 MySQL 服务：systemctl start mysqld\n   >\n   > 重启 MySQL 服务：systemctl restart mysqld\n   >\n   > 关闭 MySQL 服务：systemctl stop mysqld\n\n5. 启动mysql服务 \n\n   > systemctl start mysqld\n\n5. 查看随机密码\n\n   > cat /var/log/mysqld.log\n\n5. 链接数据库\n\n   > mysql -u root -p\n\n**二、卸载**\n\n1. 停止mysql服务\n\n   > systemctl stop mysqld\n\n2. 查询Mysql的安装文件\n\n   > rpm -qa | grep -i mysql\n\n3. 跟据上述查询结果一条一条卸载所有Mysql安装包\n\n   > rpm -e 文件名 --nodeps\n\n4. 删除MySQL的数据存放目录\n\n   >  rm -rf /var/lib/mysql/\n\n5. 删除MySQL的配置文件备份\n\n   > rm -rf /etc/my.cnf.rpmsave\n\n**三、常用设置**\n\n1. 修改用户名密码\n\n   > ALTER  USER  'root'@'localhost'  IDENTIFIED BY '你的密码'\n\n2. 创建用户与权限分配\n\n   默认的 root 用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个新的账户，用于远程访问\n\n   > create user '用户名称'@'%' IDENTIFIED WITH mysql_native_password BY '密码';\n\n   > 创建完用户分配所有权限\n   >\n   > grant all on *.* to 'mike'@'%';\n\n3. 密码策略修改\n\n   1. 查询Mysql所有的密码相关策略\n\n      > show variables like 'validate_password%';\n\n   2. 变量名说明\n\n      >变量名说明：\n      >\n      >validate_password_check_user_name：关闭用户名验证，OFF/ON：关闭/开启，默认为OFF，即关闭；\n      >\n      >\n      >validate_password_dictionary_file：用于验证密码强度的字典文件路径；\n      >\n      >\n      >validate_password_length：密码最小长度，参数默认为8，它有最小值的限制，最小值为的计算方法为validate_password_number_count+validate_password_special_char_count +(2*validate_password_mixed_case_count) ，这就是为什么很多人搞不懂明明设置了长度为1，但是最后还是为4个的长度，所以这儿要注意；\n      >\n      >\n      >validate_password_mixed_case_count：密码至少要包含的小写字母个数和大写字母个数，默认为1个；\n      >\n      >\n      >validate_password_number_count：密码至少要包含的数字个数，默认为1个；\n      >\n      >\n      >validate_password_policy：密码强度检查等级，等级总共为：0/LOW、1/MEDIUM、2/STRONG 三种，默认为MEDIUM，即1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符；\n      >\n      >validate_password_special_char_count：密码至少要包含的特殊字符数，默认为1个；\n\n   3. 修改密码策略\n\n      先将密码策略修改为LOW\n\n      > set global validate_password_policy=0;\n\n      再将密码长度修改4位\n\n      >  set global validate_password_length=4;\n\n\n\n## Linux安装Java\n\n**一、安装**\n\n1. 创建java目录\n\n   > mkdir /usr/local/java/\n\n2. 解压下载好的Java安装包\n\n   > tar -zxvf jdk-8u341-linux-x64.tar.gz -C /usr/local/java/\n\n3. 配置环境变量\n\n   > vi /etc/profile\n\n   > export JAVA_HOME=/usr/local/java/jdk1.8.0_341\n   > export JRE_HOME=${JAVA_HOME}/jre\n   > export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\n   > export PATH=${JAVA_HOME}/bin:$PATH\n   \n4. 使环境变量生效\n\n   > source /etc/profile\n\n5. 添加软链接\n\n   > ln -s /usr/local/java/jdk1.8.0_341/bin/java /usr/bin/java\n\n6. 查看Java版本\n\n   > java -version\n\n**二、卸载**\n\n1. 查询java是否安装\n\n   > **rpm -qa |grep java**\n\n2. VM中查询Java列表\n\n   > rpm -qa | grep java\n\n3. 卸载Java\n\n   > yum remove openjdk\n\n4. 其他卸载命令\n\n   >rpm -e rpm -qa|gerp java 卸载\n   >\n   >rpm -e rpm -qa|gerp java --nodeps 强制卸载\n\n\n\n## Linux配置Tomcat\n\n**一、安装**\n\n1. 创建目录\n\n   > mkdir /usr/local/Tomcat\n\n2. 解压\n\n   > tar -zxvf Tomcat安装包\n\n3. 进入Tomcat的bin目录\n\n   > chmod 777 ./*  给文件提高至最高权限\n\n4. 配置环境变量\n\n   > vim /etc/profile \n\n   >\\#tomcat\n   >export TOMCAT_HOME=/usr/local/tomcat/apache-tomcat-9.0.65\n   >\n   >export CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.65\n\n5. 修改Tomcat启动分析脚本\n\n   > vim /usr/local/tomcat/apache-tomcat/bin/setclasspath.sh\n\n   > export JAVA_HOME=/usr/local/java/jdk1.8.0_341\n   >\n   > export JRE_HOME=${JAVA_HOME}/jre\n\n6. 启动Tomcat\n\n   > 进入Tomcat/bin目录\n   >\n   > ./startup.sh\n\n\n\n\n\n## Linux配置Node\n\n一、安装\n\n1. 创建目录\n\n   > mkdir /usr/local/node\n\n2. 解压Node安装包\n\n   > *tar* -xvf node-v16.15.0-linux-x64.tar.xz\n\n3. 配置环境变量\n\n   >*sudo v*im /etc/profile\n\n   > export NODE_HOME=/usr/local/nodejs \n   > export PATH=$NODE_HOME/bin:$PATH\n\n4. 让环境变量生效\n\n   > *source* /etc/profile\n\n5. 测试是否安装成功\n\n   > node -v\n\n\n\n## Linux安装Notepadqq\n\n**一、安装**\n\n> sudo add-apt-repository ppa:notepadqq-team/notepadqq \n>\n> sudo apt-get update \n>\n> sudo apt-get install notepadqq\n\n**二、卸载**\n\n> sudo apt-get remove notepadqq \n>\n> sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq\n","slug":"Linux","published":1,"updated":"2023-08-10T09:50:32.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw99000gfswo9g299jh1","content":"<h2 id=\"Linux安装MySQL\"><a href=\"#Linux安装MySQL\" class=\"headerlink\" title=\"Linux安装MySQL\"></a>Linux安装MySQL</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/item/MySQL/471251?fr=aladdin\">MySQL</a>是一种<a href=\"https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020\">关系型数据库</a>管理系统，</p>\n</blockquote>\n<p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建一个文件夹</p>\n<blockquote>\n<p>mkdir &#x2F;soft&#x2F;mysql</p>\n<p>cd &#x2F;soft&#x2F;mysql</p>\n</blockquote>\n</li>\n<li><p>解压mysql安装包</p>\n<blockquote>\n<p>mkdir mysql-8.0.30</p>\n<p>tar -xvf mysql-8.0.30-1.el7…..tar -C mysql-8.0.30</p>\n</blockquote>\n</li>\n<li><p>rpm安装</p>\n<blockquote>\n<p>切换到解压的mysql目录下，这些文件都是rpm安装包，需要下载openssl-devel插件</p>\n<p>yum install openssl-devel</p>\n</blockquote>\n</li>\n<li><p>安装rpm包</p>\n<blockquote>\n<p>注意：一定要按照顺序</p>\n<p>rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </p>\n<p>rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </p>\n<p>rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</p>\n</blockquote>\n<blockquote>\n<p>注意：在 Linux 中 MySQL 安装好了之后系统会自动的注册一个服务，服务名称叫做mysqld，所以可以通过以下命令操作 MySQL：</p>\n<p>启动 MySQL 服务：systemctl start mysqld</p>\n<p>重启 MySQL 服务：systemctl restart mysqld</p>\n<p>关闭 MySQL 服务：systemctl stop mysqld</p>\n</blockquote>\n</li>\n<li><p>启动mysql服务 </p>\n<blockquote>\n<p>systemctl start mysqld</p>\n</blockquote>\n</li>\n<li><p>查看随机密码</p>\n<blockquote>\n<p>cat &#x2F;var&#x2F;log&#x2F;mysqld.log</p>\n</blockquote>\n</li>\n<li><p>链接数据库</p>\n<blockquote>\n<p>mysql -u root -p</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>二、卸载</strong></p>\n<ol>\n<li><p>停止mysql服务</p>\n<blockquote>\n<p>systemctl stop mysqld</p>\n</blockquote>\n</li>\n<li><p>查询Mysql的安装文件</p>\n<blockquote>\n<p>rpm -qa | grep -i mysql</p>\n</blockquote>\n</li>\n<li><p>跟据上述查询结果一条一条卸载所有Mysql安装包</p>\n<blockquote>\n<p>rpm -e 文件名 –nodeps</p>\n</blockquote>\n</li>\n<li><p>删除MySQL的数据存放目录</p>\n<blockquote>\n<p> rm -rf &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</p>\n</blockquote>\n</li>\n<li><p>删除MySQL的配置文件备份</p>\n<blockquote>\n<p>rm -rf &#x2F;etc&#x2F;my.cnf.rpmsave</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>三、常用设置</strong></p>\n<ol>\n<li><p>修改用户名密码</p>\n<blockquote>\n<p>ALTER  USER  ‘root‘@’localhost’  IDENTIFIED BY ‘你的密码’</p>\n</blockquote>\n</li>\n<li><p>创建用户与权限分配</p>\n<p>默认的 root 用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个新的账户，用于远程访问</p>\n<blockquote>\n<p>create user ‘用户名称‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘密码’;</p>\n</blockquote>\n<blockquote>\n<p>创建完用户分配所有权限</p>\n<p>grant all on <em>.</em> to ‘mike‘@’%’;</p>\n</blockquote>\n</li>\n<li><p>密码策略修改</p>\n<ol>\n<li><p>查询Mysql所有的密码相关策略</p>\n<blockquote>\n<p>show variables like ‘validate_password%’;</p>\n</blockquote>\n</li>\n<li><p>变量名说明</p>\n<blockquote>\n<p>变量名说明：</p>\n<p>validate_password_check_user_name：关闭用户名验证，OFF&#x2F;ON：关闭&#x2F;开启，默认为OFF，即关闭；</p>\n<p>validate_password_dictionary_file：用于验证密码强度的字典文件路径；</p>\n<p>validate_password_length：密码最小长度，参数默认为8，它有最小值的限制，最小值为的计算方法为validate_password_number_count+validate_password_special_char_count +(2*validate_password_mixed_case_count) ，这就是为什么很多人搞不懂明明设置了长度为1，但是最后还是为4个的长度，所以这儿要注意；</p>\n<p>validate_password_mixed_case_count：密码至少要包含的小写字母个数和大写字母个数，默认为1个；</p>\n<p>validate_password_number_count：密码至少要包含的数字个数，默认为1个；</p>\n<p>validate_password_policy：密码强度检查等级，等级总共为：0&#x2F;LOW、1&#x2F;MEDIUM、2&#x2F;STRONG 三种，默认为MEDIUM，即1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符；</p>\n<p>validate_password_special_char_count：密码至少要包含的特殊字符数，默认为1个；</p>\n</blockquote>\n</li>\n<li><p>修改密码策略</p>\n<p>先将密码策略修改为LOW</p>\n<blockquote>\n<p>set global validate_password_policy&#x3D;0;</p>\n</blockquote>\n<p>再将密码长度修改4位</p>\n<blockquote>\n<p> set global validate_password_length&#x3D;4;</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Linux安装Java\"><a href=\"#Linux安装Java\" class=\"headerlink\" title=\"Linux安装Java\"></a>Linux安装Java</h2><p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建java目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p>\n</blockquote>\n</li>\n<li><p>解压下载好的Java安装包</p>\n<blockquote>\n<p>tar -zxvf jdk-8u341-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p>vi &#x2F;etc&#x2F;profile</p>\n</blockquote>\n<blockquote>\n<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p>\n</blockquote>\n</li>\n<li><p>使环境变量生效</p>\n<blockquote>\n<p>source &#x2F;etc&#x2F;profile</p>\n</blockquote>\n</li>\n<li><p>添加软链接</p>\n<blockquote>\n<p>ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</p>\n</blockquote>\n</li>\n<li><p>查看Java版本</p>\n<blockquote>\n<p>java -version</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>二、卸载</strong></p>\n<ol>\n<li><p>查询java是否安装</p>\n<blockquote>\n<p><strong>rpm -qa |grep java</strong></p>\n</blockquote>\n</li>\n<li><p>VM中查询Java列表</p>\n<blockquote>\n<p>rpm -qa | grep java</p>\n</blockquote>\n</li>\n<li><p>卸载Java</p>\n<blockquote>\n<p>yum remove openjdk</p>\n</blockquote>\n</li>\n<li><p>其他卸载命令</p>\n<blockquote>\n<p>rpm -e rpm -qa|gerp java 卸载</p>\n<p>rpm -e rpm -qa|gerp java –nodeps 强制卸载</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux配置Tomcat\"><a href=\"#Linux配置Tomcat\" class=\"headerlink\" title=\"Linux配置Tomcat\"></a>Linux配置Tomcat</h2><p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;Tomcat</p>\n</blockquote>\n</li>\n<li><p>解压</p>\n<blockquote>\n<p>tar -zxvf Tomcat安装包</p>\n</blockquote>\n</li>\n<li><p>进入Tomcat的bin目录</p>\n<blockquote>\n<p>chmod 777 .&#x2F;*  给文件提高至最高权限</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p>vim &#x2F;etc&#x2F;profile </p>\n</blockquote>\n<blockquote>\n<p>#tomcat<br>export TOMCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-9.0.65</p>\n<p>export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-9.0.65</p>\n</blockquote>\n</li>\n<li><p>修改Tomcat启动分析脚本</p>\n<blockquote>\n<p>vim &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat&#x2F;bin&#x2F;setclasspath.sh</p>\n</blockquote>\n<blockquote>\n<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341</p>\n<p>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre</p>\n</blockquote>\n</li>\n<li><p>启动Tomcat</p>\n<blockquote>\n<p>进入Tomcat&#x2F;bin目录</p>\n<p>.&#x2F;startup.sh</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux配置Node\"><a href=\"#Linux配置Node\" class=\"headerlink\" title=\"Linux配置Node\"></a>Linux配置Node</h2><p>一、安装</p>\n<ol>\n<li><p>创建目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;node</p>\n</blockquote>\n</li>\n<li><p>解压Node安装包</p>\n<blockquote>\n<p><em>tar</em> -xvf node-v16.15.0-linux-x64.tar.xz</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p><em>sudo v</em>im &#x2F;etc&#x2F;profile</p>\n</blockquote>\n<blockquote>\n<p>export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;nodejs<br>export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</p>\n</blockquote>\n</li>\n<li><p>让环境变量生效</p>\n<blockquote>\n<p><em>source</em> &#x2F;etc&#x2F;profile</p>\n</blockquote>\n</li>\n<li><p>测试是否安装成功</p>\n<blockquote>\n<p>node -v</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux安装Notepadqq\"><a href=\"#Linux安装Notepadqq\" class=\"headerlink\" title=\"Linux安装Notepadqq\"></a>Linux安装Notepadqq</h2><p><strong>一、安装</strong></p>\n<blockquote>\n<p>sudo add-apt-repository ppa:notepadqq-team&#x2F;notepadqq </p>\n<p>sudo apt-get update </p>\n<p>sudo apt-get install notepadqq</p>\n</blockquote>\n<p><strong>二、卸载</strong></p>\n<blockquote>\n<p>sudo apt-get remove notepadqq </p>\n<p>sudo add-apt-repository –remove ppa:notepadqq-team&#x2F;notepadqq</p>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"Linux安装MySQL\"><a href=\"#Linux安装MySQL\" class=\"headerlink\" title=\"Linux安装MySQL\"></a>Linux安装MySQL</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/item/MySQL/471251?fr=aladdin\">MySQL</a>是一种<a href=\"https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020\">关系型数据库</a>管理系统，</p>\n</blockquote>\n<p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建一个文件夹</p>\n<blockquote>\n<p>mkdir &#x2F;soft&#x2F;mysql</p>\n<p>cd &#x2F;soft&#x2F;mysql</p>\n</blockquote>\n</li>\n<li><p>解压mysql安装包</p>\n<blockquote>\n<p>mkdir mysql-8.0.30</p>\n<p>tar -xvf mysql-8.0.30-1.el7…..tar -C mysql-8.0.30</p>\n</blockquote>\n</li>\n<li><p>rpm安装</p>\n<blockquote>\n<p>切换到解压的mysql目录下，这些文件都是rpm安装包，需要下载openssl-devel插件</p>\n<p>yum install openssl-devel</p>\n</blockquote>\n</li>\n<li><p>安装rpm包</p>\n<blockquote>\n<p>注意：一定要按照顺序</p>\n<p>rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </p>\n<p>rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </p>\n<p>rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</p>\n<p>rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</p>\n</blockquote>\n<blockquote>\n<p>注意：在 Linux 中 MySQL 安装好了之后系统会自动的注册一个服务，服务名称叫做mysqld，所以可以通过以下命令操作 MySQL：</p>\n<p>启动 MySQL 服务：systemctl start mysqld</p>\n<p>重启 MySQL 服务：systemctl restart mysqld</p>\n<p>关闭 MySQL 服务：systemctl stop mysqld</p>\n</blockquote>\n</li>\n<li><p>启动mysql服务 </p>\n<blockquote>\n<p>systemctl start mysqld</p>\n</blockquote>\n</li>\n<li><p>查看随机密码</p>\n<blockquote>\n<p>cat &#x2F;var&#x2F;log&#x2F;mysqld.log</p>\n</blockquote>\n</li>\n<li><p>链接数据库</p>\n<blockquote>\n<p>mysql -u root -p</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>二、卸载</strong></p>\n<ol>\n<li><p>停止mysql服务</p>\n<blockquote>\n<p>systemctl stop mysqld</p>\n</blockquote>\n</li>\n<li><p>查询Mysql的安装文件</p>\n<blockquote>\n<p>rpm -qa | grep -i mysql</p>\n</blockquote>\n</li>\n<li><p>跟据上述查询结果一条一条卸载所有Mysql安装包</p>\n<blockquote>\n<p>rpm -e 文件名 –nodeps</p>\n</blockquote>\n</li>\n<li><p>删除MySQL的数据存放目录</p>\n<blockquote>\n<p> rm -rf &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</p>\n</blockquote>\n</li>\n<li><p>删除MySQL的配置文件备份</p>\n<blockquote>\n<p>rm -rf &#x2F;etc&#x2F;my.cnf.rpmsave</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>三、常用设置</strong></p>\n<ol>\n<li><p>修改用户名密码</p>\n<blockquote>\n<p>ALTER  USER  ‘root‘@’localhost’  IDENTIFIED BY ‘你的密码’</p>\n</blockquote>\n</li>\n<li><p>创建用户与权限分配</p>\n<p>默认的 root 用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个新的账户，用于远程访问</p>\n<blockquote>\n<p>create user ‘用户名称‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘密码’;</p>\n</blockquote>\n<blockquote>\n<p>创建完用户分配所有权限</p>\n<p>grant all on <em>.</em> to ‘mike‘@’%’;</p>\n</blockquote>\n</li>\n<li><p>密码策略修改</p>\n<ol>\n<li><p>查询Mysql所有的密码相关策略</p>\n<blockquote>\n<p>show variables like ‘validate_password%’;</p>\n</blockquote>\n</li>\n<li><p>变量名说明</p>\n<blockquote>\n<p>变量名说明：</p>\n<p>validate_password_check_user_name：关闭用户名验证，OFF&#x2F;ON：关闭&#x2F;开启，默认为OFF，即关闭；</p>\n<p>validate_password_dictionary_file：用于验证密码强度的字典文件路径；</p>\n<p>validate_password_length：密码最小长度，参数默认为8，它有最小值的限制，最小值为的计算方法为validate_password_number_count+validate_password_special_char_count +(2*validate_password_mixed_case_count) ，这就是为什么很多人搞不懂明明设置了长度为1，但是最后还是为4个的长度，所以这儿要注意；</p>\n<p>validate_password_mixed_case_count：密码至少要包含的小写字母个数和大写字母个数，默认为1个；</p>\n<p>validate_password_number_count：密码至少要包含的数字个数，默认为1个；</p>\n<p>validate_password_policy：密码强度检查等级，等级总共为：0&#x2F;LOW、1&#x2F;MEDIUM、2&#x2F;STRONG 三种，默认为MEDIUM，即1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符；</p>\n<p>validate_password_special_char_count：密码至少要包含的特殊字符数，默认为1个；</p>\n</blockquote>\n</li>\n<li><p>修改密码策略</p>\n<p>先将密码策略修改为LOW</p>\n<blockquote>\n<p>set global validate_password_policy&#x3D;0;</p>\n</blockquote>\n<p>再将密码长度修改4位</p>\n<blockquote>\n<p> set global validate_password_length&#x3D;4;</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Linux安装Java\"><a href=\"#Linux安装Java\" class=\"headerlink\" title=\"Linux安装Java\"></a>Linux安装Java</h2><p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建java目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p>\n</blockquote>\n</li>\n<li><p>解压下载好的Java安装包</p>\n<blockquote>\n<p>tar -zxvf jdk-8u341-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p>vi &#x2F;etc&#x2F;profile</p>\n</blockquote>\n<blockquote>\n<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p>\n</blockquote>\n</li>\n<li><p>使环境变量生效</p>\n<blockquote>\n<p>source &#x2F;etc&#x2F;profile</p>\n</blockquote>\n</li>\n<li><p>添加软链接</p>\n<blockquote>\n<p>ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</p>\n</blockquote>\n</li>\n<li><p>查看Java版本</p>\n<blockquote>\n<p>java -version</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>二、卸载</strong></p>\n<ol>\n<li><p>查询java是否安装</p>\n<blockquote>\n<p><strong>rpm -qa |grep java</strong></p>\n</blockquote>\n</li>\n<li><p>VM中查询Java列表</p>\n<blockquote>\n<p>rpm -qa | grep java</p>\n</blockquote>\n</li>\n<li><p>卸载Java</p>\n<blockquote>\n<p>yum remove openjdk</p>\n</blockquote>\n</li>\n<li><p>其他卸载命令</p>\n<blockquote>\n<p>rpm -e rpm -qa|gerp java 卸载</p>\n<p>rpm -e rpm -qa|gerp java –nodeps 强制卸载</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux配置Tomcat\"><a href=\"#Linux配置Tomcat\" class=\"headerlink\" title=\"Linux配置Tomcat\"></a>Linux配置Tomcat</h2><p><strong>一、安装</strong></p>\n<ol>\n<li><p>创建目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;Tomcat</p>\n</blockquote>\n</li>\n<li><p>解压</p>\n<blockquote>\n<p>tar -zxvf Tomcat安装包</p>\n</blockquote>\n</li>\n<li><p>进入Tomcat的bin目录</p>\n<blockquote>\n<p>chmod 777 .&#x2F;*  给文件提高至最高权限</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p>vim &#x2F;etc&#x2F;profile </p>\n</blockquote>\n<blockquote>\n<p>#tomcat<br>export TOMCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-9.0.65</p>\n<p>export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-9.0.65</p>\n</blockquote>\n</li>\n<li><p>修改Tomcat启动分析脚本</p>\n<blockquote>\n<p>vim &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat&#x2F;bin&#x2F;setclasspath.sh</p>\n</blockquote>\n<blockquote>\n<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_341</p>\n<p>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre</p>\n</blockquote>\n</li>\n<li><p>启动Tomcat</p>\n<blockquote>\n<p>进入Tomcat&#x2F;bin目录</p>\n<p>.&#x2F;startup.sh</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux配置Node\"><a href=\"#Linux配置Node\" class=\"headerlink\" title=\"Linux配置Node\"></a>Linux配置Node</h2><p>一、安装</p>\n<ol>\n<li><p>创建目录</p>\n<blockquote>\n<p>mkdir &#x2F;usr&#x2F;local&#x2F;node</p>\n</blockquote>\n</li>\n<li><p>解压Node安装包</p>\n<blockquote>\n<p><em>tar</em> -xvf node-v16.15.0-linux-x64.tar.xz</p>\n</blockquote>\n</li>\n<li><p>配置环境变量</p>\n<blockquote>\n<p><em>sudo v</em>im &#x2F;etc&#x2F;profile</p>\n</blockquote>\n<blockquote>\n<p>export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;nodejs<br>export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</p>\n</blockquote>\n</li>\n<li><p>让环境变量生效</p>\n<blockquote>\n<p><em>source</em> &#x2F;etc&#x2F;profile</p>\n</blockquote>\n</li>\n<li><p>测试是否安装成功</p>\n<blockquote>\n<p>node -v</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Linux安装Notepadqq\"><a href=\"#Linux安装Notepadqq\" class=\"headerlink\" title=\"Linux安装Notepadqq\"></a>Linux安装Notepadqq</h2><p><strong>一、安装</strong></p>\n<blockquote>\n<p>sudo add-apt-repository ppa:notepadqq-team&#x2F;notepadqq </p>\n<p>sudo apt-get update </p>\n<p>sudo apt-get install notepadqq</p>\n</blockquote>\n<p><strong>二、卸载</strong></p>\n<blockquote>\n<p>sudo apt-get remove notepadqq </p>\n<p>sudo add-apt-repository –remove ppa:notepadqq-team&#x2F;notepadqq</p>\n</blockquote>\n"},{"title":"JavaScript","date":"2022-08-28T03:18:57.000Z","cover":"/img/images/computer3.jpg","_content":"\n## JavaScript\n\n### 一、JavaScript概念\n\n##### 简称js，一款运行于浏览器端的弱类型解释性脚本语言\n\n强类型：定义变量时必须要指定明确的类型\n\n弱类型：定义变量时不需要指定明确的类型，变量的类型由他所存储的值来推测\n\n编译性：先需要对代码进行编译，通过之后才能解释运行，安全但是效率低\n\n解释性：不需要编译，直接由解释器逐行解释运行，出错为止，效率高但是不安全\n\n脚本：一种可以执行的文本文件，并且可以嵌入到别的语言种中进行执行，js必须要嵌入到html语言中才能执行\n\n### 二、JavaScript主要用途\n\n#### 1.浏览器页面的动态效果制作\n\n#### 2.与java后端服务器进行数据交互\n\n1. 将用户再前端页面填写的数据发送给后端服务器（ajax+json）\n2. 接收后端服务器返回的数据，再将数据渲染到页面\n3. 浏览器数据计算和校验\n\n### 三、JavaScript主要组成部分\n\n1. ECMAScript\n\n   JavaScript编程语言核心语法部分\n\n   1. 变量\n\n      1. 变量的定义\n\n         js中变量由var，let，const三种不同的关键字定义\n\n         var：函数作用域\n\n         let：块级作用域\n\n         const：常量，必须要在定义时赋值，不可更改0\n\n      2. \n\n   2. 数据类型\n\n   3. 运算符\n\n   4. 流程控制\n\n   5. 数组\n\n   6. 函数\n\n   7. 面向对象\n\n   8. API\n\n2. Dom\n\n3. Bom\n\n### 四、JavaScript基本用法\n\n1. 在html页面中定义一对Script标签，在标签页面\n\n   ```html\n   <script>\n   在这里面写js代码    \n   </script>\n   ```\n\n   \n\n2. 注意\n\n   1. html页面任意微信hi都可以定义Sript标签，但是为了避免页面卡顿一般建议将其写在body结束标签之前\n   2. Script标签可以定义多个\n\n3. 在外部单独定义一个js文件，在文件中写js代码。然后再html页面中引入\n\n4. 输入出方式\n\n   1. 输出到控制台\n\n      console.log（）\n\n   2. 输出到浏览器页面\n\n      document.write（）\n\n   3. 三种对话框\n\n      1. 警告对话框\n\n         alert（）\n\n      2. 确认对话框\n\n         confirm（）\n\n      3. 输入对话框\n\n         prompt（）","source":"_posts/JavaScript.md","raw":"---\ntitle: JavaScript\ndate: 2022-08-28 11:18:57\ntags: 前端\ncategories: 前端\ncover: /img/images/computer3.jpg \n---\n\n## JavaScript\n\n### 一、JavaScript概念\n\n##### 简称js，一款运行于浏览器端的弱类型解释性脚本语言\n\n强类型：定义变量时必须要指定明确的类型\n\n弱类型：定义变量时不需要指定明确的类型，变量的类型由他所存储的值来推测\n\n编译性：先需要对代码进行编译，通过之后才能解释运行，安全但是效率低\n\n解释性：不需要编译，直接由解释器逐行解释运行，出错为止，效率高但是不安全\n\n脚本：一种可以执行的文本文件，并且可以嵌入到别的语言种中进行执行，js必须要嵌入到html语言中才能执行\n\n### 二、JavaScript主要用途\n\n#### 1.浏览器页面的动态效果制作\n\n#### 2.与java后端服务器进行数据交互\n\n1. 将用户再前端页面填写的数据发送给后端服务器（ajax+json）\n2. 接收后端服务器返回的数据，再将数据渲染到页面\n3. 浏览器数据计算和校验\n\n### 三、JavaScript主要组成部分\n\n1. ECMAScript\n\n   JavaScript编程语言核心语法部分\n\n   1. 变量\n\n      1. 变量的定义\n\n         js中变量由var，let，const三种不同的关键字定义\n\n         var：函数作用域\n\n         let：块级作用域\n\n         const：常量，必须要在定义时赋值，不可更改0\n\n      2. \n\n   2. 数据类型\n\n   3. 运算符\n\n   4. 流程控制\n\n   5. 数组\n\n   6. 函数\n\n   7. 面向对象\n\n   8. API\n\n2. Dom\n\n3. Bom\n\n### 四、JavaScript基本用法\n\n1. 在html页面中定义一对Script标签，在标签页面\n\n   ```html\n   <script>\n   在这里面写js代码    \n   </script>\n   ```\n\n   \n\n2. 注意\n\n   1. html页面任意微信hi都可以定义Sript标签，但是为了避免页面卡顿一般建议将其写在body结束标签之前\n   2. Script标签可以定义多个\n\n3. 在外部单独定义一个js文件，在文件中写js代码。然后再html页面中引入\n\n4. 输入出方式\n\n   1. 输出到控制台\n\n      console.log（）\n\n   2. 输出到浏览器页面\n\n      document.write（）\n\n   3. 三种对话框\n\n      1. 警告对话框\n\n         alert（）\n\n      2. 确认对话框\n\n         confirm（）\n\n      3. 输入对话框\n\n         prompt（）","slug":"JavaScript","published":1,"updated":"2023-08-10T09:49:46.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9d000kfswo916jghuk","content":"<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h3 id=\"一、JavaScript概念\"><a href=\"#一、JavaScript概念\" class=\"headerlink\" title=\"一、JavaScript概念\"></a>一、JavaScript概念</h3><h5 id=\"简称js，一款运行于浏览器端的弱类型解释性脚本语言\"><a href=\"#简称js，一款运行于浏览器端的弱类型解释性脚本语言\" class=\"headerlink\" title=\"简称js，一款运行于浏览器端的弱类型解释性脚本语言\"></a>简称js，一款运行于浏览器端的弱类型解释性脚本语言</h5><p>强类型：定义变量时必须要指定明确的类型</p>\n<p>弱类型：定义变量时不需要指定明确的类型，变量的类型由他所存储的值来推测</p>\n<p>编译性：先需要对代码进行编译，通过之后才能解释运行，安全但是效率低</p>\n<p>解释性：不需要编译，直接由解释器逐行解释运行，出错为止，效率高但是不安全</p>\n<p>脚本：一种可以执行的文本文件，并且可以嵌入到别的语言种中进行执行，js必须要嵌入到html语言中才能执行</p>\n<h3 id=\"二、JavaScript主要用途\"><a href=\"#二、JavaScript主要用途\" class=\"headerlink\" title=\"二、JavaScript主要用途\"></a>二、JavaScript主要用途</h3><h4 id=\"1-浏览器页面的动态效果制作\"><a href=\"#1-浏览器页面的动态效果制作\" class=\"headerlink\" title=\"1.浏览器页面的动态效果制作\"></a>1.浏览器页面的动态效果制作</h4><h4 id=\"2-与java后端服务器进行数据交互\"><a href=\"#2-与java后端服务器进行数据交互\" class=\"headerlink\" title=\"2.与java后端服务器进行数据交互\"></a>2.与java后端服务器进行数据交互</h4><ol>\n<li>将用户再前端页面填写的数据发送给后端服务器（ajax+json）</li>\n<li>接收后端服务器返回的数据，再将数据渲染到页面</li>\n<li>浏览器数据计算和校验</li>\n</ol>\n<h3 id=\"三、JavaScript主要组成部分\"><a href=\"#三、JavaScript主要组成部分\" class=\"headerlink\" title=\"三、JavaScript主要组成部分\"></a>三、JavaScript主要组成部分</h3><ol>\n<li><p>ECMAScript</p>\n<p>JavaScript编程语言核心语法部分</p>\n<ol>\n<li><p>变量</p>\n<ol>\n<li><p>变量的定义</p>\n<p>js中变量由var，let，const三种不同的关键字定义</p>\n<p>var：函数作用域</p>\n<p>let：块级作用域</p>\n<p>const：常量，必须要在定义时赋值，不可更改0</p>\n</li>\n<li></li>\n</ol>\n</li>\n<li><p>数据类型</p>\n</li>\n<li><p>运算符</p>\n</li>\n<li><p>流程控制</p>\n</li>\n<li><p>数组</p>\n</li>\n<li><p>函数</p>\n</li>\n<li><p>面向对象</p>\n</li>\n<li><p>API</p>\n</li>\n</ol>\n</li>\n<li><p>Dom</p>\n</li>\n<li><p>Bom</p>\n</li>\n</ol>\n<h3 id=\"四、JavaScript基本用法\"><a href=\"#四、JavaScript基本用法\" class=\"headerlink\" title=\"四、JavaScript基本用法\"></a>四、JavaScript基本用法</h3><ol>\n<li><p>在html页面中定义一对Script标签，在标签页面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">在这里面写js代码    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>注意</p>\n<ol>\n<li>html页面任意微信hi都可以定义Sript标签，但是为了避免页面卡顿一般建议将其写在body结束标签之前</li>\n<li>Script标签可以定义多个</li>\n</ol>\n</li>\n<li><p>在外部单独定义一个js文件，在文件中写js代码。然后再html页面中引入</p>\n</li>\n<li><p>输入出方式</p>\n<ol>\n<li><p>输出到控制台</p>\n<p>console.log（）</p>\n</li>\n<li><p>输出到浏览器页面</p>\n<p>document.write（）</p>\n</li>\n<li><p>三种对话框</p>\n<ol>\n<li><p>警告对话框</p>\n<p>alert（）</p>\n</li>\n<li><p>确认对话框</p>\n<p>confirm（）</p>\n</li>\n<li><p>输入对话框</p>\n<p>prompt（）</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h3 id=\"一、JavaScript概念\"><a href=\"#一、JavaScript概念\" class=\"headerlink\" title=\"一、JavaScript概念\"></a>一、JavaScript概念</h3><h5 id=\"简称js，一款运行于浏览器端的弱类型解释性脚本语言\"><a href=\"#简称js，一款运行于浏览器端的弱类型解释性脚本语言\" class=\"headerlink\" title=\"简称js，一款运行于浏览器端的弱类型解释性脚本语言\"></a>简称js，一款运行于浏览器端的弱类型解释性脚本语言</h5><p>强类型：定义变量时必须要指定明确的类型</p>\n<p>弱类型：定义变量时不需要指定明确的类型，变量的类型由他所存储的值来推测</p>\n<p>编译性：先需要对代码进行编译，通过之后才能解释运行，安全但是效率低</p>\n<p>解释性：不需要编译，直接由解释器逐行解释运行，出错为止，效率高但是不安全</p>\n<p>脚本：一种可以执行的文本文件，并且可以嵌入到别的语言种中进行执行，js必须要嵌入到html语言中才能执行</p>\n<h3 id=\"二、JavaScript主要用途\"><a href=\"#二、JavaScript主要用途\" class=\"headerlink\" title=\"二、JavaScript主要用途\"></a>二、JavaScript主要用途</h3><h4 id=\"1-浏览器页面的动态效果制作\"><a href=\"#1-浏览器页面的动态效果制作\" class=\"headerlink\" title=\"1.浏览器页面的动态效果制作\"></a>1.浏览器页面的动态效果制作</h4><h4 id=\"2-与java后端服务器进行数据交互\"><a href=\"#2-与java后端服务器进行数据交互\" class=\"headerlink\" title=\"2.与java后端服务器进行数据交互\"></a>2.与java后端服务器进行数据交互</h4><ol>\n<li>将用户再前端页面填写的数据发送给后端服务器（ajax+json）</li>\n<li>接收后端服务器返回的数据，再将数据渲染到页面</li>\n<li>浏览器数据计算和校验</li>\n</ol>\n<h3 id=\"三、JavaScript主要组成部分\"><a href=\"#三、JavaScript主要组成部分\" class=\"headerlink\" title=\"三、JavaScript主要组成部分\"></a>三、JavaScript主要组成部分</h3><ol>\n<li><p>ECMAScript</p>\n<p>JavaScript编程语言核心语法部分</p>\n<ol>\n<li><p>变量</p>\n<ol>\n<li><p>变量的定义</p>\n<p>js中变量由var，let，const三种不同的关键字定义</p>\n<p>var：函数作用域</p>\n<p>let：块级作用域</p>\n<p>const：常量，必须要在定义时赋值，不可更改0</p>\n</li>\n<li></li>\n</ol>\n</li>\n<li><p>数据类型</p>\n</li>\n<li><p>运算符</p>\n</li>\n<li><p>流程控制</p>\n</li>\n<li><p>数组</p>\n</li>\n<li><p>函数</p>\n</li>\n<li><p>面向对象</p>\n</li>\n<li><p>API</p>\n</li>\n</ol>\n</li>\n<li><p>Dom</p>\n</li>\n<li><p>Bom</p>\n</li>\n</ol>\n<h3 id=\"四、JavaScript基本用法\"><a href=\"#四、JavaScript基本用法\" class=\"headerlink\" title=\"四、JavaScript基本用法\"></a>四、JavaScript基本用法</h3><ol>\n<li><p>在html页面中定义一对Script标签，在标签页面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">在这里面写js代码    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>注意</p>\n<ol>\n<li>html页面任意微信hi都可以定义Sript标签，但是为了避免页面卡顿一般建议将其写在body结束标签之前</li>\n<li>Script标签可以定义多个</li>\n</ol>\n</li>\n<li><p>在外部单独定义一个js文件，在文件中写js代码。然后再html页面中引入</p>\n</li>\n<li><p>输入出方式</p>\n<ol>\n<li><p>输出到控制台</p>\n<p>console.log（）</p>\n</li>\n<li><p>输出到浏览器页面</p>\n<p>document.write（）</p>\n</li>\n<li><p>三种对话框</p>\n<ol>\n<li><p>警告对话框</p>\n<p>alert（）</p>\n</li>\n<li><p>确认对话框</p>\n<p>confirm（）</p>\n</li>\n<li><p>输入对话框</p>\n<p>prompt（）</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"MySQL","date":"2023-02-25T03:18:57.000Z","cover":"/img/images/MySQL.jpg","_content":"\n### 一、数据库概念\n\nDataBase：以表的数据结构形式来对程序产生的数据进行结构化存储和管理的数据仓库\n\nDBMS：DataBase Manager Service\n\n数据库管理系统\n\n1. 数据库服务器\n\n   负责永久性存储管理以及维护数据\n\n   在一个MySQL数据库服务器中可以存在多个数据库，互相之间名称不能重复\n\n2. 数据库客户端\n\n   通过ip和端口号链接上数据库服务器，通过账号密码进行登录，登录成功后就可以向数据库服务器发送sql指令来操作数据库服务器端的数据，并呈现操作结果\n\n   客户端：\n\n   1. cmd命令行\n   2. 图形界面（navicat...）\n   3. Java代码(JDBC,mybatis...)\n\n### 二、数据库分类\n\n1、**关系型数据库**\n\n使用一张二维表来存储数据，表中列与列之间有关系，同一个库中表和表之间也可以存在关系\n\n1. Oracle\n\n   甲骨文公司产品，第一款大型关系型数据库\n\n   个人免费，公司收费\n\n2. DB2\n\n   IBM公司大型关系型数据库\n\n   跨平台性好\n\n3. SqlServer\n\n   微软公司大型关系型数据库\n\n   对windows平台支持比较好\n\n4. MySQL\n\n   小型关系型数据库\n\n   免费开源(非核心代码)\n\n5. sqlite\n\n   小型关系型数据库，主要应用于移动设备上，可以用于存储联系人，短信，图片等信息\n\n2、**非关系型数据库**\n\n主要是以key-value键值对的形式来对数据进行存储，元素和元素之间没有关系，主要用于充当缓存\n\n1. redis\n2. memcached\n3. mongodb\n\n### 三、数据库基本命令\n\n1. status\n\n   显示当前数据库系统的相关信息\n\n2. show databases;\n\n   查看当前数据库系统中有那些库\n\n3. use 库名\n\n   打开/切换到某一个库中\n\n4. show tables;\n\n   查看当前库下有那些表\n\n5. select database()\n\n   查看当前正在操作的库\n\n6. select user()\n\n   查看当前登录用户\n\n7. select now()\n\n   查询当前系统的日期时间\n\n8. select XXX(now())\n\n   查询当前日期时间的指定字段\n\n   XXX:date/time/year/month/day/hour/minute/week/second\n\n### 四、SQL语句\n\nStructured Query Language(结构化查询语言)\n\n通过数据库客户端向服务器发送指令来执行建库删库，建表删表以及对表中数据执行增删查改等操作\n\nsql语句是一门国际化标准语言，各大数据库厂商都会遵循相同的sql标准\n\n特点：关键字不区分大小写，表中数据区分大小写\n\nSQL语句分类;\n\n1. DDL(数据定义语言)\n\n   主要用于对数据库和表的创建删除，以及对表结构的修改\n\n   1. alter  \t更新(数据库，表，表结构)\n   2. create     创建(数据库，表)\n   3. drop       删除(数据库，表，表中列)\n   4. trunate    表截断(表)\n\n2. DML(数据操作语言)\n\n   主要用于对表中数据执行插入，删除，修改操作\n\n   1. insert   插入\n   2. delete   删除(删除表中一行数据)\n   3. update   修改\n\n3. DQL(数据查询语言)\n\n   主要用于从表中查询数据\n\n   1. select\t查询\n\n4. TCL(事务控制语言)\n\n   主要用于控制多个人操作数据库\n\n   1. set transaction   设置事务\n   2. commit            提交事务\n   3. rollback          回滚事务\n   4. savepoint         设置回滚点\n\n5. DCL(数据控制语言)\n\n   主要用于设置用户的访问权限\n\n   1. create user\t创建用户\n   2. grant          授权\n   3. revoke         撤销权限\n\n### 五、DDL数据定义语言\n\n1. DataBase数据库的创建与删除\n\n   先显示当前数据库系统有那些库(库名不能重复)\n\n   > show databases；\n\n   创建一个数据库，并设置编码方式\n\n   > create database 库名 default character set utf8；\n   >\n   > create database 库名 charset=utf8；\n   >\n   > 注意：可以在库名前面添加if not exists判断库是否存在。存在就不创建\n\n   删除一个数据库\n\n   > drop database 库名；\n\n   打开/切换到某一个库\n\n   > use 库名；\n\n   查看当前正在工作的数据库\n\n   > select database();\n\n   查看数据库的创建过程\n\n   > show create database 库名；\n\n2. Table表格的创建与删除\n\n   表格是关系型数据库中存储数据的最基本单元，表格由行row和列colum组成，其中表头也叫做字段Filed，表中的每一行叫做记录Record\n\n   打开数据库\n\n   > use 库名\n\n   显示当前库下表名不能重复\n\n   > show tables;\n\n   创建一个表\n\n   > mysql>create table 表名(\n   >\n   > ​    ->字段名 字段类型(类型大小)\n   >\n   > );\n\n   > 约束Constraint\n   >\n   > 注意：\n   >\n   > ​\tprimary key\t\t主键\n   >\n   > ​\tauto_increment\t 自增\n   >\n   > ​\tcomment\t\t\t注释\n   >\n   > ​\tnot null\t\t   不能为空\n   >\n   > ​\tdefault \t\t   默认值\n   >\n   > ​\tunique\t\t\t 唯一的\n   >\n   > ​\tforeign key        外键\n\n   删除表\n\n   > drop table 表名；\n\n   查看表结构\n\n   > desc 表名；\n\n   查看表的创建过程\n\n   >  show create table 表名；\n\n   列添加\n\n   > alter table 表名 add 列名 类型；\n\n   在某一列后添加一列\n\n   > alter table 表名 add 列名 类型 after 插入在谁后面的列名；\n\n   在最前面插入列\n\n   > alter table 表名 add 列名 类型 first;\n\n   列名的修改\n\n   > alter table 表名 change 旧列名 新列名 类型；\n\n   列属性修改\n\n   > alter table 表名 modify 列名 类型；\n   >\n   > 注意：长度由大改小可能会失败\n\n   删除列\n\n   > alter table 表名 drop 列名；\n\n   表名修改\n\n   > alter table 表名 rename to 新表名；\n\n   表截断(不能回滚)\n\n   > truncate table 表名\n\n3. 表中字段的常用数据类型\n\n   1. 数值类型\n\n      1. 整数类型\n\n         1. tinyint\t 1个字节\n         2. smallint    2个字节\n         3. mediumint   3个字节\n         4. int/integer 4个字节\n         5. bigint      8个字节\n\n      2. 浮点类型\n\n         1. float       4个字节\n      \n         2. double      8个字节\n\n         3. decimal(m,d)精确位数，公共m位，精确到小数点后d位\n      \n   2. 字符类型\n      数据库中不区分字符和字符串，字符类型必须使用单引号或者双引号引起来\n      \n      1. char(定长字符类型)不足的会以空格补齐，最多255个字符\n      2. varchar(可变长度字符类型)由多少字符就占多少位置，最多65535字符\n      \n      char和varchar的区别：\n      \n      > 1. char是定长字符串，查询速度快，但是可能浪费空间，一般列下面的数值长度为定长时使用\n      >\n      > 2. varchar是变长字符串，可以节约空间，但是查询速度慢，一般列下面数值长度不固定时使用\n     \n   3. 日期时间类型\n      \n      在MySQL数据库中日期时间类型都是以特定字符串格式来进行存储的\n      \n      1. date\n      \n         日期类型，以“yyyy-MM-dd”字符串格式来进行存储\n      \n      2. time\n      \n         时间类型，以“HH:mm:ss”字符串格式来进行存储\n      \n      3. datetime\n      \n         日期时间类型，以“yyyy-MM-dd HH:mm:sss\"字符串格式来存储\n      \n      4. year\n      \n         年份类型，以”yyyy“字符串格式来进行存储\n      \n      5. timestamp\n      \n         时间戳类型，以int整数值格式来进行存储\n      \n   3. 布尔类型\n      \n         boolean/bool\n      \n         只能存储true/false两种值，在MySQL底层会自动将boolean类型转成tinyint类型，其他true转为1，false转为0\n      \n   4. 不常用类型\n      \n         > 注意：text文本类型和blob二进制类型不建议使用，实际业务中是将数据存储到文件中，然后再将文件的地址存储到数据库中\n      \n         1. 文本类型\n         \n            主要用于存储大数据量的文本\n         \n            1. tinytext\n            2. mediumtext\n            3. text\n            4. longtext\n         \n         2. blob(二进制类型)\n         \n            主要用于存储二进制文件\n         \n            图片、视频、音频...\n         \n            1. tinyblob\n            2. mediumblob\n            3. blob\n            4. longblob\n\n### 六、DML数据操纵语言\n\n主要用于对表中数据执行增删改操作\n\n1. insert(插入)\n\n   > 1. 向所有列下面插入数据(有几列就给几个值)\n   >\n   >    insert into 表名 values(值1，值2，值3...)；\n   >\n   > 2. 向部分列下面插入数据(列个数与值个数相等)\n   >\n   >    insert into 表名(列1，列2，列3...) values(值1，值2，值3...)\n   >\n   >    非空列，如果没有默认值，要主动插入数据\n   >\n   > 3. 同时插入多条数据\n   >\n   >    insert into 表名(列1，列2，列3...) \n   >\n   >    values(值1，值2，值3...)，(值1，值2，值3...)，(值1，值2，值3...)...\n\n2. update(修改)\n\n   > 1. 修改列下面所有的记录(危险操作)\n   >\n   >    update 表名 set 列名1=值1，列名2=值2...；\n   >\n   > 2. 根据条件修改列下面的值\n   >\n   >    update 表名 set 列名 = 值 where 条件；\n   >\n   > 3. 根据多条件修改下面的值\n   >\n   >    update 表名 set 列名=值... where 条件1，条件2；\n   >\n   > 4. 条件值为null时\n   >\n   >    update 表名 set 列名=值... where 条件名 is null；\n   >\n   > 5. 条件的值不为null时\n   >\n   >    update 表名 set 列名=值... where 条件 is not null；\n\n1. delete(删除)\n\n   > 1. 全表删除(禁用)\n   >\n   >    delete from 表名；\n   >\n   > 2. 根据条件删除一条记录\n   >\n   >    delte from 表名 where 条件；\n\n### 七、DQL数据查询语言\n\n主要用于从表中查询数据回来\n\n导入sql文件\n\n> msyql> source XXX.sql\n\n导出sql文件\n\n> mysqldump -u用户名-p密码 数据库名 > 导出地址\\数据库名.sql\n\n1. 基本查询\n\n   1. 全表查询\n\n      > select * from 表名；\n\n   2. 查询指定数据\n\n      > select 列名1 列名2 ...from 表名；\n\n   3. 对查询出来的列指定列别名\n\n      > select 列名1 as 别名1，列名2 as 别名2 form 表名；\n\n   4. 去除列下面重复的数据\n\n      > select distinct 列名 from 表名；\n      >\n      > select distinct 列名1，列名2 from 表名；\n\n2. 限制查询\n\n   限制查询执行过程：\n\n   执行from 表名-> 执行where 查询限制条件(从上到下做逐行匹配)->返回true，留下该行记录，返回false过滤改行记录->执行select 列名1，列名2...从留下的行记录中确定显示的列\n\n   查询比较条件：\n\n   ​\t=\t>\t<\t>=\t<=\t!=\t<>\tis null\tis not null\n\n   1. 根据条件查询指定列名\n\n      > select 列名，列名2... from 表名 where 条件；\n\n   2. 查询某年的数据大小比较\n\n      > select 列名1,列名2... from 表名 where 列名 < 'yyyy-MM-dd';\n      >\n      > select 列名1,列名2... from 表名 where year(列名) < yyyy;\n\n   3. 查询不是某个部门的\n\n      > select * from 表名 where 列名 <> ‘值’；\n\n   4. and 和 or(and优先级比or高，小括号提升优先级)\n\n      > and:等于&&，查询出来的结果必须同时满足多个条件\n      >\n      > or：等于||，查询出来的结果满足其中一个即可\n\n   5. any 和all\n\n      > any：查询的结果值只要满足其中任意一个条件即可\n      >\n      > all：查询的结果值需要同时满足多个条件\n      >\n      > 一般配合 > >= < <= 来进行使用\n      >\n      > select * from 表名 where 查询列 > any(值1，值2...);大于最小值\n      >\n      > select * from 表名 where 查询列 < any(值1，值2...);小于最大值\n      >\n      > select * from 表名 where 查询列 > all(值1，值2...);大于最大值\n      >\n      > select * from 表名 where 查询列 < all(值1，值2...);小于最小值\n\n   5. 值范围查询\n\n      > select * from 表名 where 查询列 between 值1 and 值2；\n      >\n      > select * from 表名 where 查询列>= 值1 and 查询列<= 值2；\n      >\n      > 不在值1和值2范围内\n      >\n      > select * from 表名 where 查询列 not between 值1 and 值2；\n      >\n      > select * from 表名 where 查询列<值1 or 查询列>值2；\n\n   6. 值列表查询\n\n      判断查询列下面的数据是否在值列表的范围之内，等价于查询列=值1 or 查询了=值2\n\n      > select * from 表名 where 查询列 in(值1，值2...)\n\n      判断查询列下面的数据是否在值列表的范围之内等价于查询列!=值1 or 查询了!=值2\n\n      > select * from 表名 where 查询列 not in(值1，值2...)\n\n      > 注意：in和 not in 不能匹配null值，需要使用is null 和is not null\n      \n   8. 查询列上使用表达式或函数\n\n      > 表达式：\n      >\n      > ​\tselect * from 表名 where 表达式(列名+-*/值) > 值；\n      >\n      > ​\tselect *,新增列 from 表名 where 表达式(列名+-\\*/值) > 值;\n\n   9. 查询是否包含某个字符\n\n      > select * from 表名 where 列名 regexp '字符'；\n      >\n      > select * from 表名 where 列名 rlike '字符'；\n\n   10. 查询某个列的值为null\n\n      > select * from 表名 where 列名 <=> null;\n\n3. 函数\n\n   1. 系统函数\n      1. BIN(X) \t \t将X转换为二进制\n      2. BINARY(S)       将字符串s转为二进制字符串\n      3. CAST(X AS type) 转换数据类型\n      4. USER()          返回当前用户\n      5. VERSION()       返回数据库的版本号\n      6. IFNULL(v1,v2)   v1的值为null，返回v1，否则返回v2\n      7. LAST_INSERT_ID()返回插入的最后一条记录的自增长id\n      8. JSON_OBJECT()   将键值对转换为JSON对象\n      9. JSON_ARRAY()    将值转换为JSON数组\n\n   2. 字符串函数\n\n      1. 以字段值:字段值2:字段值3格式显示所有信息\n\n         > select concat(列名1，':',列名2，':',....)from 表名；\n         >\n         > select concat_ws(':'，列名1,列名2....)from 表名；\n\n      2. 左侧补齐/右侧补齐\n\n         > select lpad(列名，长度，'填补字符') from 表名；\n         >\n         > select rpad(列名，长度，'填补字符') from 表名；\n\n   3. 日期函数\n\n      1. 查询一个时间段到多少天后的时间\n\n         > select adddate(起始日期，多少天)；\n         >\n         > select adddate(起始日期，INTERVAl 10 MONTH)；\n\n      2. 计算两个日期直接的时间\n\n         > select datediff(结束日期，起始日期)；\n\n   4. 数值函数\n\n      1. 查询数值四舍五入保留小数点后X位\n\n         > select 列名，round(列名，X) from 表名；\n\n      2. 查询数值四舍五入不保留小数\n\n         > select 列名 truncate(列名，1)；\n\n4. 模糊查询\n\n   只知道查询数据的一部分信息，需要借助like关键字以及%和_两个通配符来完成查询\n\n   %：代表0到多个任意字符，相当于正则表达式.*\n\n   _：代表任意的一个字符，相当于正则表达式.\n\n5. 排序查询\n\n   对表中已经查询出来的数据按照从小到大或者从大到小的顺序来进行排序如果和其他限制查询防砸一起使用时，排序查询必须放在最后\n\n   > select 列名1 列名2... from表名 [限制查询|模糊查询] order by 排序列 [asc(默认升序)]|desc(降序);\n\n6. 分支查询\n\n   根据列下面的不同的值来执行不同的操作\n\n   > select 列名1 列名2 case 查询列\n   >\n   > ​\twhen 值1 then 操作1\n   >\n   > ​\twhen 值2 then 操作2\n   >\n   > ​\telse 操作\n   >\n   > ​\tend [列别名] \n   >\n   > from 表名；\n   >\n   > null值在排序查询时被当做最小值\n   \n7. 分页查询\n\n   当数据库中数据量比较大的时候，不能一次性把数据库中所有数据都查询回来，这样会增大服务器端的查询和浏览器的展示压力，所以需要使用分页每次查询一批数据回来，MySQL中分页查询需要使用limit关键字完成\n\n   注意：分页查询不是标准的sql，不同的数据库需要使用不同的方式来完成分页\n\n   查询前五条数据\n\n   > select *from 表名 limit 5；\n\n   分页公式：\n\n   > select * from 表名 limit (page-1)*pageSize，pageSize；\n\n   总记录数：\n\n   > select count(*) from 表名；\n\n8. 分组查询\n\n   1. 单独使用分组函数\n\n      注意：分组函数是根据列下面多个数据经过计算返回一个数据，所以在select后面除了分组查询列外，不能再跟其他列\n\n      分组函数：聚合函数，多行函数\n\n      对表中不能直接体现出来的数据，需要根据列下面的多个值经过计算返回一个值\n\n      > max()/min()\n      >\n      > 求最大/最小值\n      >\n      > 可以对任意数据类型做统计\n\n      求某个值的最大值\n\n      > select 列名1，列名2... 列名X from 表名 where 列名X=(select max(列名X) from 表名)；\n\n   2. 单独使用分页查询\n\n      按照列下面不同的值来划分位若干个小组\n\n      > select 分组列 from 表名 [限制条件] group by 分组列 [having 过滤条件]\n\n      > select year(列名) from 表名 group by year(列名)\n\n   3. 分组函数和分页查询联合在一起使用\n\n      按照列下面不同的值来划分为若干个小组然后再单独使用分组函数来进行查询\n\n      > select 分组列，分组列2...from 表名 [where 限制条件] group by 分组列 [having]\n\n   4. sql实际执行顺序\n\n      > 1. from 表名\n      > 2. where 限制查询 | 模糊查询\n      > 3. select 查询列\n      > 4. group by 分组查询\n      > 5. having 分组过滤\n      > 6. order by 排序\n      > 7. limit 分页\n\n9. 子查询(嵌套查询)\n\n   在select查询语句中，where后面的限制条件不是一个确定的值，而是来自于另外一个查询语句的结果那么这套查询语句就被称为子查询，子查询主要是给主查询(父查询)提供数据使用，所以子查询要比主查询先执行，并且子查询必须要带上小括号\n\n   按照子查询返回结果分类：\n\n   1. 单行单列子查询\n\n      子查询的结果只有一列，且这一列下面只有一个值，一般可以配合 > >= < <= != <=>等比较运算符来进行使用\n\n   2. 多行单列子查询\n\n      子查询的结果只有一列，但是这一列下面可能有多个值一般配合any/all/in来进行使用\n\n   3. 多行多列子查询\n\n      子查询的返回结果有多个列，每列下面有多个值，一般是将其当做一张表来看待\n\n   4. 基于子查询复制一张表\n\n      > create table 新表名 as (select * from 旧表名)；\n\n   5. 子查询的exists(包含)关键字使用\n\n      子查询一般都是跟在where后面，exists后面的子查询只要至少返回一条记录，那么整个条件返回true，如果一条记录都没有，那么整个条件返回false\n\n      exists关键字使用场景:\n\n      当主查询给子查询提供数据使用时，可以使用exists或者not exists关键字\n\n10. 多表查询\n\n    我们需要查询的数据来自多张表，通常会在两张表之间建立一个关联字段，通过关联字段将两张表链接在一起，然后进行查询，这种关系一般时建立在主表的主键字段和从表的非主键字段之间\n\n    1. 关联查询\n\n       > select 列1，列2... from 表1，表2... where 表1.关联列=表2.关联列 and 表2.关联列=表3.关联列... [and 限制条件]\n       >\n       > 注意：查询列可以来自不同的表。关联查询只会返回两张表中同时满足条件的记录\n       >\n       > 做关联查询时，没有指定连接条件那么就会将左侧表中的每一行记录和右侧表中的所有记录从最后一行到第一行做逐行匹配显示，这是一个没有意义的值\n\n    2. 链接查询\n    \n       1. 内连接\n       \n          > select 列1，列2... from 表1 inner join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          >\n          > 注意：内联的查询结果和关联查询是一样的，都是返回两张表中同时满足条件的记录\n       \n       2. 外连接\n          \n          当从多张表查询数据时，需要返回满足条件的记录，也需要返回不满足的记录\n       \n          左外连接：以左侧当做驱动表，右侧表当做匹配表\n          \n          右外连接：以右侧表当做驱动表，左侧表当做匹配表，将驱动表中的每一行记录取出来和匹配表中的所有记录从下往上逐一进行匹配，最终会显示驱动表中的所有记录，匹配表中能匹配上的就显示，匹配不上的就显示null\n          \n          1. 左外连接\n          \n             > select 列1，列2... from 表1 left outer join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          \n          2. 右外连接\n          \n             > select 列1，列2... from 表1 right outer join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          \n          3. 查询结果集并集关键字\n          \n             1. union\n          \n                对两个结果集相同列的数据进行合并去除重复记录\n          \n             2. union all\n          \n                对两个结果集相同列的数据进行合并重复记录\n          \n       3. 自连接\n       \n          如果一张表数据之间具有上下级关系，此时我们可以通过表的别名将一张表虚拟成多张表，再通过关联查询或连接查询来查询表中数据\n       \n          > select 列1，列2... from 表1 别名1 left outer join 表1 别名2 on 别名1.关联列=别名2.关联列... [where 限制条件]\n    \n11. foreign key  \n\n    为了保证两张表中数据的完整性和一致性，可以再两张表关联字段之间建立一个外键约束关系，将两张表绑定在一起\n\n    > alter table 副表 add constraint 别名 foreign key (列名) references 主表(列名)；\n\n    > 注意：外键的建立会影响数据库的操作性能，因为在执行DML操作时会频繁的查询另外一张表中所有记录，所以不建议在两张表之间建立外键的约束，数据的完整性和一致性由java代码来控制\n\n    > alter table 副表 drop foreign key 外键的别名；\n\n    在数据库中除了主键约束之外，其他的三种约束都不需要创建，非空，唯一，外键三个约束作用应该都是用java业务逻辑代码来控制\n\n### 八、TCL事务控制语言\n\n为了保证表中数据的安全性和一致性，通常会将若干个DML操作绑定在一起向数据库提交，这些操作要么同时成功，要么同时失败，事务是一组不可分割的逻辑单元\n\n1. 事务的四大特性\n\n   1. **原子性Atomicity**\n\n      同一个事务内部的操作都是不可分割的\n\n   2. **一致性Consistency**\n\n      事务提交前后，数据库的状态必须是一致的，外界只能读取到事务开启前的状态或事务提交后端而状态，而不能读取到中间的状态\n\n   3. **隔离性lsolation**\n\n      多个用户在操作同一个表中的数据时，每个用户的操作时相互独立的事务，这些事务之间应该相互隔离，彼此不能干扰\n\n   4. 持久性Durability\n\n      事务一旦被提交后马，对数据库的修改就是永久性的，其他的回滚操作或故障不会对其具有任何影响\n\n2. 手动事务\n\n   事务的开启和提交需要去手动执行，每执行完一个DML操作后，如果不主动提交事务，那么数据不会持久化到数据库中\n\n3. 自动事务\n\n   事务的开启和提交是由数据库自动执行的，只要执行了一个DML操作后，不需要手动提交事务，数据会自动持久化到数据库中\n\n   mysq默认使用的是自动事务，每个事务中只有一条sql语句，所以通常在对mysql执行事务操作时需要将自动事务改为手动事务，方便我们可以去控制一个事务中可以存在多条sql语句，以及事务的开启，提交以及回滚时机\n\n4. 事务提交\n\n   1. 将自动事务提交改为手动提交\n\n      > set autocommit = 0;\n\n   2. 将事务改为手动提交后，下一条sql语句会自动开启一个事务\n\n      > 例：insert into 表名 values(值1，值2...)；\n      >\n      > 注意：在事务提交之前，数据是不会持久化到数据库中，而是存在内存的回滚段内\n\n   3. 提交事务，数据会被持久化到数据中，事务结束\n\n      > commit;\n\n   4. 事务回滚\n\n      让内存回滚段中操作撤销，事务回滚后，改事务结束\n\n      > rollback;\n\n   5. 设置回滚点\n\n      > savepoint 别名；\n      >\n      > SQL语句；\n      >\n      > savepoint 别名2；\n      >\n      > SQL语句；\n      >\n      > .......\n      >\n      > 让事务回滚到指定的回滚点\n      >\n      > rollback to 别名；\n      >\n      > 注意：回滚到某个回滚点上时，改事务并没有结束，需要rollback或这commit结束事务\n\n   6. 事务在java代码中控制：\n\n      ```java\n      try{\n          开启事务\n          DML....\n          DML....\n          提交事务\n      }catch(Exception){\n          回滚事务\n      }\n      ```\n\n   7. 事务隔离级别\n\n      |        事务隔离级别         | 脏读 | 不可重复读 | 幻读 |\n      | :-------------------------: | :--: | :--------: | :--: |\n      | 读未提交(read-uncommitted)  |  是  |     是     |  是  |\n      | 读已提交（read-committed）  |  否  |     是     |  是  |\n      | 可重复读（repeatable-read） |  否  |     否     |  是  |\n      |   串行化（serializable）    |  否  |     否     |  否  |\n\n      1. 脏读\n\n         脏读(Dirty Read):当一个事务正在访问数据并对数据做了修改,而这种修改还没有提交到数据库,这时另外一个事务也访问了这个数据,然后使用了这个数据,因为这个数据是还没有提交的操作,那么另外一个事务读到的这个数据就是\"脏数据\",依据脏数据所做的操作可能是不正确的\n         如:事务A读取了事务B更新但未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据\n\n      2. 不可重复读：\n\n         指在一个事务内多次读取同一数据,在这个事务还没有结束时,另外一个事务也访问该数据,那么在第一个事务中的两次读取数据之间,由于第二个事务的修改导致第一个事务两次读取的数据不一致,这就导致了一个事务内两次读取的数据不一致,因此称为不可重复读\n         如:事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\n\n      3. 幻读：\n\n         幻读(Phantom Read):幻读与不可重复读类似,他发生在一个事务T1读取了几行数据,接着另外一个并发事务T2插入了一些数据,在随后的查询中,第一个事务就会发现读了一些原本不存在的记录,就好像发生了幻觉一样,所以称为幻读 \n\n         如:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n### 九、DCL数据控制语言\n\n主要用于管理数据库用户以及控制数据的访问控制权限\n\n只是由DBA来进行的操作\n\n1. 用户管理\n\n   1. 查询用户\n\n      > use mysql;\n      >\n      > select * from user\\G;\n\n   2. 新建用户\n\n      > create user '用户名'@'主机名' identified by '密码';\n      >\n      > 注意：主机名为localhost/%，localhost为本地访问，%为多用户远程访问，单用户远程访问为指定ip地址\n\n   3. 修改密码\n\n      > alter user '用户名'@'主机名' identified with mysql_native_password by '新密码'；\n\n   4. 删除指定用户\n\n      > drop user '用户名'@'主机名'；\n\n2. 权限管理\n\n   mysql中定义了很多权限，但是常用的只有一下几种\n\n   1. ALL/All Privileges\t 所有权\n   2. select                 查询权限\n   3. insert                 添加权限\n   4. update                 修改权限\n   5. delete                 删除权限\n   6. drop                   删除库/表/表结构/视图权限\n   7. create                 创建库/表权限\n\n   > 查询授予用户的权限\n   >\n   > show grants for '用户名'@'主机名'\n\n3. 授予权限\n\n   > grant 权限1，权限2... on 数据库名.表名 to '用户名'@'主机名'；\n\n4. 撤销权限\n\n   > revoke 权限1，权限2... on数据库名.表名 from '用户名'@'主机名'；\n\n### 十、表于表之间的关系\n\n1. 一对多，多对一(one-to-many  many-to-one)\n\n   表设计：在多方表中添加一个外键列，去关联一方表的主键列\n\n   案例：一个部门多个员工\n\n2. 一对一(one-to-one)\n\n   案例：一个公司发行一种股票\n\n   1. 单向主键关联\n   2. 双向主键关联\n   3. 单向外键关联\n   4. 双向外键关联\n\n3. 多对多(many-to-many)\n\n   表设计：创建一张中间表，用于存储两张多方表的主键\n\n   案例：一个学生对应多个老师，一个老师对应多个学生吧\n\n### 十一、ER图\n\nEntity-relationship  实体关系图\n\n主要用于描述数据库中表与表之间得关系\n\n1. 实体Entity\n\n   数据模型中实体对象(表),使用长方形表示\n\n2. 属性Attribute\n\n   实体对象得属性(字段)使用椭圆形表示\n\n3. 关系Relationship\n\n   实体对象之间得关系(表与表之间得关系)，使用菱形表示\n\n### 十二、数据表设计得三大范式\n\n为了建立结构合理，数据冗余较小得表，所以数据表在设计时要遵循相应得原则，也就是范式\n\n1. 保证数据表中每一列得原子性，每一列下面得数据不能再拆分\n2. 非主键字段不能部分依赖主键字段确保表中的每一列要和主键列直接关联\n3. 确保表中的每一列和主键列都素hi直接关联关系，而不是间接关联，不能存在传递依赖\n","source":"_posts/MySQL.md","raw":"---\ntitle: MySQL\ndate: 2023-02-25 11:18:57\ntags: 数据库\ncategories: 数据库\ncover: /img/images/MySQL.jpg \n---\n\n### 一、数据库概念\n\nDataBase：以表的数据结构形式来对程序产生的数据进行结构化存储和管理的数据仓库\n\nDBMS：DataBase Manager Service\n\n数据库管理系统\n\n1. 数据库服务器\n\n   负责永久性存储管理以及维护数据\n\n   在一个MySQL数据库服务器中可以存在多个数据库，互相之间名称不能重复\n\n2. 数据库客户端\n\n   通过ip和端口号链接上数据库服务器，通过账号密码进行登录，登录成功后就可以向数据库服务器发送sql指令来操作数据库服务器端的数据，并呈现操作结果\n\n   客户端：\n\n   1. cmd命令行\n   2. 图形界面（navicat...）\n   3. Java代码(JDBC,mybatis...)\n\n### 二、数据库分类\n\n1、**关系型数据库**\n\n使用一张二维表来存储数据，表中列与列之间有关系，同一个库中表和表之间也可以存在关系\n\n1. Oracle\n\n   甲骨文公司产品，第一款大型关系型数据库\n\n   个人免费，公司收费\n\n2. DB2\n\n   IBM公司大型关系型数据库\n\n   跨平台性好\n\n3. SqlServer\n\n   微软公司大型关系型数据库\n\n   对windows平台支持比较好\n\n4. MySQL\n\n   小型关系型数据库\n\n   免费开源(非核心代码)\n\n5. sqlite\n\n   小型关系型数据库，主要应用于移动设备上，可以用于存储联系人，短信，图片等信息\n\n2、**非关系型数据库**\n\n主要是以key-value键值对的形式来对数据进行存储，元素和元素之间没有关系，主要用于充当缓存\n\n1. redis\n2. memcached\n3. mongodb\n\n### 三、数据库基本命令\n\n1. status\n\n   显示当前数据库系统的相关信息\n\n2. show databases;\n\n   查看当前数据库系统中有那些库\n\n3. use 库名\n\n   打开/切换到某一个库中\n\n4. show tables;\n\n   查看当前库下有那些表\n\n5. select database()\n\n   查看当前正在操作的库\n\n6. select user()\n\n   查看当前登录用户\n\n7. select now()\n\n   查询当前系统的日期时间\n\n8. select XXX(now())\n\n   查询当前日期时间的指定字段\n\n   XXX:date/time/year/month/day/hour/minute/week/second\n\n### 四、SQL语句\n\nStructured Query Language(结构化查询语言)\n\n通过数据库客户端向服务器发送指令来执行建库删库，建表删表以及对表中数据执行增删查改等操作\n\nsql语句是一门国际化标准语言，各大数据库厂商都会遵循相同的sql标准\n\n特点：关键字不区分大小写，表中数据区分大小写\n\nSQL语句分类;\n\n1. DDL(数据定义语言)\n\n   主要用于对数据库和表的创建删除，以及对表结构的修改\n\n   1. alter  \t更新(数据库，表，表结构)\n   2. create     创建(数据库，表)\n   3. drop       删除(数据库，表，表中列)\n   4. trunate    表截断(表)\n\n2. DML(数据操作语言)\n\n   主要用于对表中数据执行插入，删除，修改操作\n\n   1. insert   插入\n   2. delete   删除(删除表中一行数据)\n   3. update   修改\n\n3. DQL(数据查询语言)\n\n   主要用于从表中查询数据\n\n   1. select\t查询\n\n4. TCL(事务控制语言)\n\n   主要用于控制多个人操作数据库\n\n   1. set transaction   设置事务\n   2. commit            提交事务\n   3. rollback          回滚事务\n   4. savepoint         设置回滚点\n\n5. DCL(数据控制语言)\n\n   主要用于设置用户的访问权限\n\n   1. create user\t创建用户\n   2. grant          授权\n   3. revoke         撤销权限\n\n### 五、DDL数据定义语言\n\n1. DataBase数据库的创建与删除\n\n   先显示当前数据库系统有那些库(库名不能重复)\n\n   > show databases；\n\n   创建一个数据库，并设置编码方式\n\n   > create database 库名 default character set utf8；\n   >\n   > create database 库名 charset=utf8；\n   >\n   > 注意：可以在库名前面添加if not exists判断库是否存在。存在就不创建\n\n   删除一个数据库\n\n   > drop database 库名；\n\n   打开/切换到某一个库\n\n   > use 库名；\n\n   查看当前正在工作的数据库\n\n   > select database();\n\n   查看数据库的创建过程\n\n   > show create database 库名；\n\n2. Table表格的创建与删除\n\n   表格是关系型数据库中存储数据的最基本单元，表格由行row和列colum组成，其中表头也叫做字段Filed，表中的每一行叫做记录Record\n\n   打开数据库\n\n   > use 库名\n\n   显示当前库下表名不能重复\n\n   > show tables;\n\n   创建一个表\n\n   > mysql>create table 表名(\n   >\n   > ​    ->字段名 字段类型(类型大小)\n   >\n   > );\n\n   > 约束Constraint\n   >\n   > 注意：\n   >\n   > ​\tprimary key\t\t主键\n   >\n   > ​\tauto_increment\t 自增\n   >\n   > ​\tcomment\t\t\t注释\n   >\n   > ​\tnot null\t\t   不能为空\n   >\n   > ​\tdefault \t\t   默认值\n   >\n   > ​\tunique\t\t\t 唯一的\n   >\n   > ​\tforeign key        外键\n\n   删除表\n\n   > drop table 表名；\n\n   查看表结构\n\n   > desc 表名；\n\n   查看表的创建过程\n\n   >  show create table 表名；\n\n   列添加\n\n   > alter table 表名 add 列名 类型；\n\n   在某一列后添加一列\n\n   > alter table 表名 add 列名 类型 after 插入在谁后面的列名；\n\n   在最前面插入列\n\n   > alter table 表名 add 列名 类型 first;\n\n   列名的修改\n\n   > alter table 表名 change 旧列名 新列名 类型；\n\n   列属性修改\n\n   > alter table 表名 modify 列名 类型；\n   >\n   > 注意：长度由大改小可能会失败\n\n   删除列\n\n   > alter table 表名 drop 列名；\n\n   表名修改\n\n   > alter table 表名 rename to 新表名；\n\n   表截断(不能回滚)\n\n   > truncate table 表名\n\n3. 表中字段的常用数据类型\n\n   1. 数值类型\n\n      1. 整数类型\n\n         1. tinyint\t 1个字节\n         2. smallint    2个字节\n         3. mediumint   3个字节\n         4. int/integer 4个字节\n         5. bigint      8个字节\n\n      2. 浮点类型\n\n         1. float       4个字节\n      \n         2. double      8个字节\n\n         3. decimal(m,d)精确位数，公共m位，精确到小数点后d位\n      \n   2. 字符类型\n      数据库中不区分字符和字符串，字符类型必须使用单引号或者双引号引起来\n      \n      1. char(定长字符类型)不足的会以空格补齐，最多255个字符\n      2. varchar(可变长度字符类型)由多少字符就占多少位置，最多65535字符\n      \n      char和varchar的区别：\n      \n      > 1. char是定长字符串，查询速度快，但是可能浪费空间，一般列下面的数值长度为定长时使用\n      >\n      > 2. varchar是变长字符串，可以节约空间，但是查询速度慢，一般列下面数值长度不固定时使用\n     \n   3. 日期时间类型\n      \n      在MySQL数据库中日期时间类型都是以特定字符串格式来进行存储的\n      \n      1. date\n      \n         日期类型，以“yyyy-MM-dd”字符串格式来进行存储\n      \n      2. time\n      \n         时间类型，以“HH:mm:ss”字符串格式来进行存储\n      \n      3. datetime\n      \n         日期时间类型，以“yyyy-MM-dd HH:mm:sss\"字符串格式来存储\n      \n      4. year\n      \n         年份类型，以”yyyy“字符串格式来进行存储\n      \n      5. timestamp\n      \n         时间戳类型，以int整数值格式来进行存储\n      \n   3. 布尔类型\n      \n         boolean/bool\n      \n         只能存储true/false两种值，在MySQL底层会自动将boolean类型转成tinyint类型，其他true转为1，false转为0\n      \n   4. 不常用类型\n      \n         > 注意：text文本类型和blob二进制类型不建议使用，实际业务中是将数据存储到文件中，然后再将文件的地址存储到数据库中\n      \n         1. 文本类型\n         \n            主要用于存储大数据量的文本\n         \n            1. tinytext\n            2. mediumtext\n            3. text\n            4. longtext\n         \n         2. blob(二进制类型)\n         \n            主要用于存储二进制文件\n         \n            图片、视频、音频...\n         \n            1. tinyblob\n            2. mediumblob\n            3. blob\n            4. longblob\n\n### 六、DML数据操纵语言\n\n主要用于对表中数据执行增删改操作\n\n1. insert(插入)\n\n   > 1. 向所有列下面插入数据(有几列就给几个值)\n   >\n   >    insert into 表名 values(值1，值2，值3...)；\n   >\n   > 2. 向部分列下面插入数据(列个数与值个数相等)\n   >\n   >    insert into 表名(列1，列2，列3...) values(值1，值2，值3...)\n   >\n   >    非空列，如果没有默认值，要主动插入数据\n   >\n   > 3. 同时插入多条数据\n   >\n   >    insert into 表名(列1，列2，列3...) \n   >\n   >    values(值1，值2，值3...)，(值1，值2，值3...)，(值1，值2，值3...)...\n\n2. update(修改)\n\n   > 1. 修改列下面所有的记录(危险操作)\n   >\n   >    update 表名 set 列名1=值1，列名2=值2...；\n   >\n   > 2. 根据条件修改列下面的值\n   >\n   >    update 表名 set 列名 = 值 where 条件；\n   >\n   > 3. 根据多条件修改下面的值\n   >\n   >    update 表名 set 列名=值... where 条件1，条件2；\n   >\n   > 4. 条件值为null时\n   >\n   >    update 表名 set 列名=值... where 条件名 is null；\n   >\n   > 5. 条件的值不为null时\n   >\n   >    update 表名 set 列名=值... where 条件 is not null；\n\n1. delete(删除)\n\n   > 1. 全表删除(禁用)\n   >\n   >    delete from 表名；\n   >\n   > 2. 根据条件删除一条记录\n   >\n   >    delte from 表名 where 条件；\n\n### 七、DQL数据查询语言\n\n主要用于从表中查询数据回来\n\n导入sql文件\n\n> msyql> source XXX.sql\n\n导出sql文件\n\n> mysqldump -u用户名-p密码 数据库名 > 导出地址\\数据库名.sql\n\n1. 基本查询\n\n   1. 全表查询\n\n      > select * from 表名；\n\n   2. 查询指定数据\n\n      > select 列名1 列名2 ...from 表名；\n\n   3. 对查询出来的列指定列别名\n\n      > select 列名1 as 别名1，列名2 as 别名2 form 表名；\n\n   4. 去除列下面重复的数据\n\n      > select distinct 列名 from 表名；\n      >\n      > select distinct 列名1，列名2 from 表名；\n\n2. 限制查询\n\n   限制查询执行过程：\n\n   执行from 表名-> 执行where 查询限制条件(从上到下做逐行匹配)->返回true，留下该行记录，返回false过滤改行记录->执行select 列名1，列名2...从留下的行记录中确定显示的列\n\n   查询比较条件：\n\n   ​\t=\t>\t<\t>=\t<=\t!=\t<>\tis null\tis not null\n\n   1. 根据条件查询指定列名\n\n      > select 列名，列名2... from 表名 where 条件；\n\n   2. 查询某年的数据大小比较\n\n      > select 列名1,列名2... from 表名 where 列名 < 'yyyy-MM-dd';\n      >\n      > select 列名1,列名2... from 表名 where year(列名) < yyyy;\n\n   3. 查询不是某个部门的\n\n      > select * from 表名 where 列名 <> ‘值’；\n\n   4. and 和 or(and优先级比or高，小括号提升优先级)\n\n      > and:等于&&，查询出来的结果必须同时满足多个条件\n      >\n      > or：等于||，查询出来的结果满足其中一个即可\n\n   5. any 和all\n\n      > any：查询的结果值只要满足其中任意一个条件即可\n      >\n      > all：查询的结果值需要同时满足多个条件\n      >\n      > 一般配合 > >= < <= 来进行使用\n      >\n      > select * from 表名 where 查询列 > any(值1，值2...);大于最小值\n      >\n      > select * from 表名 where 查询列 < any(值1，值2...);小于最大值\n      >\n      > select * from 表名 where 查询列 > all(值1，值2...);大于最大值\n      >\n      > select * from 表名 where 查询列 < all(值1，值2...);小于最小值\n\n   5. 值范围查询\n\n      > select * from 表名 where 查询列 between 值1 and 值2；\n      >\n      > select * from 表名 where 查询列>= 值1 and 查询列<= 值2；\n      >\n      > 不在值1和值2范围内\n      >\n      > select * from 表名 where 查询列 not between 值1 and 值2；\n      >\n      > select * from 表名 where 查询列<值1 or 查询列>值2；\n\n   6. 值列表查询\n\n      判断查询列下面的数据是否在值列表的范围之内，等价于查询列=值1 or 查询了=值2\n\n      > select * from 表名 where 查询列 in(值1，值2...)\n\n      判断查询列下面的数据是否在值列表的范围之内等价于查询列!=值1 or 查询了!=值2\n\n      > select * from 表名 where 查询列 not in(值1，值2...)\n\n      > 注意：in和 not in 不能匹配null值，需要使用is null 和is not null\n      \n   8. 查询列上使用表达式或函数\n\n      > 表达式：\n      >\n      > ​\tselect * from 表名 where 表达式(列名+-*/值) > 值；\n      >\n      > ​\tselect *,新增列 from 表名 where 表达式(列名+-\\*/值) > 值;\n\n   9. 查询是否包含某个字符\n\n      > select * from 表名 where 列名 regexp '字符'；\n      >\n      > select * from 表名 where 列名 rlike '字符'；\n\n   10. 查询某个列的值为null\n\n      > select * from 表名 where 列名 <=> null;\n\n3. 函数\n\n   1. 系统函数\n      1. BIN(X) \t \t将X转换为二进制\n      2. BINARY(S)       将字符串s转为二进制字符串\n      3. CAST(X AS type) 转换数据类型\n      4. USER()          返回当前用户\n      5. VERSION()       返回数据库的版本号\n      6. IFNULL(v1,v2)   v1的值为null，返回v1，否则返回v2\n      7. LAST_INSERT_ID()返回插入的最后一条记录的自增长id\n      8. JSON_OBJECT()   将键值对转换为JSON对象\n      9. JSON_ARRAY()    将值转换为JSON数组\n\n   2. 字符串函数\n\n      1. 以字段值:字段值2:字段值3格式显示所有信息\n\n         > select concat(列名1，':',列名2，':',....)from 表名；\n         >\n         > select concat_ws(':'，列名1,列名2....)from 表名；\n\n      2. 左侧补齐/右侧补齐\n\n         > select lpad(列名，长度，'填补字符') from 表名；\n         >\n         > select rpad(列名，长度，'填补字符') from 表名；\n\n   3. 日期函数\n\n      1. 查询一个时间段到多少天后的时间\n\n         > select adddate(起始日期，多少天)；\n         >\n         > select adddate(起始日期，INTERVAl 10 MONTH)；\n\n      2. 计算两个日期直接的时间\n\n         > select datediff(结束日期，起始日期)；\n\n   4. 数值函数\n\n      1. 查询数值四舍五入保留小数点后X位\n\n         > select 列名，round(列名，X) from 表名；\n\n      2. 查询数值四舍五入不保留小数\n\n         > select 列名 truncate(列名，1)；\n\n4. 模糊查询\n\n   只知道查询数据的一部分信息，需要借助like关键字以及%和_两个通配符来完成查询\n\n   %：代表0到多个任意字符，相当于正则表达式.*\n\n   _：代表任意的一个字符，相当于正则表达式.\n\n5. 排序查询\n\n   对表中已经查询出来的数据按照从小到大或者从大到小的顺序来进行排序如果和其他限制查询防砸一起使用时，排序查询必须放在最后\n\n   > select 列名1 列名2... from表名 [限制查询|模糊查询] order by 排序列 [asc(默认升序)]|desc(降序);\n\n6. 分支查询\n\n   根据列下面的不同的值来执行不同的操作\n\n   > select 列名1 列名2 case 查询列\n   >\n   > ​\twhen 值1 then 操作1\n   >\n   > ​\twhen 值2 then 操作2\n   >\n   > ​\telse 操作\n   >\n   > ​\tend [列别名] \n   >\n   > from 表名；\n   >\n   > null值在排序查询时被当做最小值\n   \n7. 分页查询\n\n   当数据库中数据量比较大的时候，不能一次性把数据库中所有数据都查询回来，这样会增大服务器端的查询和浏览器的展示压力，所以需要使用分页每次查询一批数据回来，MySQL中分页查询需要使用limit关键字完成\n\n   注意：分页查询不是标准的sql，不同的数据库需要使用不同的方式来完成分页\n\n   查询前五条数据\n\n   > select *from 表名 limit 5；\n\n   分页公式：\n\n   > select * from 表名 limit (page-1)*pageSize，pageSize；\n\n   总记录数：\n\n   > select count(*) from 表名；\n\n8. 分组查询\n\n   1. 单独使用分组函数\n\n      注意：分组函数是根据列下面多个数据经过计算返回一个数据，所以在select后面除了分组查询列外，不能再跟其他列\n\n      分组函数：聚合函数，多行函数\n\n      对表中不能直接体现出来的数据，需要根据列下面的多个值经过计算返回一个值\n\n      > max()/min()\n      >\n      > 求最大/最小值\n      >\n      > 可以对任意数据类型做统计\n\n      求某个值的最大值\n\n      > select 列名1，列名2... 列名X from 表名 where 列名X=(select max(列名X) from 表名)；\n\n   2. 单独使用分页查询\n\n      按照列下面不同的值来划分位若干个小组\n\n      > select 分组列 from 表名 [限制条件] group by 分组列 [having 过滤条件]\n\n      > select year(列名) from 表名 group by year(列名)\n\n   3. 分组函数和分页查询联合在一起使用\n\n      按照列下面不同的值来划分为若干个小组然后再单独使用分组函数来进行查询\n\n      > select 分组列，分组列2...from 表名 [where 限制条件] group by 分组列 [having]\n\n   4. sql实际执行顺序\n\n      > 1. from 表名\n      > 2. where 限制查询 | 模糊查询\n      > 3. select 查询列\n      > 4. group by 分组查询\n      > 5. having 分组过滤\n      > 6. order by 排序\n      > 7. limit 分页\n\n9. 子查询(嵌套查询)\n\n   在select查询语句中，where后面的限制条件不是一个确定的值，而是来自于另外一个查询语句的结果那么这套查询语句就被称为子查询，子查询主要是给主查询(父查询)提供数据使用，所以子查询要比主查询先执行，并且子查询必须要带上小括号\n\n   按照子查询返回结果分类：\n\n   1. 单行单列子查询\n\n      子查询的结果只有一列，且这一列下面只有一个值，一般可以配合 > >= < <= != <=>等比较运算符来进行使用\n\n   2. 多行单列子查询\n\n      子查询的结果只有一列，但是这一列下面可能有多个值一般配合any/all/in来进行使用\n\n   3. 多行多列子查询\n\n      子查询的返回结果有多个列，每列下面有多个值，一般是将其当做一张表来看待\n\n   4. 基于子查询复制一张表\n\n      > create table 新表名 as (select * from 旧表名)；\n\n   5. 子查询的exists(包含)关键字使用\n\n      子查询一般都是跟在where后面，exists后面的子查询只要至少返回一条记录，那么整个条件返回true，如果一条记录都没有，那么整个条件返回false\n\n      exists关键字使用场景:\n\n      当主查询给子查询提供数据使用时，可以使用exists或者not exists关键字\n\n10. 多表查询\n\n    我们需要查询的数据来自多张表，通常会在两张表之间建立一个关联字段，通过关联字段将两张表链接在一起，然后进行查询，这种关系一般时建立在主表的主键字段和从表的非主键字段之间\n\n    1. 关联查询\n\n       > select 列1，列2... from 表1，表2... where 表1.关联列=表2.关联列 and 表2.关联列=表3.关联列... [and 限制条件]\n       >\n       > 注意：查询列可以来自不同的表。关联查询只会返回两张表中同时满足条件的记录\n       >\n       > 做关联查询时，没有指定连接条件那么就会将左侧表中的每一行记录和右侧表中的所有记录从最后一行到第一行做逐行匹配显示，这是一个没有意义的值\n\n    2. 链接查询\n    \n       1. 内连接\n       \n          > select 列1，列2... from 表1 inner join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          >\n          > 注意：内联的查询结果和关联查询是一样的，都是返回两张表中同时满足条件的记录\n       \n       2. 外连接\n          \n          当从多张表查询数据时，需要返回满足条件的记录，也需要返回不满足的记录\n       \n          左外连接：以左侧当做驱动表，右侧表当做匹配表\n          \n          右外连接：以右侧表当做驱动表，左侧表当做匹配表，将驱动表中的每一行记录取出来和匹配表中的所有记录从下往上逐一进行匹配，最终会显示驱动表中的所有记录，匹配表中能匹配上的就显示，匹配不上的就显示null\n          \n          1. 左外连接\n          \n             > select 列1，列2... from 表1 left outer join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          \n          2. 右外连接\n          \n             > select 列1，列2... from 表1 right outer join 表2 on 表1.关联列=表2.关联列... [where 限制条件]\n          \n          3. 查询结果集并集关键字\n          \n             1. union\n          \n                对两个结果集相同列的数据进行合并去除重复记录\n          \n             2. union all\n          \n                对两个结果集相同列的数据进行合并重复记录\n          \n       3. 自连接\n       \n          如果一张表数据之间具有上下级关系，此时我们可以通过表的别名将一张表虚拟成多张表，再通过关联查询或连接查询来查询表中数据\n       \n          > select 列1，列2... from 表1 别名1 left outer join 表1 别名2 on 别名1.关联列=别名2.关联列... [where 限制条件]\n    \n11. foreign key  \n\n    为了保证两张表中数据的完整性和一致性，可以再两张表关联字段之间建立一个外键约束关系，将两张表绑定在一起\n\n    > alter table 副表 add constraint 别名 foreign key (列名) references 主表(列名)；\n\n    > 注意：外键的建立会影响数据库的操作性能，因为在执行DML操作时会频繁的查询另外一张表中所有记录，所以不建议在两张表之间建立外键的约束，数据的完整性和一致性由java代码来控制\n\n    > alter table 副表 drop foreign key 外键的别名；\n\n    在数据库中除了主键约束之外，其他的三种约束都不需要创建，非空，唯一，外键三个约束作用应该都是用java业务逻辑代码来控制\n\n### 八、TCL事务控制语言\n\n为了保证表中数据的安全性和一致性，通常会将若干个DML操作绑定在一起向数据库提交，这些操作要么同时成功，要么同时失败，事务是一组不可分割的逻辑单元\n\n1. 事务的四大特性\n\n   1. **原子性Atomicity**\n\n      同一个事务内部的操作都是不可分割的\n\n   2. **一致性Consistency**\n\n      事务提交前后，数据库的状态必须是一致的，外界只能读取到事务开启前的状态或事务提交后端而状态，而不能读取到中间的状态\n\n   3. **隔离性lsolation**\n\n      多个用户在操作同一个表中的数据时，每个用户的操作时相互独立的事务，这些事务之间应该相互隔离，彼此不能干扰\n\n   4. 持久性Durability\n\n      事务一旦被提交后马，对数据库的修改就是永久性的，其他的回滚操作或故障不会对其具有任何影响\n\n2. 手动事务\n\n   事务的开启和提交需要去手动执行，每执行完一个DML操作后，如果不主动提交事务，那么数据不会持久化到数据库中\n\n3. 自动事务\n\n   事务的开启和提交是由数据库自动执行的，只要执行了一个DML操作后，不需要手动提交事务，数据会自动持久化到数据库中\n\n   mysq默认使用的是自动事务，每个事务中只有一条sql语句，所以通常在对mysql执行事务操作时需要将自动事务改为手动事务，方便我们可以去控制一个事务中可以存在多条sql语句，以及事务的开启，提交以及回滚时机\n\n4. 事务提交\n\n   1. 将自动事务提交改为手动提交\n\n      > set autocommit = 0;\n\n   2. 将事务改为手动提交后，下一条sql语句会自动开启一个事务\n\n      > 例：insert into 表名 values(值1，值2...)；\n      >\n      > 注意：在事务提交之前，数据是不会持久化到数据库中，而是存在内存的回滚段内\n\n   3. 提交事务，数据会被持久化到数据中，事务结束\n\n      > commit;\n\n   4. 事务回滚\n\n      让内存回滚段中操作撤销，事务回滚后，改事务结束\n\n      > rollback;\n\n   5. 设置回滚点\n\n      > savepoint 别名；\n      >\n      > SQL语句；\n      >\n      > savepoint 别名2；\n      >\n      > SQL语句；\n      >\n      > .......\n      >\n      > 让事务回滚到指定的回滚点\n      >\n      > rollback to 别名；\n      >\n      > 注意：回滚到某个回滚点上时，改事务并没有结束，需要rollback或这commit结束事务\n\n   6. 事务在java代码中控制：\n\n      ```java\n      try{\n          开启事务\n          DML....\n          DML....\n          提交事务\n      }catch(Exception){\n          回滚事务\n      }\n      ```\n\n   7. 事务隔离级别\n\n      |        事务隔离级别         | 脏读 | 不可重复读 | 幻读 |\n      | :-------------------------: | :--: | :--------: | :--: |\n      | 读未提交(read-uncommitted)  |  是  |     是     |  是  |\n      | 读已提交（read-committed）  |  否  |     是     |  是  |\n      | 可重复读（repeatable-read） |  否  |     否     |  是  |\n      |   串行化（serializable）    |  否  |     否     |  否  |\n\n      1. 脏读\n\n         脏读(Dirty Read):当一个事务正在访问数据并对数据做了修改,而这种修改还没有提交到数据库,这时另外一个事务也访问了这个数据,然后使用了这个数据,因为这个数据是还没有提交的操作,那么另外一个事务读到的这个数据就是\"脏数据\",依据脏数据所做的操作可能是不正确的\n         如:事务A读取了事务B更新但未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据\n\n      2. 不可重复读：\n\n         指在一个事务内多次读取同一数据,在这个事务还没有结束时,另外一个事务也访问该数据,那么在第一个事务中的两次读取数据之间,由于第二个事务的修改导致第一个事务两次读取的数据不一致,这就导致了一个事务内两次读取的数据不一致,因此称为不可重复读\n         如:事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\n\n      3. 幻读：\n\n         幻读(Phantom Read):幻读与不可重复读类似,他发生在一个事务T1读取了几行数据,接着另外一个并发事务T2插入了一些数据,在随后的查询中,第一个事务就会发现读了一些原本不存在的记录,就好像发生了幻觉一样,所以称为幻读 \n\n         如:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n### 九、DCL数据控制语言\n\n主要用于管理数据库用户以及控制数据的访问控制权限\n\n只是由DBA来进行的操作\n\n1. 用户管理\n\n   1. 查询用户\n\n      > use mysql;\n      >\n      > select * from user\\G;\n\n   2. 新建用户\n\n      > create user '用户名'@'主机名' identified by '密码';\n      >\n      > 注意：主机名为localhost/%，localhost为本地访问，%为多用户远程访问，单用户远程访问为指定ip地址\n\n   3. 修改密码\n\n      > alter user '用户名'@'主机名' identified with mysql_native_password by '新密码'；\n\n   4. 删除指定用户\n\n      > drop user '用户名'@'主机名'；\n\n2. 权限管理\n\n   mysql中定义了很多权限，但是常用的只有一下几种\n\n   1. ALL/All Privileges\t 所有权\n   2. select                 查询权限\n   3. insert                 添加权限\n   4. update                 修改权限\n   5. delete                 删除权限\n   6. drop                   删除库/表/表结构/视图权限\n   7. create                 创建库/表权限\n\n   > 查询授予用户的权限\n   >\n   > show grants for '用户名'@'主机名'\n\n3. 授予权限\n\n   > grant 权限1，权限2... on 数据库名.表名 to '用户名'@'主机名'；\n\n4. 撤销权限\n\n   > revoke 权限1，权限2... on数据库名.表名 from '用户名'@'主机名'；\n\n### 十、表于表之间的关系\n\n1. 一对多，多对一(one-to-many  many-to-one)\n\n   表设计：在多方表中添加一个外键列，去关联一方表的主键列\n\n   案例：一个部门多个员工\n\n2. 一对一(one-to-one)\n\n   案例：一个公司发行一种股票\n\n   1. 单向主键关联\n   2. 双向主键关联\n   3. 单向外键关联\n   4. 双向外键关联\n\n3. 多对多(many-to-many)\n\n   表设计：创建一张中间表，用于存储两张多方表的主键\n\n   案例：一个学生对应多个老师，一个老师对应多个学生吧\n\n### 十一、ER图\n\nEntity-relationship  实体关系图\n\n主要用于描述数据库中表与表之间得关系\n\n1. 实体Entity\n\n   数据模型中实体对象(表),使用长方形表示\n\n2. 属性Attribute\n\n   实体对象得属性(字段)使用椭圆形表示\n\n3. 关系Relationship\n\n   实体对象之间得关系(表与表之间得关系)，使用菱形表示\n\n### 十二、数据表设计得三大范式\n\n为了建立结构合理，数据冗余较小得表，所以数据表在设计时要遵循相应得原则，也就是范式\n\n1. 保证数据表中每一列得原子性，每一列下面得数据不能再拆分\n2. 非主键字段不能部分依赖主键字段确保表中的每一列要和主键列直接关联\n3. 确保表中的每一列和主键列都素hi直接关联关系，而不是间接关联，不能存在传递依赖\n","slug":"MySQL","published":1,"updated":"2023-08-10T09:50:42.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9g000mfswog8s45iq4","content":"<h3 id=\"一、数据库概念\"><a href=\"#一、数据库概念\" class=\"headerlink\" title=\"一、数据库概念\"></a>一、数据库概念</h3><p>DataBase：以表的数据结构形式来对程序产生的数据进行结构化存储和管理的数据仓库</p>\n<p>DBMS：DataBase Manager Service</p>\n<p>数据库管理系统</p>\n<ol>\n<li><p>数据库服务器</p>\n<p>负责永久性存储管理以及维护数据</p>\n<p>在一个MySQL数据库服务器中可以存在多个数据库，互相之间名称不能重复</p>\n</li>\n<li><p>数据库客户端</p>\n<p>通过ip和端口号链接上数据库服务器，通过账号密码进行登录，登录成功后就可以向数据库服务器发送sql指令来操作数据库服务器端的数据，并呈现操作结果</p>\n<p>客户端：</p>\n<ol>\n<li>cmd命令行</li>\n<li>图形界面（navicat…）</li>\n<li>Java代码(JDBC,mybatis…)</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"二、数据库分类\"><a href=\"#二、数据库分类\" class=\"headerlink\" title=\"二、数据库分类\"></a>二、数据库分类</h3><p>1、<strong>关系型数据库</strong></p>\n<p>使用一张二维表来存储数据，表中列与列之间有关系，同一个库中表和表之间也可以存在关系</p>\n<ol>\n<li><p>Oracle</p>\n<p>甲骨文公司产品，第一款大型关系型数据库</p>\n<p>个人免费，公司收费</p>\n</li>\n<li><p>DB2</p>\n<p>IBM公司大型关系型数据库</p>\n<p>跨平台性好</p>\n</li>\n<li><p>SqlServer</p>\n<p>微软公司大型关系型数据库</p>\n<p>对windows平台支持比较好</p>\n</li>\n<li><p>MySQL</p>\n<p>小型关系型数据库</p>\n<p>免费开源(非核心代码)</p>\n</li>\n<li><p>sqlite</p>\n<p>小型关系型数据库，主要应用于移动设备上，可以用于存储联系人，短信，图片等信息</p>\n</li>\n</ol>\n<p>2、<strong>非关系型数据库</strong></p>\n<p>主要是以key-value键值对的形式来对数据进行存储，元素和元素之间没有关系，主要用于充当缓存</p>\n<ol>\n<li>redis</li>\n<li>memcached</li>\n<li>mongodb</li>\n</ol>\n<h3 id=\"三、数据库基本命令\"><a href=\"#三、数据库基本命令\" class=\"headerlink\" title=\"三、数据库基本命令\"></a>三、数据库基本命令</h3><ol>\n<li><p>status</p>\n<p>显示当前数据库系统的相关信息</p>\n</li>\n<li><p>show databases;</p>\n<p>查看当前数据库系统中有那些库</p>\n</li>\n<li><p>use 库名</p>\n<p>打开&#x2F;切换到某一个库中</p>\n</li>\n<li><p>show tables;</p>\n<p>查看当前库下有那些表</p>\n</li>\n<li><p>select database()</p>\n<p>查看当前正在操作的库</p>\n</li>\n<li><p>select user()</p>\n<p>查看当前登录用户</p>\n</li>\n<li><p>select now()</p>\n<p>查询当前系统的日期时间</p>\n</li>\n<li><p>select XXX(now())</p>\n<p>查询当前日期时间的指定字段</p>\n<p>XXX:date&#x2F;time&#x2F;year&#x2F;month&#x2F;day&#x2F;hour&#x2F;minute&#x2F;week&#x2F;second</p>\n</li>\n</ol>\n<h3 id=\"四、SQL语句\"><a href=\"#四、SQL语句\" class=\"headerlink\" title=\"四、SQL语句\"></a>四、SQL语句</h3><p>Structured Query Language(结构化查询语言)</p>\n<p>通过数据库客户端向服务器发送指令来执行建库删库，建表删表以及对表中数据执行增删查改等操作</p>\n<p>sql语句是一门国际化标准语言，各大数据库厂商都会遵循相同的sql标准</p>\n<p>特点：关键字不区分大小写，表中数据区分大小写</p>\n<p>SQL语句分类;</p>\n<ol>\n<li><p>DDL(数据定义语言)</p>\n<p>主要用于对数据库和表的创建删除，以及对表结构的修改</p>\n<ol>\n<li>alter  \t更新(数据库，表，表结构)</li>\n<li>create     创建(数据库，表)</li>\n<li>drop       删除(数据库，表，表中列)</li>\n<li>trunate    表截断(表)</li>\n</ol>\n</li>\n<li><p>DML(数据操作语言)</p>\n<p>主要用于对表中数据执行插入，删除，修改操作</p>\n<ol>\n<li>insert   插入</li>\n<li>delete   删除(删除表中一行数据)</li>\n<li>update   修改</li>\n</ol>\n</li>\n<li><p>DQL(数据查询语言)</p>\n<p>主要用于从表中查询数据</p>\n<ol>\n<li>select\t查询</li>\n</ol>\n</li>\n<li><p>TCL(事务控制语言)</p>\n<p>主要用于控制多个人操作数据库</p>\n<ol>\n<li>set transaction   设置事务</li>\n<li>commit            提交事务</li>\n<li>rollback          回滚事务</li>\n<li>savepoint         设置回滚点</li>\n</ol>\n</li>\n<li><p>DCL(数据控制语言)</p>\n<p>主要用于设置用户的访问权限</p>\n<ol>\n<li>create user\t创建用户</li>\n<li>grant          授权</li>\n<li>revoke         撤销权限</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"五、DDL数据定义语言\"><a href=\"#五、DDL数据定义语言\" class=\"headerlink\" title=\"五、DDL数据定义语言\"></a>五、DDL数据定义语言</h3><ol>\n<li><p>DataBase数据库的创建与删除</p>\n<p>先显示当前数据库系统有那些库(库名不能重复)</p>\n<blockquote>\n<p>show databases；</p>\n</blockquote>\n<p>创建一个数据库，并设置编码方式</p>\n<blockquote>\n<p>create database 库名 default character set utf8；</p>\n<p>create database 库名 charset&#x3D;utf8；</p>\n<p>注意：可以在库名前面添加if not exists判断库是否存在。存在就不创建</p>\n</blockquote>\n<p>删除一个数据库</p>\n<blockquote>\n<p>drop database 库名；</p>\n</blockquote>\n<p>打开&#x2F;切换到某一个库</p>\n<blockquote>\n<p>use 库名；</p>\n</blockquote>\n<p>查看当前正在工作的数据库</p>\n<blockquote>\n<p>select database();</p>\n</blockquote>\n<p>查看数据库的创建过程</p>\n<blockquote>\n<p>show create database 库名；</p>\n</blockquote>\n</li>\n<li><p>Table表格的创建与删除</p>\n<p>表格是关系型数据库中存储数据的最基本单元，表格由行row和列colum组成，其中表头也叫做字段Filed，表中的每一行叫做记录Record</p>\n<p>打开数据库</p>\n<blockquote>\n<p>use 库名</p>\n</blockquote>\n<p>显示当前库下表名不能重复</p>\n<blockquote>\n<p>show tables;</p>\n</blockquote>\n<p>创建一个表</p>\n<blockquote>\n<p>mysql&gt;create table 表名(</p>\n<p>​    -&gt;字段名 字段类型(类型大小)</p>\n<p>);</p>\n</blockquote>\n<blockquote>\n<p>约束Constraint</p>\n<p>注意：</p>\n<p>​\tprimary key\t\t主键</p>\n<p>​\tauto_increment\t 自增</p>\n<p>​\tcomment\t\t\t注释</p>\n<p>​\tnot null\t\t   不能为空</p>\n<p>​\tdefault \t\t   默认值</p>\n<p>​\tunique\t\t\t 唯一的</p>\n<p>​\tforeign key        外键</p>\n</blockquote>\n<p>删除表</p>\n<blockquote>\n<p>drop table 表名；</p>\n</blockquote>\n<p>查看表结构</p>\n<blockquote>\n<p>desc 表名；</p>\n</blockquote>\n<p>查看表的创建过程</p>\n<blockquote>\n<p> show create table 表名；</p>\n</blockquote>\n<p>列添加</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型；</p>\n</blockquote>\n<p>在某一列后添加一列</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型 after 插入在谁后面的列名；</p>\n</blockquote>\n<p>在最前面插入列</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型 first;</p>\n</blockquote>\n<p>列名的修改</p>\n<blockquote>\n<p>alter table 表名 change 旧列名 新列名 类型；</p>\n</blockquote>\n<p>列属性修改</p>\n<blockquote>\n<p>alter table 表名 modify 列名 类型；</p>\n<p>注意：长度由大改小可能会失败</p>\n</blockquote>\n<p>删除列</p>\n<blockquote>\n<p>alter table 表名 drop 列名；</p>\n</blockquote>\n<p>表名修改</p>\n<blockquote>\n<p>alter table 表名 rename to 新表名；</p>\n</blockquote>\n<p>表截断(不能回滚)</p>\n<blockquote>\n<p>truncate table 表名</p>\n</blockquote>\n</li>\n<li><p>表中字段的常用数据类型</p>\n<ol>\n<li><p>数值类型</p>\n<ol>\n<li><p>整数类型</p>\n<ol>\n<li>tinyint\t 1个字节</li>\n<li>smallint    2个字节</li>\n<li>mediumint   3个字节</li>\n<li>int&#x2F;integer 4个字节</li>\n<li>bigint      8个字节</li>\n</ol>\n</li>\n<li><p>浮点类型</p>\n<ol>\n<li><p>float       4个字节</p>\n</li>\n<li><p>double      8个字节</p>\n</li>\n<li><p>decimal(m,d)精确位数，公共m位，精确到小数点后d位</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>字符类型<br>数据库中不区分字符和字符串，字符类型必须使用单引号或者双引号引起来</p>\n<ol>\n<li>char(定长字符类型)不足的会以空格补齐，最多255个字符</li>\n<li>varchar(可变长度字符类型)由多少字符就占多少位置，最多65535字符</li>\n</ol>\n<p>char和varchar的区别：</p>\n<blockquote>\n<ol>\n<li><p>char是定长字符串，查询速度快，但是可能浪费空间，一般列下面的数值长度为定长时使用</p>\n</li>\n<li><p>varchar是变长字符串，可以节约空间，但是查询速度慢，一般列下面数值长度不固定时使用</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>日期时间类型</p>\n<p>在MySQL数据库中日期时间类型都是以特定字符串格式来进行存储的</p>\n<ol>\n<li><p>date</p>\n<p>日期类型，以“yyyy-MM-dd”字符串格式来进行存储</p>\n</li>\n<li><p>time</p>\n<p>时间类型，以“HH:mm:ss”字符串格式来进行存储</p>\n</li>\n<li><p>datetime</p>\n<p>日期时间类型，以“yyyy-MM-dd HH:mm:sss”字符串格式来存储</p>\n</li>\n<li><p>year</p>\n<p>年份类型，以”yyyy“字符串格式来进行存储</p>\n</li>\n<li><p>timestamp</p>\n<p>时间戳类型，以int整数值格式来进行存储</p>\n</li>\n</ol>\n</li>\n<li><p>布尔类型</p>\n<p>   boolean&#x2F;bool</p>\n<p>   只能存储true&#x2F;false两种值，在MySQL底层会自动将boolean类型转成tinyint类型，其他true转为1，false转为0</p>\n</li>\n<li><p>不常用类型</p>\n<blockquote>\n<p>注意：text文本类型和blob二进制类型不建议使用，实际业务中是将数据存储到文件中，然后再将文件的地址存储到数据库中</p>\n</blockquote>\n<ol>\n<li><p>文本类型</p>\n<p>主要用于存储大数据量的文本</p>\n<ol>\n<li>tinytext</li>\n<li>mediumtext</li>\n<li>text</li>\n<li>longtext</li>\n</ol>\n</li>\n<li><p>blob(二进制类型)</p>\n<p>主要用于存储二进制文件</p>\n<p>图片、视频、音频…</p>\n<ol>\n<li>tinyblob</li>\n<li>mediumblob</li>\n<li>blob</li>\n<li>longblob</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"六、DML数据操纵语言\"><a href=\"#六、DML数据操纵语言\" class=\"headerlink\" title=\"六、DML数据操纵语言\"></a>六、DML数据操纵语言</h3><p>主要用于对表中数据执行增删改操作</p>\n<ol>\n<li><p>insert(插入)</p>\n<blockquote>\n<ol>\n<li><p>向所有列下面插入数据(有几列就给几个值)</p>\n<p>insert into 表名 values(值1，值2，值3…)；</p>\n</li>\n<li><p>向部分列下面插入数据(列个数与值个数相等)</p>\n<p>insert into 表名(列1，列2，列3…) values(值1，值2，值3…)</p>\n<p>非空列，如果没有默认值，要主动插入数据</p>\n</li>\n<li><p>同时插入多条数据</p>\n<p>insert into 表名(列1，列2，列3…) </p>\n<p>values(值1，值2，值3…)，(值1，值2，值3…)，(值1，值2，值3…)…</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>update(修改)</p>\n<blockquote>\n<ol>\n<li><p>修改列下面所有的记录(危险操作)</p>\n<p>update 表名 set 列名1&#x3D;值1，列名2&#x3D;值2…；</p>\n</li>\n<li><p>根据条件修改列下面的值</p>\n<p>update 表名 set 列名 &#x3D; 值 where 条件；</p>\n</li>\n<li><p>根据多条件修改下面的值</p>\n<p>update 表名 set 列名&#x3D;值… where 条件1，条件2；</p>\n</li>\n<li><p>条件值为null时</p>\n<p>update 表名 set 列名&#x3D;值… where 条件名 is null；</p>\n</li>\n<li><p>条件的值不为null时</p>\n<p>update 表名 set 列名&#x3D;值… where 条件 is not null；</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>delete(删除)</p>\n<blockquote>\n<ol>\n<li><p>全表删除(禁用)</p>\n<p>delete from 表名；</p>\n</li>\n<li><p>根据条件删除一条记录</p>\n<p>delte from 表名 where 条件；</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"七、DQL数据查询语言\"><a href=\"#七、DQL数据查询语言\" class=\"headerlink\" title=\"七、DQL数据查询语言\"></a>七、DQL数据查询语言</h3><p>主要用于从表中查询数据回来</p>\n<p>导入sql文件</p>\n<blockquote>\n<p>msyql&gt; source XXX.sql</p>\n</blockquote>\n<p>导出sql文件</p>\n<blockquote>\n<p>mysqldump -u用户名-p密码 数据库名 &gt; 导出地址\\数据库名.sql</p>\n</blockquote>\n<ol>\n<li><p>基本查询</p>\n<ol>\n<li><p>全表查询</p>\n<blockquote>\n<p>select * from 表名；</p>\n</blockquote>\n</li>\n<li><p>查询指定数据</p>\n<blockquote>\n<p>select 列名1 列名2 …from 表名；</p>\n</blockquote>\n</li>\n<li><p>对查询出来的列指定列别名</p>\n<blockquote>\n<p>select 列名1 as 别名1，列名2 as 别名2 form 表名；</p>\n</blockquote>\n</li>\n<li><p>去除列下面重复的数据</p>\n<blockquote>\n<p>select distinct 列名 from 表名；</p>\n<p>select distinct 列名1，列名2 from 表名；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>限制查询</p>\n<p>限制查询执行过程：</p>\n<p>执行from 表名-&gt; 执行where 查询限制条件(从上到下做逐行匹配)-&gt;返回true，留下该行记录，返回false过滤改行记录-&gt;执行select 列名1，列名2…从留下的行记录中确定显示的列</p>\n<p>查询比较条件：</p>\n<p>​\t&#x3D;\t&gt;\t&lt;\t&gt;&#x3D;\t&lt;&#x3D;\t!&#x3D;\t&lt;&gt;\tis null\tis not null</p>\n<ol>\n<li><p>根据条件查询指定列名</p>\n<blockquote>\n<p>select 列名，列名2… from 表名 where 条件；</p>\n</blockquote>\n</li>\n<li><p>查询某年的数据大小比较</p>\n<blockquote>\n<p>select 列名1,列名2… from 表名 where 列名 &lt; ‘yyyy-MM-dd’;</p>\n<p>select 列名1,列名2… from 表名 where year(列名) &lt; yyyy;</p>\n</blockquote>\n</li>\n<li><p>查询不是某个部门的</p>\n<blockquote>\n<p>select * from 表名 where 列名 &lt;&gt; ‘值’；</p>\n</blockquote>\n</li>\n<li><p>and 和 or(and优先级比or高，小括号提升优先级)</p>\n<blockquote>\n<p>and:等于&amp;&amp;，查询出来的结果必须同时满足多个条件</p>\n<p>or：等于||，查询出来的结果满足其中一个即可</p>\n</blockquote>\n</li>\n<li><p>any 和all</p>\n<blockquote>\n<p>any：查询的结果值只要满足其中任意一个条件即可</p>\n<p>all：查询的结果值需要同时满足多个条件</p>\n<p>一般配合 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 来进行使用</p>\n<p>select * from 表名 where 查询列 &gt; any(值1，值2…);大于最小值</p>\n<p>select * from 表名 where 查询列 &lt; any(值1，值2…);小于最大值</p>\n<p>select * from 表名 where 查询列 &gt; all(值1，值2…);大于最大值</p>\n<p>select * from 表名 where 查询列 &lt; all(值1，值2…);小于最小值</p>\n</blockquote>\n</li>\n<li><p>值范围查询</p>\n<blockquote>\n<p>select * from 表名 where 查询列 between 值1 and 值2；</p>\n<p>select * from 表名 where 查询列&gt;&#x3D; 值1 and 查询列&lt;&#x3D; 值2；</p>\n<p>不在值1和值2范围内</p>\n<p>select * from 表名 where 查询列 not between 值1 and 值2；</p>\n<p>select * from 表名 where 查询列&lt;值1 or 查询列&gt;值2；</p>\n</blockquote>\n</li>\n<li><p>值列表查询</p>\n<p>判断查询列下面的数据是否在值列表的范围之内，等价于查询列&#x3D;值1 or 查询了&#x3D;值2</p>\n<blockquote>\n<p>select * from 表名 where 查询列 in(值1，值2…)</p>\n</blockquote>\n<p>判断查询列下面的数据是否在值列表的范围之内等价于查询列!&#x3D;值1 or 查询了!&#x3D;值2</p>\n<blockquote>\n<p>select * from 表名 where 查询列 not in(值1，值2…)</p>\n</blockquote>\n<blockquote>\n<p>注意：in和 not in 不能匹配null值，需要使用is null 和is not null</p>\n</blockquote>\n</li>\n<li><p>查询列上使用表达式或函数</p>\n<blockquote>\n<p>表达式：</p>\n<p>​\tselect * from 表名 where 表达式(列名+-*&#x2F;值) &gt; 值；</p>\n<p>​\tselect *,新增列 from 表名 where 表达式(列名+-*&#x2F;值) &gt; 值;</p>\n</blockquote>\n</li>\n<li><p>查询是否包含某个字符</p>\n<blockquote>\n<p>select * from 表名 where 列名 regexp ‘字符’；</p>\n<p>select * from 表名 where 列名 rlike ‘字符’；</p>\n</blockquote>\n</li>\n<li><p>查询某个列的值为null</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from 表名 where 列名 &lt;&#x3D;&gt; null;</p>\n</blockquote>\n</li>\n<li><p>函数</p>\n<ol>\n<li><p>系统函数</p>\n<ol>\n<li>BIN(X) \t \t将X转换为二进制</li>\n<li>BINARY(S)       将字符串s转为二进制字符串</li>\n<li>CAST(X AS type) 转换数据类型</li>\n<li>USER()          返回当前用户</li>\n<li>VERSION()       返回数据库的版本号</li>\n<li>IFNULL(v1,v2)   v1的值为null，返回v1，否则返回v2</li>\n<li>LAST_INSERT_ID()返回插入的最后一条记录的自增长id</li>\n<li>JSON_OBJECT()   将键值对转换为JSON对象</li>\n<li>JSON_ARRAY()    将值转换为JSON数组</li>\n</ol>\n</li>\n<li><p>字符串函数</p>\n<ol>\n<li><p>以字段值:字段值2:字段值3格式显示所有信息</p>\n<blockquote>\n<p>select concat(列名1，’:’,列名2，’:’,….)from 表名；</p>\n<p>select concat_ws(‘:’，列名1,列名2….)from 表名；</p>\n</blockquote>\n</li>\n<li><p>左侧补齐&#x2F;右侧补齐</p>\n<blockquote>\n<p>select lpad(列名，长度，’填补字符’) from 表名；</p>\n<p>select rpad(列名，长度，’填补字符’) from 表名；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>日期函数</p>\n<ol>\n<li><p>查询一个时间段到多少天后的时间</p>\n<blockquote>\n<p>select adddate(起始日期，多少天)；</p>\n<p>select adddate(起始日期，INTERVAl 10 MONTH)；</p>\n</blockquote>\n</li>\n<li><p>计算两个日期直接的时间</p>\n<blockquote>\n<p>select datediff(结束日期，起始日期)；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>数值函数</p>\n<ol>\n<li><p>查询数值四舍五入保留小数点后X位</p>\n<blockquote>\n<p>select 列名，round(列名，X) from 表名；</p>\n</blockquote>\n</li>\n<li><p>查询数值四舍五入不保留小数</p>\n<blockquote>\n<p>select 列名 truncate(列名，1)；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>模糊查询</p>\n<p>只知道查询数据的一部分信息，需要借助like关键字以及%和_两个通配符来完成查询</p>\n<p>%：代表0到多个任意字符，相当于正则表达式.*</p>\n<p>_：代表任意的一个字符，相当于正则表达式.</p>\n</li>\n<li><p>排序查询</p>\n<p>对表中已经查询出来的数据按照从小到大或者从大到小的顺序来进行排序如果和其他限制查询防砸一起使用时，排序查询必须放在最后</p>\n<blockquote>\n<p>select 列名1 列名2… from表名 [限制查询|模糊查询] order by 排序列 [asc(默认升序)]|desc(降序);</p>\n</blockquote>\n</li>\n<li><p>分支查询</p>\n<p>根据列下面的不同的值来执行不同的操作</p>\n<blockquote>\n<p>select 列名1 列名2 case 查询列</p>\n<p>​\twhen 值1 then 操作1</p>\n<p>​\twhen 值2 then 操作2</p>\n<p>​\telse 操作</p>\n<p>​\tend [列别名] </p>\n<p>from 表名；</p>\n<p>null值在排序查询时被当做最小值</p>\n</blockquote>\n</li>\n<li><p>分页查询</p>\n<p>当数据库中数据量比较大的时候，不能一次性把数据库中所有数据都查询回来，这样会增大服务器端的查询和浏览器的展示压力，所以需要使用分页每次查询一批数据回来，MySQL中分页查询需要使用limit关键字完成</p>\n<p>注意：分页查询不是标准的sql，不同的数据库需要使用不同的方式来完成分页</p>\n<p>查询前五条数据</p>\n<blockquote>\n<p>select *from 表名 limit 5；</p>\n</blockquote>\n<p>分页公式：</p>\n<blockquote>\n<p>select * from 表名 limit (page-1)*pageSize，pageSize；</p>\n</blockquote>\n<p>总记录数：</p>\n<blockquote>\n<p>select count(*) from 表名；</p>\n</blockquote>\n</li>\n<li><p>分组查询</p>\n<ol>\n<li><p>单独使用分组函数</p>\n<p>注意：分组函数是根据列下面多个数据经过计算返回一个数据，所以在select后面除了分组查询列外，不能再跟其他列</p>\n<p>分组函数：聚合函数，多行函数</p>\n<p>对表中不能直接体现出来的数据，需要根据列下面的多个值经过计算返回一个值</p>\n<blockquote>\n<p>max()&#x2F;min()</p>\n<p>求最大&#x2F;最小值</p>\n<p>可以对任意数据类型做统计</p>\n</blockquote>\n<p>求某个值的最大值</p>\n<blockquote>\n<p>select 列名1，列名2… 列名X from 表名 where 列名X&#x3D;(select max(列名X) from 表名)；</p>\n</blockquote>\n</li>\n<li><p>单独使用分页查询</p>\n<p>按照列下面不同的值来划分位若干个小组</p>\n<blockquote>\n<p>select 分组列 from 表名 [限制条件] group by 分组列 [having 过滤条件]</p>\n</blockquote>\n<blockquote>\n<p>select year(列名) from 表名 group by year(列名)</p>\n</blockquote>\n</li>\n<li><p>分组函数和分页查询联合在一起使用</p>\n<p>按照列下面不同的值来划分为若干个小组然后再单独使用分组函数来进行查询</p>\n<blockquote>\n<p>select 分组列，分组列2…from 表名 [where 限制条件] group by 分组列 [having]</p>\n</blockquote>\n</li>\n<li><p>sql实际执行顺序</p>\n<blockquote>\n<ol>\n<li>from 表名</li>\n<li>where 限制查询 | 模糊查询</li>\n<li>select 查询列</li>\n<li>group by 分组查询</li>\n<li>having 分组过滤</li>\n<li>order by 排序</li>\n<li>limit 分页</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>子查询(嵌套查询)</p>\n<p>在select查询语句中，where后面的限制条件不是一个确定的值，而是来自于另外一个查询语句的结果那么这套查询语句就被称为子查询，子查询主要是给主查询(父查询)提供数据使用，所以子查询要比主查询先执行，并且子查询必须要带上小括号</p>\n<p>按照子查询返回结果分类：</p>\n<ol>\n<li><p>单行单列子查询</p>\n<p>子查询的结果只有一列，且这一列下面只有一个值，一般可以配合 &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &lt;&#x3D;&gt;等比较运算符来进行使用</p>\n</li>\n<li><p>多行单列子查询</p>\n<p>子查询的结果只有一列，但是这一列下面可能有多个值一般配合any&#x2F;all&#x2F;in来进行使用</p>\n</li>\n<li><p>多行多列子查询</p>\n<p>子查询的返回结果有多个列，每列下面有多个值，一般是将其当做一张表来看待</p>\n</li>\n<li><p>基于子查询复制一张表</p>\n<blockquote>\n<p>create table 新表名 as (select * from 旧表名)；</p>\n</blockquote>\n</li>\n<li><p>子查询的exists(包含)关键字使用</p>\n<p>子查询一般都是跟在where后面，exists后面的子查询只要至少返回一条记录，那么整个条件返回true，如果一条记录都没有，那么整个条件返回false</p>\n<p>exists关键字使用场景:</p>\n<p>当主查询给子查询提供数据使用时，可以使用exists或者not exists关键字</p>\n</li>\n</ol>\n</li>\n<li><p>多表查询</p>\n<p>我们需要查询的数据来自多张表，通常会在两张表之间建立一个关联字段，通过关联字段将两张表链接在一起，然后进行查询，这种关系一般时建立在主表的主键字段和从表的非主键字段之间</p>\n<ol>\n<li><p>关联查询</p>\n<blockquote>\n<p>select 列1，列2… from 表1，表2… where 表1.关联列&#x3D;表2.关联列 and 表2.关联列&#x3D;表3.关联列… [and 限制条件]</p>\n<p>注意：查询列可以来自不同的表。关联查询只会返回两张表中同时满足条件的记录</p>\n<p>做关联查询时，没有指定连接条件那么就会将左侧表中的每一行记录和右侧表中的所有记录从最后一行到第一行做逐行匹配显示，这是一个没有意义的值</p>\n</blockquote>\n</li>\n<li><p>链接查询</p>\n<ol>\n<li><p>内连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 inner join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n<p>注意：内联的查询结果和关联查询是一样的，都是返回两张表中同时满足条件的记录</p>\n</blockquote>\n</li>\n<li><p>外连接</p>\n<p>当从多张表查询数据时，需要返回满足条件的记录，也需要返回不满足的记录</p>\n<p>左外连接：以左侧当做驱动表，右侧表当做匹配表</p>\n<p>右外连接：以右侧表当做驱动表，左侧表当做匹配表，将驱动表中的每一行记录取出来和匹配表中的所有记录从下往上逐一进行匹配，最终会显示驱动表中的所有记录，匹配表中能匹配上的就显示，匹配不上的就显示null</p>\n<ol>\n<li><p>左外连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 left outer join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n<li><p>右外连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 right outer join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n<li><p>查询结果集并集关键字</p>\n<ol>\n<li><p>union</p>\n<p>对两个结果集相同列的数据进行合并去除重复记录</p>\n</li>\n<li><p>union all</p>\n<p>对两个结果集相同列的数据进行合并重复记录</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>自连接</p>\n<p>如果一张表数据之间具有上下级关系，此时我们可以通过表的别名将一张表虚拟成多张表，再通过关联查询或连接查询来查询表中数据</p>\n<blockquote>\n<p>select 列1，列2… from 表1 别名1 left outer join 表1 别名2 on 别名1.关联列&#x3D;别名2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>foreign key  </p>\n<p>为了保证两张表中数据的完整性和一致性，可以再两张表关联字段之间建立一个外键约束关系，将两张表绑定在一起</p>\n<blockquote>\n<p>alter table 副表 add constraint 别名 foreign key (列名) references 主表(列名)；</p>\n</blockquote>\n<blockquote>\n<p>注意：外键的建立会影响数据库的操作性能，因为在执行DML操作时会频繁的查询另外一张表中所有记录，所以不建议在两张表之间建立外键的约束，数据的完整性和一致性由java代码来控制</p>\n</blockquote>\n<blockquote>\n<p>alter table 副表 drop foreign key 外键的别名；</p>\n</blockquote>\n<p>在数据库中除了主键约束之外，其他的三种约束都不需要创建，非空，唯一，外键三个约束作用应该都是用java业务逻辑代码来控制</p>\n</li>\n</ol>\n<h3 id=\"八、TCL事务控制语言\"><a href=\"#八、TCL事务控制语言\" class=\"headerlink\" title=\"八、TCL事务控制语言\"></a>八、TCL事务控制语言</h3><p>为了保证表中数据的安全性和一致性，通常会将若干个DML操作绑定在一起向数据库提交，这些操作要么同时成功，要么同时失败，事务是一组不可分割的逻辑单元</p>\n<ol>\n<li><p>事务的四大特性</p>\n<ol>\n<li><p><strong>原子性Atomicity</strong></p>\n<p>同一个事务内部的操作都是不可分割的</p>\n</li>\n<li><p><strong>一致性Consistency</strong></p>\n<p>事务提交前后，数据库的状态必须是一致的，外界只能读取到事务开启前的状态或事务提交后端而状态，而不能读取到中间的状态</p>\n</li>\n<li><p><strong>隔离性lsolation</strong></p>\n<p>多个用户在操作同一个表中的数据时，每个用户的操作时相互独立的事务，这些事务之间应该相互隔离，彼此不能干扰</p>\n</li>\n<li><p>持久性Durability</p>\n<p>事务一旦被提交后马，对数据库的修改就是永久性的，其他的回滚操作或故障不会对其具有任何影响</p>\n</li>\n</ol>\n</li>\n<li><p>手动事务</p>\n<p>事务的开启和提交需要去手动执行，每执行完一个DML操作后，如果不主动提交事务，那么数据不会持久化到数据库中</p>\n</li>\n<li><p>自动事务</p>\n<p>事务的开启和提交是由数据库自动执行的，只要执行了一个DML操作后，不需要手动提交事务，数据会自动持久化到数据库中</p>\n<p>mysq默认使用的是自动事务，每个事务中只有一条sql语句，所以通常在对mysql执行事务操作时需要将自动事务改为手动事务，方便我们可以去控制一个事务中可以存在多条sql语句，以及事务的开启，提交以及回滚时机</p>\n</li>\n<li><p>事务提交</p>\n<ol>\n<li><p>将自动事务提交改为手动提交</p>\n<blockquote>\n<p>set autocommit &#x3D; 0;</p>\n</blockquote>\n</li>\n<li><p>将事务改为手动提交后，下一条sql语句会自动开启一个事务</p>\n<blockquote>\n<p>例：insert into 表名 values(值1，值2…)；</p>\n<p>注意：在事务提交之前，数据是不会持久化到数据库中，而是存在内存的回滚段内</p>\n</blockquote>\n</li>\n<li><p>提交事务，数据会被持久化到数据中，事务结束</p>\n<blockquote>\n<p>commit;</p>\n</blockquote>\n</li>\n<li><p>事务回滚</p>\n<p>让内存回滚段中操作撤销，事务回滚后，改事务结束</p>\n<blockquote>\n<p>rollback;</p>\n</blockquote>\n</li>\n<li><p>设置回滚点</p>\n<blockquote>\n<p>savepoint 别名；</p>\n<p>SQL语句；</p>\n<p>savepoint 别名2；</p>\n<p>SQL语句；</p>\n<p>…….</p>\n<p>让事务回滚到指定的回滚点</p>\n<p>rollback to 别名；</p>\n<p>注意：回滚到某个回滚点上时，改事务并没有结束，需要rollback或这commit结束事务</p>\n</blockquote>\n</li>\n<li><p>事务在java代码中控制：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    开启事务</span><br><span class=\"line\">    DML....</span><br><span class=\"line\">    DML....</span><br><span class=\"line\">    提交事务</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception)&#123;</span><br><span class=\"line\">    回滚事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事务隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读未提交(read-uncommitted)</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">读已提交（read-committed）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">可重复读（repeatable-read）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">串行化（serializable）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>脏读</p>\n<p>脏读(Dirty Read):当一个事务正在访问数据并对数据做了修改,而这种修改还没有提交到数据库,这时另外一个事务也访问了这个数据,然后使用了这个数据,因为这个数据是还没有提交的操作,那么另外一个事务读到的这个数据就是”脏数据”,依据脏数据所做的操作可能是不正确的<br>如:事务A读取了事务B更新但未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>\n</li>\n<li><p>不可重复读：</p>\n<p>指在一个事务内多次读取同一数据,在这个事务还没有结束时,另外一个事务也访问该数据,那么在第一个事务中的两次读取数据之间,由于第二个事务的修改导致第一个事务两次读取的数据不一致,这就导致了一个事务内两次读取的数据不一致,因此称为不可重复读<br>如:事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>\n</li>\n<li><p>幻读：</p>\n<p>幻读(Phantom Read):幻读与不可重复读类似,他发生在一个事务T1读取了几行数据,接着另外一个并发事务T2插入了一些数据,在随后的查询中,第一个事务就会发现读了一些原本不存在的记录,就好像发生了幻觉一样,所以称为幻读 </p>\n<p>如:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"九、DCL数据控制语言\"><a href=\"#九、DCL数据控制语言\" class=\"headerlink\" title=\"九、DCL数据控制语言\"></a>九、DCL数据控制语言</h3><p>主要用于管理数据库用户以及控制数据的访问控制权限</p>\n<p>只是由DBA来进行的操作</p>\n<ol>\n<li><p>用户管理</p>\n<ol>\n<li><p>查询用户</p>\n<blockquote>\n<p>use mysql;</p>\n<p>select * from user\\G;</p>\n</blockquote>\n</li>\n<li><p>新建用户</p>\n<blockquote>\n<p>create user ‘用户名‘@’主机名’ identified by ‘密码’;</p>\n<p>注意：主机名为localhost&#x2F;%，localhost为本地访问，%为多用户远程访问，单用户远程访问为指定ip地址</p>\n</blockquote>\n</li>\n<li><p>修改密码</p>\n<blockquote>\n<p>alter user ‘用户名‘@’主机名’ identified with mysql_native_password by ‘新密码’；</p>\n</blockquote>\n</li>\n<li><p>删除指定用户</p>\n<blockquote>\n<p>drop user ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>权限管理</p>\n<p>mysql中定义了很多权限，但是常用的只有一下几种</p>\n<ol>\n<li>ALL&#x2F;All Privileges\t 所有权</li>\n<li>select                 查询权限</li>\n<li>insert                 添加权限</li>\n<li>update                 修改权限</li>\n<li>delete                 删除权限</li>\n<li>drop                   删除库&#x2F;表&#x2F;表结构&#x2F;视图权限</li>\n<li>create                 创建库&#x2F;表权限</li>\n</ol>\n<blockquote>\n<p>查询授予用户的权限</p>\n<p>show grants for ‘用户名‘@’主机名’</p>\n</blockquote>\n</li>\n<li><p>授予权限</p>\n<blockquote>\n<p>grant 权限1，权限2… on 数据库名.表名 to ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n<li><p>撤销权限</p>\n<blockquote>\n<p>revoke 权限1，权限2… on数据库名.表名 from ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"十、表于表之间的关系\"><a href=\"#十、表于表之间的关系\" class=\"headerlink\" title=\"十、表于表之间的关系\"></a>十、表于表之间的关系</h3><ol>\n<li><p>一对多，多对一(one-to-many  many-to-one)</p>\n<p>表设计：在多方表中添加一个外键列，去关联一方表的主键列</p>\n<p>案例：一个部门多个员工</p>\n</li>\n<li><p>一对一(one-to-one)</p>\n<p>案例：一个公司发行一种股票</p>\n<ol>\n<li>单向主键关联</li>\n<li>双向主键关联</li>\n<li>单向外键关联</li>\n<li>双向外键关联</li>\n</ol>\n</li>\n<li><p>多对多(many-to-many)</p>\n<p>表设计：创建一张中间表，用于存储两张多方表的主键</p>\n<p>案例：一个学生对应多个老师，一个老师对应多个学生吧</p>\n</li>\n</ol>\n<h3 id=\"十一、ER图\"><a href=\"#十一、ER图\" class=\"headerlink\" title=\"十一、ER图\"></a>十一、ER图</h3><p>Entity-relationship  实体关系图</p>\n<p>主要用于描述数据库中表与表之间得关系</p>\n<ol>\n<li><p>实体Entity</p>\n<p>数据模型中实体对象(表),使用长方形表示</p>\n</li>\n<li><p>属性Attribute</p>\n<p>实体对象得属性(字段)使用椭圆形表示</p>\n</li>\n<li><p>关系Relationship</p>\n<p>实体对象之间得关系(表与表之间得关系)，使用菱形表示</p>\n</li>\n</ol>\n<h3 id=\"十二、数据表设计得三大范式\"><a href=\"#十二、数据表设计得三大范式\" class=\"headerlink\" title=\"十二、数据表设计得三大范式\"></a>十二、数据表设计得三大范式</h3><p>为了建立结构合理，数据冗余较小得表，所以数据表在设计时要遵循相应得原则，也就是范式</p>\n<ol>\n<li>保证数据表中每一列得原子性，每一列下面得数据不能再拆分</li>\n<li>非主键字段不能部分依赖主键字段确保表中的每一列要和主键列直接关联</li>\n<li>确保表中的每一列和主键列都素hi直接关联关系，而不是间接关联，不能存在传递依赖</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h3 id=\"一、数据库概念\"><a href=\"#一、数据库概念\" class=\"headerlink\" title=\"一、数据库概念\"></a>一、数据库概念</h3><p>DataBase：以表的数据结构形式来对程序产生的数据进行结构化存储和管理的数据仓库</p>\n<p>DBMS：DataBase Manager Service</p>\n<p>数据库管理系统</p>\n<ol>\n<li><p>数据库服务器</p>\n<p>负责永久性存储管理以及维护数据</p>\n<p>在一个MySQL数据库服务器中可以存在多个数据库，互相之间名称不能重复</p>\n</li>\n<li><p>数据库客户端</p>\n<p>通过ip和端口号链接上数据库服务器，通过账号密码进行登录，登录成功后就可以向数据库服务器发送sql指令来操作数据库服务器端的数据，并呈现操作结果</p>\n<p>客户端：</p>\n<ol>\n<li>cmd命令行</li>\n<li>图形界面（navicat…）</li>\n<li>Java代码(JDBC,mybatis…)</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"二、数据库分类\"><a href=\"#二、数据库分类\" class=\"headerlink\" title=\"二、数据库分类\"></a>二、数据库分类</h3><p>1、<strong>关系型数据库</strong></p>\n<p>使用一张二维表来存储数据，表中列与列之间有关系，同一个库中表和表之间也可以存在关系</p>\n<ol>\n<li><p>Oracle</p>\n<p>甲骨文公司产品，第一款大型关系型数据库</p>\n<p>个人免费，公司收费</p>\n</li>\n<li><p>DB2</p>\n<p>IBM公司大型关系型数据库</p>\n<p>跨平台性好</p>\n</li>\n<li><p>SqlServer</p>\n<p>微软公司大型关系型数据库</p>\n<p>对windows平台支持比较好</p>\n</li>\n<li><p>MySQL</p>\n<p>小型关系型数据库</p>\n<p>免费开源(非核心代码)</p>\n</li>\n<li><p>sqlite</p>\n<p>小型关系型数据库，主要应用于移动设备上，可以用于存储联系人，短信，图片等信息</p>\n</li>\n</ol>\n<p>2、<strong>非关系型数据库</strong></p>\n<p>主要是以key-value键值对的形式来对数据进行存储，元素和元素之间没有关系，主要用于充当缓存</p>\n<ol>\n<li>redis</li>\n<li>memcached</li>\n<li>mongodb</li>\n</ol>\n<h3 id=\"三、数据库基本命令\"><a href=\"#三、数据库基本命令\" class=\"headerlink\" title=\"三、数据库基本命令\"></a>三、数据库基本命令</h3><ol>\n<li><p>status</p>\n<p>显示当前数据库系统的相关信息</p>\n</li>\n<li><p>show databases;</p>\n<p>查看当前数据库系统中有那些库</p>\n</li>\n<li><p>use 库名</p>\n<p>打开&#x2F;切换到某一个库中</p>\n</li>\n<li><p>show tables;</p>\n<p>查看当前库下有那些表</p>\n</li>\n<li><p>select database()</p>\n<p>查看当前正在操作的库</p>\n</li>\n<li><p>select user()</p>\n<p>查看当前登录用户</p>\n</li>\n<li><p>select now()</p>\n<p>查询当前系统的日期时间</p>\n</li>\n<li><p>select XXX(now())</p>\n<p>查询当前日期时间的指定字段</p>\n<p>XXX:date&#x2F;time&#x2F;year&#x2F;month&#x2F;day&#x2F;hour&#x2F;minute&#x2F;week&#x2F;second</p>\n</li>\n</ol>\n<h3 id=\"四、SQL语句\"><a href=\"#四、SQL语句\" class=\"headerlink\" title=\"四、SQL语句\"></a>四、SQL语句</h3><p>Structured Query Language(结构化查询语言)</p>\n<p>通过数据库客户端向服务器发送指令来执行建库删库，建表删表以及对表中数据执行增删查改等操作</p>\n<p>sql语句是一门国际化标准语言，各大数据库厂商都会遵循相同的sql标准</p>\n<p>特点：关键字不区分大小写，表中数据区分大小写</p>\n<p>SQL语句分类;</p>\n<ol>\n<li><p>DDL(数据定义语言)</p>\n<p>主要用于对数据库和表的创建删除，以及对表结构的修改</p>\n<ol>\n<li>alter  \t更新(数据库，表，表结构)</li>\n<li>create     创建(数据库，表)</li>\n<li>drop       删除(数据库，表，表中列)</li>\n<li>trunate    表截断(表)</li>\n</ol>\n</li>\n<li><p>DML(数据操作语言)</p>\n<p>主要用于对表中数据执行插入，删除，修改操作</p>\n<ol>\n<li>insert   插入</li>\n<li>delete   删除(删除表中一行数据)</li>\n<li>update   修改</li>\n</ol>\n</li>\n<li><p>DQL(数据查询语言)</p>\n<p>主要用于从表中查询数据</p>\n<ol>\n<li>select\t查询</li>\n</ol>\n</li>\n<li><p>TCL(事务控制语言)</p>\n<p>主要用于控制多个人操作数据库</p>\n<ol>\n<li>set transaction   设置事务</li>\n<li>commit            提交事务</li>\n<li>rollback          回滚事务</li>\n<li>savepoint         设置回滚点</li>\n</ol>\n</li>\n<li><p>DCL(数据控制语言)</p>\n<p>主要用于设置用户的访问权限</p>\n<ol>\n<li>create user\t创建用户</li>\n<li>grant          授权</li>\n<li>revoke         撤销权限</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"五、DDL数据定义语言\"><a href=\"#五、DDL数据定义语言\" class=\"headerlink\" title=\"五、DDL数据定义语言\"></a>五、DDL数据定义语言</h3><ol>\n<li><p>DataBase数据库的创建与删除</p>\n<p>先显示当前数据库系统有那些库(库名不能重复)</p>\n<blockquote>\n<p>show databases；</p>\n</blockquote>\n<p>创建一个数据库，并设置编码方式</p>\n<blockquote>\n<p>create database 库名 default character set utf8；</p>\n<p>create database 库名 charset&#x3D;utf8；</p>\n<p>注意：可以在库名前面添加if not exists判断库是否存在。存在就不创建</p>\n</blockquote>\n<p>删除一个数据库</p>\n<blockquote>\n<p>drop database 库名；</p>\n</blockquote>\n<p>打开&#x2F;切换到某一个库</p>\n<blockquote>\n<p>use 库名；</p>\n</blockquote>\n<p>查看当前正在工作的数据库</p>\n<blockquote>\n<p>select database();</p>\n</blockquote>\n<p>查看数据库的创建过程</p>\n<blockquote>\n<p>show create database 库名；</p>\n</blockquote>\n</li>\n<li><p>Table表格的创建与删除</p>\n<p>表格是关系型数据库中存储数据的最基本单元，表格由行row和列colum组成，其中表头也叫做字段Filed，表中的每一行叫做记录Record</p>\n<p>打开数据库</p>\n<blockquote>\n<p>use 库名</p>\n</blockquote>\n<p>显示当前库下表名不能重复</p>\n<blockquote>\n<p>show tables;</p>\n</blockquote>\n<p>创建一个表</p>\n<blockquote>\n<p>mysql&gt;create table 表名(</p>\n<p>​    -&gt;字段名 字段类型(类型大小)</p>\n<p>);</p>\n</blockquote>\n<blockquote>\n<p>约束Constraint</p>\n<p>注意：</p>\n<p>​\tprimary key\t\t主键</p>\n<p>​\tauto_increment\t 自增</p>\n<p>​\tcomment\t\t\t注释</p>\n<p>​\tnot null\t\t   不能为空</p>\n<p>​\tdefault \t\t   默认值</p>\n<p>​\tunique\t\t\t 唯一的</p>\n<p>​\tforeign key        外键</p>\n</blockquote>\n<p>删除表</p>\n<blockquote>\n<p>drop table 表名；</p>\n</blockquote>\n<p>查看表结构</p>\n<blockquote>\n<p>desc 表名；</p>\n</blockquote>\n<p>查看表的创建过程</p>\n<blockquote>\n<p> show create table 表名；</p>\n</blockquote>\n<p>列添加</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型；</p>\n</blockquote>\n<p>在某一列后添加一列</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型 after 插入在谁后面的列名；</p>\n</blockquote>\n<p>在最前面插入列</p>\n<blockquote>\n<p>alter table 表名 add 列名 类型 first;</p>\n</blockquote>\n<p>列名的修改</p>\n<blockquote>\n<p>alter table 表名 change 旧列名 新列名 类型；</p>\n</blockquote>\n<p>列属性修改</p>\n<blockquote>\n<p>alter table 表名 modify 列名 类型；</p>\n<p>注意：长度由大改小可能会失败</p>\n</blockquote>\n<p>删除列</p>\n<blockquote>\n<p>alter table 表名 drop 列名；</p>\n</blockquote>\n<p>表名修改</p>\n<blockquote>\n<p>alter table 表名 rename to 新表名；</p>\n</blockquote>\n<p>表截断(不能回滚)</p>\n<blockquote>\n<p>truncate table 表名</p>\n</blockquote>\n</li>\n<li><p>表中字段的常用数据类型</p>\n<ol>\n<li><p>数值类型</p>\n<ol>\n<li><p>整数类型</p>\n<ol>\n<li>tinyint\t 1个字节</li>\n<li>smallint    2个字节</li>\n<li>mediumint   3个字节</li>\n<li>int&#x2F;integer 4个字节</li>\n<li>bigint      8个字节</li>\n</ol>\n</li>\n<li><p>浮点类型</p>\n<ol>\n<li><p>float       4个字节</p>\n</li>\n<li><p>double      8个字节</p>\n</li>\n<li><p>decimal(m,d)精确位数，公共m位，精确到小数点后d位</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>字符类型<br>数据库中不区分字符和字符串，字符类型必须使用单引号或者双引号引起来</p>\n<ol>\n<li>char(定长字符类型)不足的会以空格补齐，最多255个字符</li>\n<li>varchar(可变长度字符类型)由多少字符就占多少位置，最多65535字符</li>\n</ol>\n<p>char和varchar的区别：</p>\n<blockquote>\n<ol>\n<li><p>char是定长字符串，查询速度快，但是可能浪费空间，一般列下面的数值长度为定长时使用</p>\n</li>\n<li><p>varchar是变长字符串，可以节约空间，但是查询速度慢，一般列下面数值长度不固定时使用</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>日期时间类型</p>\n<p>在MySQL数据库中日期时间类型都是以特定字符串格式来进行存储的</p>\n<ol>\n<li><p>date</p>\n<p>日期类型，以“yyyy-MM-dd”字符串格式来进行存储</p>\n</li>\n<li><p>time</p>\n<p>时间类型，以“HH:mm:ss”字符串格式来进行存储</p>\n</li>\n<li><p>datetime</p>\n<p>日期时间类型，以“yyyy-MM-dd HH:mm:sss”字符串格式来存储</p>\n</li>\n<li><p>year</p>\n<p>年份类型，以”yyyy“字符串格式来进行存储</p>\n</li>\n<li><p>timestamp</p>\n<p>时间戳类型，以int整数值格式来进行存储</p>\n</li>\n</ol>\n</li>\n<li><p>布尔类型</p>\n<p>   boolean&#x2F;bool</p>\n<p>   只能存储true&#x2F;false两种值，在MySQL底层会自动将boolean类型转成tinyint类型，其他true转为1，false转为0</p>\n</li>\n<li><p>不常用类型</p>\n<blockquote>\n<p>注意：text文本类型和blob二进制类型不建议使用，实际业务中是将数据存储到文件中，然后再将文件的地址存储到数据库中</p>\n</blockquote>\n<ol>\n<li><p>文本类型</p>\n<p>主要用于存储大数据量的文本</p>\n<ol>\n<li>tinytext</li>\n<li>mediumtext</li>\n<li>text</li>\n<li>longtext</li>\n</ol>\n</li>\n<li><p>blob(二进制类型)</p>\n<p>主要用于存储二进制文件</p>\n<p>图片、视频、音频…</p>\n<ol>\n<li>tinyblob</li>\n<li>mediumblob</li>\n<li>blob</li>\n<li>longblob</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"六、DML数据操纵语言\"><a href=\"#六、DML数据操纵语言\" class=\"headerlink\" title=\"六、DML数据操纵语言\"></a>六、DML数据操纵语言</h3><p>主要用于对表中数据执行增删改操作</p>\n<ol>\n<li><p>insert(插入)</p>\n<blockquote>\n<ol>\n<li><p>向所有列下面插入数据(有几列就给几个值)</p>\n<p>insert into 表名 values(值1，值2，值3…)；</p>\n</li>\n<li><p>向部分列下面插入数据(列个数与值个数相等)</p>\n<p>insert into 表名(列1，列2，列3…) values(值1，值2，值3…)</p>\n<p>非空列，如果没有默认值，要主动插入数据</p>\n</li>\n<li><p>同时插入多条数据</p>\n<p>insert into 表名(列1，列2，列3…) </p>\n<p>values(值1，值2，值3…)，(值1，值2，值3…)，(值1，值2，值3…)…</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>update(修改)</p>\n<blockquote>\n<ol>\n<li><p>修改列下面所有的记录(危险操作)</p>\n<p>update 表名 set 列名1&#x3D;值1，列名2&#x3D;值2…；</p>\n</li>\n<li><p>根据条件修改列下面的值</p>\n<p>update 表名 set 列名 &#x3D; 值 where 条件；</p>\n</li>\n<li><p>根据多条件修改下面的值</p>\n<p>update 表名 set 列名&#x3D;值… where 条件1，条件2；</p>\n</li>\n<li><p>条件值为null时</p>\n<p>update 表名 set 列名&#x3D;值… where 条件名 is null；</p>\n</li>\n<li><p>条件的值不为null时</p>\n<p>update 表名 set 列名&#x3D;值… where 条件 is not null；</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>delete(删除)</p>\n<blockquote>\n<ol>\n<li><p>全表删除(禁用)</p>\n<p>delete from 表名；</p>\n</li>\n<li><p>根据条件删除一条记录</p>\n<p>delte from 表名 where 条件；</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"七、DQL数据查询语言\"><a href=\"#七、DQL数据查询语言\" class=\"headerlink\" title=\"七、DQL数据查询语言\"></a>七、DQL数据查询语言</h3><p>主要用于从表中查询数据回来</p>\n<p>导入sql文件</p>\n<blockquote>\n<p>msyql&gt; source XXX.sql</p>\n</blockquote>\n<p>导出sql文件</p>\n<blockquote>\n<p>mysqldump -u用户名-p密码 数据库名 &gt; 导出地址\\数据库名.sql</p>\n</blockquote>\n<ol>\n<li><p>基本查询</p>\n<ol>\n<li><p>全表查询</p>\n<blockquote>\n<p>select * from 表名；</p>\n</blockquote>\n</li>\n<li><p>查询指定数据</p>\n<blockquote>\n<p>select 列名1 列名2 …from 表名；</p>\n</blockquote>\n</li>\n<li><p>对查询出来的列指定列别名</p>\n<blockquote>\n<p>select 列名1 as 别名1，列名2 as 别名2 form 表名；</p>\n</blockquote>\n</li>\n<li><p>去除列下面重复的数据</p>\n<blockquote>\n<p>select distinct 列名 from 表名；</p>\n<p>select distinct 列名1，列名2 from 表名；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>限制查询</p>\n<p>限制查询执行过程：</p>\n<p>执行from 表名-&gt; 执行where 查询限制条件(从上到下做逐行匹配)-&gt;返回true，留下该行记录，返回false过滤改行记录-&gt;执行select 列名1，列名2…从留下的行记录中确定显示的列</p>\n<p>查询比较条件：</p>\n<p>​\t&#x3D;\t&gt;\t&lt;\t&gt;&#x3D;\t&lt;&#x3D;\t!&#x3D;\t&lt;&gt;\tis null\tis not null</p>\n<ol>\n<li><p>根据条件查询指定列名</p>\n<blockquote>\n<p>select 列名，列名2… from 表名 where 条件；</p>\n</blockquote>\n</li>\n<li><p>查询某年的数据大小比较</p>\n<blockquote>\n<p>select 列名1,列名2… from 表名 where 列名 &lt; ‘yyyy-MM-dd’;</p>\n<p>select 列名1,列名2… from 表名 where year(列名) &lt; yyyy;</p>\n</blockquote>\n</li>\n<li><p>查询不是某个部门的</p>\n<blockquote>\n<p>select * from 表名 where 列名 &lt;&gt; ‘值’；</p>\n</blockquote>\n</li>\n<li><p>and 和 or(and优先级比or高，小括号提升优先级)</p>\n<blockquote>\n<p>and:等于&amp;&amp;，查询出来的结果必须同时满足多个条件</p>\n<p>or：等于||，查询出来的结果满足其中一个即可</p>\n</blockquote>\n</li>\n<li><p>any 和all</p>\n<blockquote>\n<p>any：查询的结果值只要满足其中任意一个条件即可</p>\n<p>all：查询的结果值需要同时满足多个条件</p>\n<p>一般配合 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 来进行使用</p>\n<p>select * from 表名 where 查询列 &gt; any(值1，值2…);大于最小值</p>\n<p>select * from 表名 where 查询列 &lt; any(值1，值2…);小于最大值</p>\n<p>select * from 表名 where 查询列 &gt; all(值1，值2…);大于最大值</p>\n<p>select * from 表名 where 查询列 &lt; all(值1，值2…);小于最小值</p>\n</blockquote>\n</li>\n<li><p>值范围查询</p>\n<blockquote>\n<p>select * from 表名 where 查询列 between 值1 and 值2；</p>\n<p>select * from 表名 where 查询列&gt;&#x3D; 值1 and 查询列&lt;&#x3D; 值2；</p>\n<p>不在值1和值2范围内</p>\n<p>select * from 表名 where 查询列 not between 值1 and 值2；</p>\n<p>select * from 表名 where 查询列&lt;值1 or 查询列&gt;值2；</p>\n</blockquote>\n</li>\n<li><p>值列表查询</p>\n<p>判断查询列下面的数据是否在值列表的范围之内，等价于查询列&#x3D;值1 or 查询了&#x3D;值2</p>\n<blockquote>\n<p>select * from 表名 where 查询列 in(值1，值2…)</p>\n</blockquote>\n<p>判断查询列下面的数据是否在值列表的范围之内等价于查询列!&#x3D;值1 or 查询了!&#x3D;值2</p>\n<blockquote>\n<p>select * from 表名 where 查询列 not in(值1，值2…)</p>\n</blockquote>\n<blockquote>\n<p>注意：in和 not in 不能匹配null值，需要使用is null 和is not null</p>\n</blockquote>\n</li>\n<li><p>查询列上使用表达式或函数</p>\n<blockquote>\n<p>表达式：</p>\n<p>​\tselect * from 表名 where 表达式(列名+-*&#x2F;值) &gt; 值；</p>\n<p>​\tselect *,新增列 from 表名 where 表达式(列名+-*&#x2F;值) &gt; 值;</p>\n</blockquote>\n</li>\n<li><p>查询是否包含某个字符</p>\n<blockquote>\n<p>select * from 表名 where 列名 regexp ‘字符’；</p>\n<p>select * from 表名 where 列名 rlike ‘字符’；</p>\n</blockquote>\n</li>\n<li><p>查询某个列的值为null</p>\n</li>\n</ol>\n<blockquote>\n<p>select * from 表名 where 列名 &lt;&#x3D;&gt; null;</p>\n</blockquote>\n</li>\n<li><p>函数</p>\n<ol>\n<li><p>系统函数</p>\n<ol>\n<li>BIN(X) \t \t将X转换为二进制</li>\n<li>BINARY(S)       将字符串s转为二进制字符串</li>\n<li>CAST(X AS type) 转换数据类型</li>\n<li>USER()          返回当前用户</li>\n<li>VERSION()       返回数据库的版本号</li>\n<li>IFNULL(v1,v2)   v1的值为null，返回v1，否则返回v2</li>\n<li>LAST_INSERT_ID()返回插入的最后一条记录的自增长id</li>\n<li>JSON_OBJECT()   将键值对转换为JSON对象</li>\n<li>JSON_ARRAY()    将值转换为JSON数组</li>\n</ol>\n</li>\n<li><p>字符串函数</p>\n<ol>\n<li><p>以字段值:字段值2:字段值3格式显示所有信息</p>\n<blockquote>\n<p>select concat(列名1，’:’,列名2，’:’,….)from 表名；</p>\n<p>select concat_ws(‘:’，列名1,列名2….)from 表名；</p>\n</blockquote>\n</li>\n<li><p>左侧补齐&#x2F;右侧补齐</p>\n<blockquote>\n<p>select lpad(列名，长度，’填补字符’) from 表名；</p>\n<p>select rpad(列名，长度，’填补字符’) from 表名；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>日期函数</p>\n<ol>\n<li><p>查询一个时间段到多少天后的时间</p>\n<blockquote>\n<p>select adddate(起始日期，多少天)；</p>\n<p>select adddate(起始日期，INTERVAl 10 MONTH)；</p>\n</blockquote>\n</li>\n<li><p>计算两个日期直接的时间</p>\n<blockquote>\n<p>select datediff(结束日期，起始日期)；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>数值函数</p>\n<ol>\n<li><p>查询数值四舍五入保留小数点后X位</p>\n<blockquote>\n<p>select 列名，round(列名，X) from 表名；</p>\n</blockquote>\n</li>\n<li><p>查询数值四舍五入不保留小数</p>\n<blockquote>\n<p>select 列名 truncate(列名，1)；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>模糊查询</p>\n<p>只知道查询数据的一部分信息，需要借助like关键字以及%和_两个通配符来完成查询</p>\n<p>%：代表0到多个任意字符，相当于正则表达式.*</p>\n<p>_：代表任意的一个字符，相当于正则表达式.</p>\n</li>\n<li><p>排序查询</p>\n<p>对表中已经查询出来的数据按照从小到大或者从大到小的顺序来进行排序如果和其他限制查询防砸一起使用时，排序查询必须放在最后</p>\n<blockquote>\n<p>select 列名1 列名2… from表名 [限制查询|模糊查询] order by 排序列 [asc(默认升序)]|desc(降序);</p>\n</blockquote>\n</li>\n<li><p>分支查询</p>\n<p>根据列下面的不同的值来执行不同的操作</p>\n<blockquote>\n<p>select 列名1 列名2 case 查询列</p>\n<p>​\twhen 值1 then 操作1</p>\n<p>​\twhen 值2 then 操作2</p>\n<p>​\telse 操作</p>\n<p>​\tend [列别名] </p>\n<p>from 表名；</p>\n<p>null值在排序查询时被当做最小值</p>\n</blockquote>\n</li>\n<li><p>分页查询</p>\n<p>当数据库中数据量比较大的时候，不能一次性把数据库中所有数据都查询回来，这样会增大服务器端的查询和浏览器的展示压力，所以需要使用分页每次查询一批数据回来，MySQL中分页查询需要使用limit关键字完成</p>\n<p>注意：分页查询不是标准的sql，不同的数据库需要使用不同的方式来完成分页</p>\n<p>查询前五条数据</p>\n<blockquote>\n<p>select *from 表名 limit 5；</p>\n</blockquote>\n<p>分页公式：</p>\n<blockquote>\n<p>select * from 表名 limit (page-1)*pageSize，pageSize；</p>\n</blockquote>\n<p>总记录数：</p>\n<blockquote>\n<p>select count(*) from 表名；</p>\n</blockquote>\n</li>\n<li><p>分组查询</p>\n<ol>\n<li><p>单独使用分组函数</p>\n<p>注意：分组函数是根据列下面多个数据经过计算返回一个数据，所以在select后面除了分组查询列外，不能再跟其他列</p>\n<p>分组函数：聚合函数，多行函数</p>\n<p>对表中不能直接体现出来的数据，需要根据列下面的多个值经过计算返回一个值</p>\n<blockquote>\n<p>max()&#x2F;min()</p>\n<p>求最大&#x2F;最小值</p>\n<p>可以对任意数据类型做统计</p>\n</blockquote>\n<p>求某个值的最大值</p>\n<blockquote>\n<p>select 列名1，列名2… 列名X from 表名 where 列名X&#x3D;(select max(列名X) from 表名)；</p>\n</blockquote>\n</li>\n<li><p>单独使用分页查询</p>\n<p>按照列下面不同的值来划分位若干个小组</p>\n<blockquote>\n<p>select 分组列 from 表名 [限制条件] group by 分组列 [having 过滤条件]</p>\n</blockquote>\n<blockquote>\n<p>select year(列名) from 表名 group by year(列名)</p>\n</blockquote>\n</li>\n<li><p>分组函数和分页查询联合在一起使用</p>\n<p>按照列下面不同的值来划分为若干个小组然后再单独使用分组函数来进行查询</p>\n<blockquote>\n<p>select 分组列，分组列2…from 表名 [where 限制条件] group by 分组列 [having]</p>\n</blockquote>\n</li>\n<li><p>sql实际执行顺序</p>\n<blockquote>\n<ol>\n<li>from 表名</li>\n<li>where 限制查询 | 模糊查询</li>\n<li>select 查询列</li>\n<li>group by 分组查询</li>\n<li>having 分组过滤</li>\n<li>order by 排序</li>\n<li>limit 分页</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>子查询(嵌套查询)</p>\n<p>在select查询语句中，where后面的限制条件不是一个确定的值，而是来自于另外一个查询语句的结果那么这套查询语句就被称为子查询，子查询主要是给主查询(父查询)提供数据使用，所以子查询要比主查询先执行，并且子查询必须要带上小括号</p>\n<p>按照子查询返回结果分类：</p>\n<ol>\n<li><p>单行单列子查询</p>\n<p>子查询的结果只有一列，且这一列下面只有一个值，一般可以配合 &gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &lt;&#x3D;&gt;等比较运算符来进行使用</p>\n</li>\n<li><p>多行单列子查询</p>\n<p>子查询的结果只有一列，但是这一列下面可能有多个值一般配合any&#x2F;all&#x2F;in来进行使用</p>\n</li>\n<li><p>多行多列子查询</p>\n<p>子查询的返回结果有多个列，每列下面有多个值，一般是将其当做一张表来看待</p>\n</li>\n<li><p>基于子查询复制一张表</p>\n<blockquote>\n<p>create table 新表名 as (select * from 旧表名)；</p>\n</blockquote>\n</li>\n<li><p>子查询的exists(包含)关键字使用</p>\n<p>子查询一般都是跟在where后面，exists后面的子查询只要至少返回一条记录，那么整个条件返回true，如果一条记录都没有，那么整个条件返回false</p>\n<p>exists关键字使用场景:</p>\n<p>当主查询给子查询提供数据使用时，可以使用exists或者not exists关键字</p>\n</li>\n</ol>\n</li>\n<li><p>多表查询</p>\n<p>我们需要查询的数据来自多张表，通常会在两张表之间建立一个关联字段，通过关联字段将两张表链接在一起，然后进行查询，这种关系一般时建立在主表的主键字段和从表的非主键字段之间</p>\n<ol>\n<li><p>关联查询</p>\n<blockquote>\n<p>select 列1，列2… from 表1，表2… where 表1.关联列&#x3D;表2.关联列 and 表2.关联列&#x3D;表3.关联列… [and 限制条件]</p>\n<p>注意：查询列可以来自不同的表。关联查询只会返回两张表中同时满足条件的记录</p>\n<p>做关联查询时，没有指定连接条件那么就会将左侧表中的每一行记录和右侧表中的所有记录从最后一行到第一行做逐行匹配显示，这是一个没有意义的值</p>\n</blockquote>\n</li>\n<li><p>链接查询</p>\n<ol>\n<li><p>内连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 inner join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n<p>注意：内联的查询结果和关联查询是一样的，都是返回两张表中同时满足条件的记录</p>\n</blockquote>\n</li>\n<li><p>外连接</p>\n<p>当从多张表查询数据时，需要返回满足条件的记录，也需要返回不满足的记录</p>\n<p>左外连接：以左侧当做驱动表，右侧表当做匹配表</p>\n<p>右外连接：以右侧表当做驱动表，左侧表当做匹配表，将驱动表中的每一行记录取出来和匹配表中的所有记录从下往上逐一进行匹配，最终会显示驱动表中的所有记录，匹配表中能匹配上的就显示，匹配不上的就显示null</p>\n<ol>\n<li><p>左外连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 left outer join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n<li><p>右外连接</p>\n<blockquote>\n<p>select 列1，列2… from 表1 right outer join 表2 on 表1.关联列&#x3D;表2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n<li><p>查询结果集并集关键字</p>\n<ol>\n<li><p>union</p>\n<p>对两个结果集相同列的数据进行合并去除重复记录</p>\n</li>\n<li><p>union all</p>\n<p>对两个结果集相同列的数据进行合并重复记录</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>自连接</p>\n<p>如果一张表数据之间具有上下级关系，此时我们可以通过表的别名将一张表虚拟成多张表，再通过关联查询或连接查询来查询表中数据</p>\n<blockquote>\n<p>select 列1，列2… from 表1 别名1 left outer join 表1 别名2 on 别名1.关联列&#x3D;别名2.关联列… [where 限制条件]</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>foreign key  </p>\n<p>为了保证两张表中数据的完整性和一致性，可以再两张表关联字段之间建立一个外键约束关系，将两张表绑定在一起</p>\n<blockquote>\n<p>alter table 副表 add constraint 别名 foreign key (列名) references 主表(列名)；</p>\n</blockquote>\n<blockquote>\n<p>注意：外键的建立会影响数据库的操作性能，因为在执行DML操作时会频繁的查询另外一张表中所有记录，所以不建议在两张表之间建立外键的约束，数据的完整性和一致性由java代码来控制</p>\n</blockquote>\n<blockquote>\n<p>alter table 副表 drop foreign key 外键的别名；</p>\n</blockquote>\n<p>在数据库中除了主键约束之外，其他的三种约束都不需要创建，非空，唯一，外键三个约束作用应该都是用java业务逻辑代码来控制</p>\n</li>\n</ol>\n<h3 id=\"八、TCL事务控制语言\"><a href=\"#八、TCL事务控制语言\" class=\"headerlink\" title=\"八、TCL事务控制语言\"></a>八、TCL事务控制语言</h3><p>为了保证表中数据的安全性和一致性，通常会将若干个DML操作绑定在一起向数据库提交，这些操作要么同时成功，要么同时失败，事务是一组不可分割的逻辑单元</p>\n<ol>\n<li><p>事务的四大特性</p>\n<ol>\n<li><p><strong>原子性Atomicity</strong></p>\n<p>同一个事务内部的操作都是不可分割的</p>\n</li>\n<li><p><strong>一致性Consistency</strong></p>\n<p>事务提交前后，数据库的状态必须是一致的，外界只能读取到事务开启前的状态或事务提交后端而状态，而不能读取到中间的状态</p>\n</li>\n<li><p><strong>隔离性lsolation</strong></p>\n<p>多个用户在操作同一个表中的数据时，每个用户的操作时相互独立的事务，这些事务之间应该相互隔离，彼此不能干扰</p>\n</li>\n<li><p>持久性Durability</p>\n<p>事务一旦被提交后马，对数据库的修改就是永久性的，其他的回滚操作或故障不会对其具有任何影响</p>\n</li>\n</ol>\n</li>\n<li><p>手动事务</p>\n<p>事务的开启和提交需要去手动执行，每执行完一个DML操作后，如果不主动提交事务，那么数据不会持久化到数据库中</p>\n</li>\n<li><p>自动事务</p>\n<p>事务的开启和提交是由数据库自动执行的，只要执行了一个DML操作后，不需要手动提交事务，数据会自动持久化到数据库中</p>\n<p>mysq默认使用的是自动事务，每个事务中只有一条sql语句，所以通常在对mysql执行事务操作时需要将自动事务改为手动事务，方便我们可以去控制一个事务中可以存在多条sql语句，以及事务的开启，提交以及回滚时机</p>\n</li>\n<li><p>事务提交</p>\n<ol>\n<li><p>将自动事务提交改为手动提交</p>\n<blockquote>\n<p>set autocommit &#x3D; 0;</p>\n</blockquote>\n</li>\n<li><p>将事务改为手动提交后，下一条sql语句会自动开启一个事务</p>\n<blockquote>\n<p>例：insert into 表名 values(值1，值2…)；</p>\n<p>注意：在事务提交之前，数据是不会持久化到数据库中，而是存在内存的回滚段内</p>\n</blockquote>\n</li>\n<li><p>提交事务，数据会被持久化到数据中，事务结束</p>\n<blockquote>\n<p>commit;</p>\n</blockquote>\n</li>\n<li><p>事务回滚</p>\n<p>让内存回滚段中操作撤销，事务回滚后，改事务结束</p>\n<blockquote>\n<p>rollback;</p>\n</blockquote>\n</li>\n<li><p>设置回滚点</p>\n<blockquote>\n<p>savepoint 别名；</p>\n<p>SQL语句；</p>\n<p>savepoint 别名2；</p>\n<p>SQL语句；</p>\n<p>…….</p>\n<p>让事务回滚到指定的回滚点</p>\n<p>rollback to 别名；</p>\n<p>注意：回滚到某个回滚点上时，改事务并没有结束，需要rollback或这commit结束事务</p>\n</blockquote>\n</li>\n<li><p>事务在java代码中控制：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    开启事务</span><br><span class=\"line\">    DML....</span><br><span class=\"line\">    DML....</span><br><span class=\"line\">    提交事务</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception)&#123;</span><br><span class=\"line\">    回滚事务</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事务隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读未提交(read-uncommitted)</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">读已提交（read-committed）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">可重复读（repeatable-read）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">串行化（serializable）</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>脏读</p>\n<p>脏读(Dirty Read):当一个事务正在访问数据并对数据做了修改,而这种修改还没有提交到数据库,这时另外一个事务也访问了这个数据,然后使用了这个数据,因为这个数据是还没有提交的操作,那么另外一个事务读到的这个数据就是”脏数据”,依据脏数据所做的操作可能是不正确的<br>如:事务A读取了事务B更新但未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>\n</li>\n<li><p>不可重复读：</p>\n<p>指在一个事务内多次读取同一数据,在这个事务还没有结束时,另外一个事务也访问该数据,那么在第一个事务中的两次读取数据之间,由于第二个事务的修改导致第一个事务两次读取的数据不一致,这就导致了一个事务内两次读取的数据不一致,因此称为不可重复读<br>如:事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>\n</li>\n<li><p>幻读：</p>\n<p>幻读(Phantom Read):幻读与不可重复读类似,他发生在一个事务T1读取了几行数据,接着另外一个并发事务T2插入了一些数据,在随后的查询中,第一个事务就会发现读了一些原本不存在的记录,就好像发生了幻觉一样,所以称为幻读 </p>\n<p>如:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"九、DCL数据控制语言\"><a href=\"#九、DCL数据控制语言\" class=\"headerlink\" title=\"九、DCL数据控制语言\"></a>九、DCL数据控制语言</h3><p>主要用于管理数据库用户以及控制数据的访问控制权限</p>\n<p>只是由DBA来进行的操作</p>\n<ol>\n<li><p>用户管理</p>\n<ol>\n<li><p>查询用户</p>\n<blockquote>\n<p>use mysql;</p>\n<p>select * from user\\G;</p>\n</blockquote>\n</li>\n<li><p>新建用户</p>\n<blockquote>\n<p>create user ‘用户名‘@’主机名’ identified by ‘密码’;</p>\n<p>注意：主机名为localhost&#x2F;%，localhost为本地访问，%为多用户远程访问，单用户远程访问为指定ip地址</p>\n</blockquote>\n</li>\n<li><p>修改密码</p>\n<blockquote>\n<p>alter user ‘用户名‘@’主机名’ identified with mysql_native_password by ‘新密码’；</p>\n</blockquote>\n</li>\n<li><p>删除指定用户</p>\n<blockquote>\n<p>drop user ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>权限管理</p>\n<p>mysql中定义了很多权限，但是常用的只有一下几种</p>\n<ol>\n<li>ALL&#x2F;All Privileges\t 所有权</li>\n<li>select                 查询权限</li>\n<li>insert                 添加权限</li>\n<li>update                 修改权限</li>\n<li>delete                 删除权限</li>\n<li>drop                   删除库&#x2F;表&#x2F;表结构&#x2F;视图权限</li>\n<li>create                 创建库&#x2F;表权限</li>\n</ol>\n<blockquote>\n<p>查询授予用户的权限</p>\n<p>show grants for ‘用户名‘@’主机名’</p>\n</blockquote>\n</li>\n<li><p>授予权限</p>\n<blockquote>\n<p>grant 权限1，权限2… on 数据库名.表名 to ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n<li><p>撤销权限</p>\n<blockquote>\n<p>revoke 权限1，权限2… on数据库名.表名 from ‘用户名‘@’主机名’；</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"十、表于表之间的关系\"><a href=\"#十、表于表之间的关系\" class=\"headerlink\" title=\"十、表于表之间的关系\"></a>十、表于表之间的关系</h3><ol>\n<li><p>一对多，多对一(one-to-many  many-to-one)</p>\n<p>表设计：在多方表中添加一个外键列，去关联一方表的主键列</p>\n<p>案例：一个部门多个员工</p>\n</li>\n<li><p>一对一(one-to-one)</p>\n<p>案例：一个公司发行一种股票</p>\n<ol>\n<li>单向主键关联</li>\n<li>双向主键关联</li>\n<li>单向外键关联</li>\n<li>双向外键关联</li>\n</ol>\n</li>\n<li><p>多对多(many-to-many)</p>\n<p>表设计：创建一张中间表，用于存储两张多方表的主键</p>\n<p>案例：一个学生对应多个老师，一个老师对应多个学生吧</p>\n</li>\n</ol>\n<h3 id=\"十一、ER图\"><a href=\"#十一、ER图\" class=\"headerlink\" title=\"十一、ER图\"></a>十一、ER图</h3><p>Entity-relationship  实体关系图</p>\n<p>主要用于描述数据库中表与表之间得关系</p>\n<ol>\n<li><p>实体Entity</p>\n<p>数据模型中实体对象(表),使用长方形表示</p>\n</li>\n<li><p>属性Attribute</p>\n<p>实体对象得属性(字段)使用椭圆形表示</p>\n</li>\n<li><p>关系Relationship</p>\n<p>实体对象之间得关系(表与表之间得关系)，使用菱形表示</p>\n</li>\n</ol>\n<h3 id=\"十二、数据表设计得三大范式\"><a href=\"#十二、数据表设计得三大范式\" class=\"headerlink\" title=\"十二、数据表设计得三大范式\"></a>十二、数据表设计得三大范式</h3><p>为了建立结构合理，数据冗余较小得表，所以数据表在设计时要遵循相应得原则，也就是范式</p>\n<ol>\n<li>保证数据表中每一列得原子性，每一列下面得数据不能再拆分</li>\n<li>非主键字段不能部分依赖主键字段确保表中的每一列要和主键列直接关联</li>\n<li>确保表中的每一列和主键列都素hi直接关联关系，而不是间接关联，不能存在传递依赖</li>\n</ol>\n"},{"title":"Nginx基础","date":"2023-05-16T03:18:57.000Z","cover":"/img/images/nginx.jpg","_content":"\n# Nginx基础\n\n## Nginx特点\n反向代理\n负载均衡\n动静分离\n\n## Nginx安装\n1.官网下载Nginx安装包\n> cd /opt/\n> wget http://nginx.org/download/nginx-x.xx.x.tar.gz\n\n2.解压缩\n> tar -xzvf nginx-x.xx.x.tar.gz\n\n3.进入Nginx目录\n> cd nginx-x.xx.x\n\n4.安装\n> ./configure --help\t查看安装所需要的命令\n> ./configure --prefix=PATH 安装的路径\n> 安装过程中可能缺少某些库，例如pcre、zlib、openssl\n\n5.编译\n> make && make install\n\n如果没有设置安装路径默认路径是 /usr/local/nginx\n> cd /usr/local/nginx/sbin\n> nginx -v 查看nginx版本\n\n6.启动Nginx服务\n> cd /usr/local/nginx/sbin\n> ./nginx\n\n7.查看服务是否启动\n> ps -ef|grep nginx\n\n\n\n\n\n所需依赖\n\n>pcre   zlib \n\n\n\n\n\n\n## 常用命令\n> 1. cd /usr/local/nginx/sbin\n> 2. ./nginx\t\t\t\t启动服务\n> 3. ./nginx -s stop\t\t强制停止\n> 4. ./nginx -s quit\t\t安全退出\n> 5. ./nginx -s reload\t\t重新加载配置文件\n> 6. ps aux|grep nginx\t\t查看nginx进程\n\n注意：如果链接不上，检查服务器安全组是否开放端口，或者服务器防火墙是否开放端口\n> service firewalld start\t\t开启防火墙\n> service firewalld restart\t\t重启防火墙\n> service firewalld stop\t\t关闭防火墙\n> firewall-cmd --list-all\t\t查看防火墙规则\n> firewall-cmd --query-port=端口号/tcp\t\t查询端口号是否开放\n> firewall-cmd --permanent --add-port=端口号/tcp\t开放XX端口\n> firewall-cmd --permanent --remove-port=端口号/tcp 移除XX端口号\n> firewall-cmd --reload\t\t重启防火墙(修改配置后重启防火墙)\n\n\n\nNginx的配置文件\n\ncd /usrl/local/nginx/conf\n\n\n\n全局块\n\n#user  nobody;\nworker_processes  1;并发处理量，值越大并发处理越高\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\n\n\n\nevents块\n\nNginx服务器与用户的网络连接\n\nevents {\n    worker_connections  1024;最大连接数\n}\n\n\n\nhttp块\n\n代理、缓存、日志绝大数功能和第三方模块都在这里配置\n\nhttp全局块：文件引入、MIME-TYPE定义，日志自定义，连接超时时间，单连接请求数上限等\n\n```nginx\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    #gzip  on;\n    server {\n        #监听端口\n        listen       80;\n        #主机名称\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n}\n```\n\n\n\n示例1.反向代理\n\n>1. 实现效果：打开浏览器地址栏输入www.123.com,跳转到linux系统tomcat主页面中\n>2. 准备工作\n>   1. 安装tomcat服务器使用默认端口\n\n\n\n示例2.负载均衡\n\n分配服务器策略\n\n1. 默认轮询\n\n2. weight权重\n\n   默认1，权重越高被分配的请求就越多\n\n3. ip_hash\n\n   每个请求按照ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题\n\n\n\n\n\n示例3.动静分离\n","source":"_posts/Nginx基础.md","raw":"---\ntitle: Nginx基础\ndate: 2023-05-16 11:18:57\ntags: 中间件\ncategories: 中间件\ncover: /img/images/nginx.jpg\n---\n\n# Nginx基础\n\n## Nginx特点\n反向代理\n负载均衡\n动静分离\n\n## Nginx安装\n1.官网下载Nginx安装包\n> cd /opt/\n> wget http://nginx.org/download/nginx-x.xx.x.tar.gz\n\n2.解压缩\n> tar -xzvf nginx-x.xx.x.tar.gz\n\n3.进入Nginx目录\n> cd nginx-x.xx.x\n\n4.安装\n> ./configure --help\t查看安装所需要的命令\n> ./configure --prefix=PATH 安装的路径\n> 安装过程中可能缺少某些库，例如pcre、zlib、openssl\n\n5.编译\n> make && make install\n\n如果没有设置安装路径默认路径是 /usr/local/nginx\n> cd /usr/local/nginx/sbin\n> nginx -v 查看nginx版本\n\n6.启动Nginx服务\n> cd /usr/local/nginx/sbin\n> ./nginx\n\n7.查看服务是否启动\n> ps -ef|grep nginx\n\n\n\n\n\n所需依赖\n\n>pcre   zlib \n\n\n\n\n\n\n## 常用命令\n> 1. cd /usr/local/nginx/sbin\n> 2. ./nginx\t\t\t\t启动服务\n> 3. ./nginx -s stop\t\t强制停止\n> 4. ./nginx -s quit\t\t安全退出\n> 5. ./nginx -s reload\t\t重新加载配置文件\n> 6. ps aux|grep nginx\t\t查看nginx进程\n\n注意：如果链接不上，检查服务器安全组是否开放端口，或者服务器防火墙是否开放端口\n> service firewalld start\t\t开启防火墙\n> service firewalld restart\t\t重启防火墙\n> service firewalld stop\t\t关闭防火墙\n> firewall-cmd --list-all\t\t查看防火墙规则\n> firewall-cmd --query-port=端口号/tcp\t\t查询端口号是否开放\n> firewall-cmd --permanent --add-port=端口号/tcp\t开放XX端口\n> firewall-cmd --permanent --remove-port=端口号/tcp 移除XX端口号\n> firewall-cmd --reload\t\t重启防火墙(修改配置后重启防火墙)\n\n\n\nNginx的配置文件\n\ncd /usrl/local/nginx/conf\n\n\n\n全局块\n\n#user  nobody;\nworker_processes  1;并发处理量，值越大并发处理越高\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\n\n\n\nevents块\n\nNginx服务器与用户的网络连接\n\nevents {\n    worker_connections  1024;最大连接数\n}\n\n\n\nhttp块\n\n代理、缓存、日志绝大数功能和第三方模块都在这里配置\n\nhttp全局块：文件引入、MIME-TYPE定义，日志自定义，连接超时时间，单连接请求数上限等\n\n```nginx\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    #gzip  on;\n    server {\n        #监听端口\n        listen       80;\n        #主机名称\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n}\n```\n\n\n\n示例1.反向代理\n\n>1. 实现效果：打开浏览器地址栏输入www.123.com,跳转到linux系统tomcat主页面中\n>2. 准备工作\n>   1. 安装tomcat服务器使用默认端口\n\n\n\n示例2.负载均衡\n\n分配服务器策略\n\n1. 默认轮询\n\n2. weight权重\n\n   默认1，权重越高被分配的请求就越多\n\n3. ip_hash\n\n   每个请求按照ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题\n\n\n\n\n\n示例3.动静分离\n","slug":"Nginx基础","published":1,"updated":"2023-08-10T09:50:50.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9j000qfswo7dwydwhk","content":"<h1 id=\"Nginx基础\"><a href=\"#Nginx基础\" class=\"headerlink\" title=\"Nginx基础\"></a>Nginx基础</h1><h2 id=\"Nginx特点\"><a href=\"#Nginx特点\" class=\"headerlink\" title=\"Nginx特点\"></a>Nginx特点</h2><p>反向代理<br>负载均衡<br>动静分离</p>\n<h2 id=\"Nginx安装\"><a href=\"#Nginx安装\" class=\"headerlink\" title=\"Nginx安装\"></a>Nginx安装</h2><p>1.官网下载Nginx安装包</p>\n<blockquote>\n<p>cd &#x2F;opt&#x2F;<br>wget <a href=\"http://nginx.org/download/nginx-x.xx.x.tar.gz\">http://nginx.org/download/nginx-x.xx.x.tar.gz</a></p>\n</blockquote>\n<p>2.解压缩</p>\n<blockquote>\n<p>tar -xzvf nginx-x.xx.x.tar.gz</p>\n</blockquote>\n<p>3.进入Nginx目录</p>\n<blockquote>\n<p>cd nginx-x.xx.x</p>\n</blockquote>\n<p>4.安装</p>\n<blockquote>\n<p>.&#x2F;configure –help\t查看安装所需要的命令<br>.&#x2F;configure –prefix&#x3D;PATH 安装的路径<br>安装过程中可能缺少某些库，例如pcre、zlib、openssl</p>\n</blockquote>\n<p>5.编译</p>\n<blockquote>\n<p>make &amp;&amp; make install</p>\n</blockquote>\n<p>如果没有设置安装路径默认路径是 &#x2F;usr&#x2F;local&#x2F;nginx</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin<br>nginx -v 查看nginx版本</p>\n</blockquote>\n<p>6.启动Nginx服务</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin<br>.&#x2F;nginx</p>\n</blockquote>\n<p>7.查看服务是否启动</p>\n<blockquote>\n<p>ps -ef|grep nginx</p>\n</blockquote>\n<p>所需依赖</p>\n<blockquote>\n<p>pcre   zlib </p>\n</blockquote>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><blockquote>\n<ol>\n<li>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</li>\n<li>.&#x2F;nginx\t\t\t\t启动服务</li>\n<li>.&#x2F;nginx -s stop\t\t强制停止</li>\n<li>.&#x2F;nginx -s quit\t\t安全退出</li>\n<li>.&#x2F;nginx -s reload\t\t重新加载配置文件</li>\n<li>ps aux|grep nginx\t\t查看nginx进程</li>\n</ol>\n</blockquote>\n<p>注意：如果链接不上，检查服务器安全组是否开放端口，或者服务器防火墙是否开放端口</p>\n<blockquote>\n<p>service firewalld start\t\t开启防火墙<br>service firewalld restart\t\t重启防火墙<br>service firewalld stop\t\t关闭防火墙<br>firewall-cmd –list-all\t\t查看防火墙规则<br>firewall-cmd –query-port&#x3D;端口号&#x2F;tcp\t\t查询端口号是否开放<br>firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;tcp\t开放XX端口<br>firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;tcp 移除XX端口号<br>firewall-cmd –reload\t\t重启防火墙(修改配置后重启防火墙)</p>\n</blockquote>\n<p>Nginx的配置文件</p>\n<p>cd &#x2F;usrl&#x2F;local&#x2F;nginx&#x2F;conf</p>\n<p>全局块</p>\n<p>#user  nobody;<br>worker_processes  1;并发处理量，值越大并发处理越高</p>\n<p>#error_log  logs&#x2F;error.log;<br>#error_log  logs&#x2F;error.log  notice;<br>#error_log  logs&#x2F;error.log  info;</p>\n<p>#pid        logs&#x2F;nginx.pid;</p>\n<p>events块</p>\n<p>Nginx服务器与用户的网络连接</p>\n<p>events {<br>    worker_connections  1024;最大连接数<br>}</p>\n<p>http块</p>\n<p>代理、缓存、日志绝大数功能和第三方模块都在这里配置</p>\n<p>http全局块：文件引入、MIME-TYPE定义，日志自定义，连接超时时间，单连接请求数上限等</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/octet-stream;</span><br><span class=\"line\">    <span class=\"comment\">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">#access_log  logs/access.log  main;</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span>        <span class=\"literal\">on</span>;</span><br><span class=\"line\">    <span class=\"comment\">#tcp_nopush     on;</span></span><br><span class=\"line\">    <span class=\"comment\">#keepalive_timeout  0;</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span>  <span class=\"number\">65</span>;</span><br><span class=\"line\">    <span class=\"comment\">#gzip  on;</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">80</span>;</span><br><span class=\"line\">        <span class=\"comment\">#主机名称</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  localhost;</span><br><span class=\"line\">        <span class=\"comment\">#charset koi8-r;</span></span><br><span class=\"line\">        <span class=\"comment\">#access_log  logs/host.access.log  main;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html;</span><br><span class=\"line\">            <span class=\"attribute\">index</span>  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">#error_page  404              /404.html;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># redirect server error pages to the static page /50x.html</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"attribute\">error_page</span>   <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span>  /50x.html;</span><br><span class=\"line\">        <span class=\"section\">location</span> = /50x.html &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    proxy_pass   http://127.0.0.1;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    root           html;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_index  index.php;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class=\"line\">        <span class=\"comment\">#    include        fastcgi_params;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class=\"line\">        <span class=\"comment\"># concurs with nginx&#x27;s one</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ /\\.ht &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    deny  all;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\">#server &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       8000;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       somename:8080;</span></span><br><span class=\"line\">    <span class=\"comment\">#    server_name  somename  alias  another.alias;</span></span><br><span class=\"line\">    <span class=\"comment\">#    location / &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#        root   html;</span></span><br><span class=\"line\">    <span class=\"comment\">#        index  index.html index.htm;</span></span><br><span class=\"line\">    <span class=\"comment\">#    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">    <span class=\"comment\"># HTTPS server</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\">#server &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       443 ssl;</span></span><br><span class=\"line\">    <span class=\"comment\">#    server_name  localhost;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate      cert.pem;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate_key  cert.key;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_timeout  5m;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_prefer_server_ciphers  on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    location / &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#        root   html;</span></span><br><span class=\"line\">    <span class=\"comment\">#        index  index.html index.htm;</span></span><br><span class=\"line\">    <span class=\"comment\">#    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例1.反向代理</p>\n<blockquote>\n<ol>\n<li>实现效果：打开浏览器地址栏输入<a href=\"http://www.123.com,跳转到linux系统tomcat主页面中/\">www.123.com,跳转到linux系统tomcat主页面中</a></li>\n<li>准备工作</li>\n<li>安装tomcat服务器使用默认端口</li>\n</ol>\n</blockquote>\n<p>示例2.负载均衡</p>\n<p>分配服务器策略</p>\n<ol>\n<li><p>默认轮询</p>\n</li>\n<li><p>weight权重</p>\n<p>默认1，权重越高被分配的请求就越多</p>\n</li>\n<li><p>ip_hash</p>\n<p>每个请求按照ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p>\n</li>\n</ol>\n<p>示例3.动静分离</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Nginx基础\"><a href=\"#Nginx基础\" class=\"headerlink\" title=\"Nginx基础\"></a>Nginx基础</h1><h2 id=\"Nginx特点\"><a href=\"#Nginx特点\" class=\"headerlink\" title=\"Nginx特点\"></a>Nginx特点</h2><p>反向代理<br>负载均衡<br>动静分离</p>\n<h2 id=\"Nginx安装\"><a href=\"#Nginx安装\" class=\"headerlink\" title=\"Nginx安装\"></a>Nginx安装</h2><p>1.官网下载Nginx安装包</p>\n<blockquote>\n<p>cd &#x2F;opt&#x2F;<br>wget <a href=\"http://nginx.org/download/nginx-x.xx.x.tar.gz\">http://nginx.org/download/nginx-x.xx.x.tar.gz</a></p>\n</blockquote>\n<p>2.解压缩</p>\n<blockquote>\n<p>tar -xzvf nginx-x.xx.x.tar.gz</p>\n</blockquote>\n<p>3.进入Nginx目录</p>\n<blockquote>\n<p>cd nginx-x.xx.x</p>\n</blockquote>\n<p>4.安装</p>\n<blockquote>\n<p>.&#x2F;configure –help\t查看安装所需要的命令<br>.&#x2F;configure –prefix&#x3D;PATH 安装的路径<br>安装过程中可能缺少某些库，例如pcre、zlib、openssl</p>\n</blockquote>\n<p>5.编译</p>\n<blockquote>\n<p>make &amp;&amp; make install</p>\n</blockquote>\n<p>如果没有设置安装路径默认路径是 &#x2F;usr&#x2F;local&#x2F;nginx</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin<br>nginx -v 查看nginx版本</p>\n</blockquote>\n<p>6.启动Nginx服务</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin<br>.&#x2F;nginx</p>\n</blockquote>\n<p>7.查看服务是否启动</p>\n<blockquote>\n<p>ps -ef|grep nginx</p>\n</blockquote>\n<p>所需依赖</p>\n<blockquote>\n<p>pcre   zlib </p>\n</blockquote>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><blockquote>\n<ol>\n<li>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</li>\n<li>.&#x2F;nginx\t\t\t\t启动服务</li>\n<li>.&#x2F;nginx -s stop\t\t强制停止</li>\n<li>.&#x2F;nginx -s quit\t\t安全退出</li>\n<li>.&#x2F;nginx -s reload\t\t重新加载配置文件</li>\n<li>ps aux|grep nginx\t\t查看nginx进程</li>\n</ol>\n</blockquote>\n<p>注意：如果链接不上，检查服务器安全组是否开放端口，或者服务器防火墙是否开放端口</p>\n<blockquote>\n<p>service firewalld start\t\t开启防火墙<br>service firewalld restart\t\t重启防火墙<br>service firewalld stop\t\t关闭防火墙<br>firewall-cmd –list-all\t\t查看防火墙规则<br>firewall-cmd –query-port&#x3D;端口号&#x2F;tcp\t\t查询端口号是否开放<br>firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;tcp\t开放XX端口<br>firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;tcp 移除XX端口号<br>firewall-cmd –reload\t\t重启防火墙(修改配置后重启防火墙)</p>\n</blockquote>\n<p>Nginx的配置文件</p>\n<p>cd &#x2F;usrl&#x2F;local&#x2F;nginx&#x2F;conf</p>\n<p>全局块</p>\n<p>#user  nobody;<br>worker_processes  1;并发处理量，值越大并发处理越高</p>\n<p>#error_log  logs&#x2F;error.log;<br>#error_log  logs&#x2F;error.log  notice;<br>#error_log  logs&#x2F;error.log  info;</p>\n<p>#pid        logs&#x2F;nginx.pid;</p>\n<p>events块</p>\n<p>Nginx服务器与用户的网络连接</p>\n<p>events {<br>    worker_connections  1024;最大连接数<br>}</p>\n<p>http块</p>\n<p>代理、缓存、日志绝大数功能和第三方模块都在这里配置</p>\n<p>http全局块：文件引入、MIME-TYPE定义，日志自定义，连接超时时间，单连接请求数上限等</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/octet-stream;</span><br><span class=\"line\">    <span class=\"comment\">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class=\"line\">    <span class=\"comment\">#access_log  logs/access.log  main;</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span>        <span class=\"literal\">on</span>;</span><br><span class=\"line\">    <span class=\"comment\">#tcp_nopush     on;</span></span><br><span class=\"line\">    <span class=\"comment\">#keepalive_timeout  0;</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span>  <span class=\"number\">65</span>;</span><br><span class=\"line\">    <span class=\"comment\">#gzip  on;</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">80</span>;</span><br><span class=\"line\">        <span class=\"comment\">#主机名称</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  localhost;</span><br><span class=\"line\">        <span class=\"comment\">#charset koi8-r;</span></span><br><span class=\"line\">        <span class=\"comment\">#access_log  logs/host.access.log  main;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html;</span><br><span class=\"line\">            <span class=\"attribute\">index</span>  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">#error_page  404              /404.html;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># redirect server error pages to the static page /50x.html</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"attribute\">error_page</span>   <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span>  /50x.html;</span><br><span class=\"line\">        <span class=\"section\">location</span> = /50x.html &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    proxy_pass   http://127.0.0.1;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ \\.php$ &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    root           html;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_index  index.php;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class=\"line\">        <span class=\"comment\">#    include        fastcgi_params;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class=\"line\">        <span class=\"comment\"># concurs with nginx&#x27;s one</span></span><br><span class=\"line\">        <span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"comment\">#location ~ /\\.ht &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    deny  all;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\">#server &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       8000;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       somename:8080;</span></span><br><span class=\"line\">    <span class=\"comment\">#    server_name  somename  alias  another.alias;</span></span><br><span class=\"line\">    <span class=\"comment\">#    location / &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#        root   html;</span></span><br><span class=\"line\">    <span class=\"comment\">#        index  index.html index.htm;</span></span><br><span class=\"line\">    <span class=\"comment\">#    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">    <span class=\"comment\"># HTTPS server</span></span><br><span class=\"line\">    <span class=\"comment\">#</span></span><br><span class=\"line\">    <span class=\"comment\">#server &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#    listen       443 ssl;</span></span><br><span class=\"line\">    <span class=\"comment\">#    server_name  localhost;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate      cert.pem;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_certificate_key  cert.key;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_session_timeout  5m;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class=\"line\">    <span class=\"comment\">#    ssl_prefer_server_ciphers  on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#    location / &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">#        root   html;</span></span><br><span class=\"line\">    <span class=\"comment\">#        index  index.html index.htm;</span></span><br><span class=\"line\">    <span class=\"comment\">#    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例1.反向代理</p>\n<blockquote>\n<ol>\n<li>实现效果：打开浏览器地址栏输入<a href=\"http://www.123.com,跳转到linux系统tomcat主页面中/\">www.123.com,跳转到linux系统tomcat主页面中</a></li>\n<li>准备工作</li>\n<li>安装tomcat服务器使用默认端口</li>\n</ol>\n</blockquote>\n<p>示例2.负载均衡</p>\n<p>分配服务器策略</p>\n<ol>\n<li><p>默认轮询</p>\n</li>\n<li><p>weight权重</p>\n<p>默认1，权重越高被分配的请求就越多</p>\n</li>\n<li><p>ip_hash</p>\n<p>每个请求按照ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p>\n</li>\n</ol>\n<p>示例3.动静分离</p>\n"},{"title":"Redis缓存","date":"2023-07-12T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# Redis\n\n### 一、NoSQL数据库简介\n\n#### 1.1 NoSQL数据库概述\n\nNoSQL(Not Only SQL)不仅仅是SQL，泛指非关系性数据库，NoSQL不依赖业务逻辑方式存储，而以简单的Key-value模式存储，因此大大的增加了数据库的扩展能力\n\n>不遵循SQL标准\n>\n>不支持ACID(原子性，一致性，隔离性，持久性)\n>\n>远超于SQL的性能\n\n#### 1.2 NoSQL适用场景\n\n> 对数据高并发的读写\n>\n> 海量数据的读写\n>\n> 对数据高扩展性\n\n#### 1.3 Memcache\n\n1. 数据都在内存中，一般不持久化\n2. 支持简单的key-value模式，支持类型单一\n3. 一般是作为缓存数据库辅助持久化的数据库\n\n#### 1.4 Redis\n\n1. 数据都在内存中，支持持久化，主要用于备份恢复\n2. 除了简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset\n3. 一般是作为缓存数据库辅助持久化的数据库\n\n#### 1.5 MongoDB\n\n1. 高性能、开源、模式自由(schema free)的文档型数据库\n2. 数据都在内存中，如果内存不足，吧不常用的数据保存到硬盘\n3. 虽然是key-value模式，但是对value(尤其是json)，提供了丰富的查询功能\n4. 支持二进制数据及大型对象\n5. 可以根据数据的特点代替RDBMS，成为独立的数据库，或者配合RDBMS，存储特定的数据\n\n#### 1.6 行式存储数据库\n\n##### 1.6.1 行式数据库\n\n​\t字段一行一行对应上面的字段存储内容\n\n##### 1.6.2 列式数据库\n\n​\t一列一列存储数据\n\n1. Hbase\n\n   Hbase是Hadoop项目中的数据库，它用于需要对大量的数据进行随机、实时的读写操作场景中\n\n   Hbase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表\n\n2. Cassandra\n\n   Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程\n\n#### 1.7 图关系型数据库\n\n​\t主要应用于：社会关系、公共交通网络、地图及网络拓扑 \n\n\n\n### 二、Redis概述和安装\n\n#### 1.特点\n\n- Redis是一个开源的key-value存储系统\n- 和Memcached类似，它支持存储的value类型相对更多\n- 这些数据类型都支持push/pop，add/remove及取交集和差集及更丰富的操作，而且这些操作都是原子性\n- Redis支持各种不同的排序\n- 为了保证效率，数据都是缓存在内存中\n- Redis会周期性的吧更新的数据写入到磁盘中，或者把修改操作写入追加的记录文件中\n- 并且在此基础上实现了master-slave主从同步\n\n#### 2.应用场景\n\n配合关系型数据库做高速缓存\n\n- 高频次，降低数据库IO\n- 分布式架构，做session共享\n- 缓存加速\n- 排行榜场景\n- 分布式计数器，锁，会话...\n\n#### 3.安装\n\n##### 3.1 安装C语言的编译环境\n\n> yum install gcc\n>\n> gcc --version\n\n##### 3.2 解压Redis压缩文件\n\n> tar -zxvf redis-6.2.1.tar.gz\n\n##### 3.3 进入Redis解压目录里面进行编译\n\n> cd redis-6.2.1\n>\n> make\n>\n> - make报错 -Jemalloc/jemalloc,h:没有这个文件\n> - 第一步：查看gcc 版本是否安装成功\n> - 第二步：make distclean\n> - 第三步：make 再次进行编译\n\n##### 3.4 编译好之后进行安装\n\n> make install\n\n##### 3.5 查看安装目录\n\n> cd /usr/local/bin\n>\n> 默认安装目录：\n>\n> - redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何\n> - redis-check-aof:修复有问题的AOF文件\n> - redis-check-dump:修复有问题的dump。rdb文件\n> - redis-sentinel:Redis集群使用\n> - **`redis-server`**:Redis服务器启动命令\n> - **`redis-cli`**:客户端，操作入口\n\n##### 3.6 启动Redis\n\n###### 3.6.1 前台启动(不推荐)\n\n​\t前台启动，命令行窗口不能关闭，否则服务器停止\n\n> cd /usr/local/bin\n>\n> redis-server\n\n###### 3.6.2 后台启动(推荐)\n\n​\t后台启动，命令行窗口不显示，服务器后台运行，不会停止\n\n1. **进入redis-6.2.1目录中**\n\n   > cd /opt/redis-6.2.1\n\n2. **复制redis.conf**\n\n   > cp redis.conf /etc/redis.conf\n\n3. **修改etc下的redis.conf的复制文件**\n\n   > cd /etc\n   >\n   > vi redis.conf\n   >\n   > 修改`daemonize no`改为 `yes`\n\n4. **启动**\n\n   > cd /usr/local/bin\n   >\n   > redis-server /etc/redis.conf\n   >\n   > ps -ef | grep redis   查询是否启动\n\n5. **客户端连接**\n\n   > redis-cli \n   >\n   > ping   测试连接\n\n##### 3.7 关闭Redis\n\n1. 单实例关闭：redis-cli shutdown\n2. 也可以进入终端关闭：shutdown\n3. 多实例关闭：redis-cli -p6379(端口号) shutdown\n4. kill -9 进程号  \n\n#### 4. Redis相关知识\n\n​\tRedis端口的由来：默认端口6379，6379对应的是按键机的Merz，Alessia `Merz`是一名演员\n\n- Redis默认提供了`16个数据库`，类似数组下标从0开始初始`默认使用0号数据库`\n- 使用命令 **`selec`** <dbid>来切换数据库。例如：select 8，切换到8号数据库\n- 统一密码管理。所有库同样密码\n- **`dbsize`**查看当前数据库的key的数量\n- **`flushdb`**清空当前数据库\n- **`flushall`**通杀全部库\n\n​\t多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞知道超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如**使用线程池**)\n\nMemcache：`多线程+锁(memcached)`\n\nRedis：`单线程+多路IO复用`\n\n`Redis与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用`\n\n### 三、常用的五大数据类型\n\n#### 1.Redis键(key)\n\n> - keys *查看当前库所有key(匹配：key *1)\n> - exists key 判断某个key是否存在\n> - type key 查看你的key是什么类型\n> - del key 删除指定的key数据\n> - `unlink key 根据value选择非阻塞删除`\n> - 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作\n> - expire key 10 10秒钟：为给定的key设置过期时间\n> - ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n> - select命令切换数据库\n> - dbsize查看当前数据库的key的数量\n> - flushdb清空当前库\n> - flushall通杀全部库\n\n#### 2.Redis字符串(String)\n\n##### 2.1 简介\n\n1. String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value\n2. String类型是二进制安全的，意味着Redis的String可以包含任何数据，比如jpg图片或者序列化对象\n3. String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M\n\n##### 2.2 常用命令\n\nset <key><value>添加键值对\n\nget <key>查询对应键值\n\nappend <key><value>将给定的<value>追加到原值的末尾\n\nstrlen <key>获得值的长度\n\nsetnx <key><value>只有在key不存在时 设置key的值\n\nincr <key> 将key中存储的数字增值1\n\n​\t\t   只能对数字值操作，如果为空，新增值为1\n","source":"_posts/Redis.md","raw":"---\ntitle: Redis缓存\ndate: 2023-07-12 11:18:57\ntags: 中间件\ncategories: 中间件\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# Redis\n\n### 一、NoSQL数据库简介\n\n#### 1.1 NoSQL数据库概述\n\nNoSQL(Not Only SQL)不仅仅是SQL，泛指非关系性数据库，NoSQL不依赖业务逻辑方式存储，而以简单的Key-value模式存储，因此大大的增加了数据库的扩展能力\n\n>不遵循SQL标准\n>\n>不支持ACID(原子性，一致性，隔离性，持久性)\n>\n>远超于SQL的性能\n\n#### 1.2 NoSQL适用场景\n\n> 对数据高并发的读写\n>\n> 海量数据的读写\n>\n> 对数据高扩展性\n\n#### 1.3 Memcache\n\n1. 数据都在内存中，一般不持久化\n2. 支持简单的key-value模式，支持类型单一\n3. 一般是作为缓存数据库辅助持久化的数据库\n\n#### 1.4 Redis\n\n1. 数据都在内存中，支持持久化，主要用于备份恢复\n2. 除了简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset\n3. 一般是作为缓存数据库辅助持久化的数据库\n\n#### 1.5 MongoDB\n\n1. 高性能、开源、模式自由(schema free)的文档型数据库\n2. 数据都在内存中，如果内存不足，吧不常用的数据保存到硬盘\n3. 虽然是key-value模式，但是对value(尤其是json)，提供了丰富的查询功能\n4. 支持二进制数据及大型对象\n5. 可以根据数据的特点代替RDBMS，成为独立的数据库，或者配合RDBMS，存储特定的数据\n\n#### 1.6 行式存储数据库\n\n##### 1.6.1 行式数据库\n\n​\t字段一行一行对应上面的字段存储内容\n\n##### 1.6.2 列式数据库\n\n​\t一列一列存储数据\n\n1. Hbase\n\n   Hbase是Hadoop项目中的数据库，它用于需要对大量的数据进行随机、实时的读写操作场景中\n\n   Hbase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表\n\n2. Cassandra\n\n   Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程\n\n#### 1.7 图关系型数据库\n\n​\t主要应用于：社会关系、公共交通网络、地图及网络拓扑 \n\n\n\n### 二、Redis概述和安装\n\n#### 1.特点\n\n- Redis是一个开源的key-value存储系统\n- 和Memcached类似，它支持存储的value类型相对更多\n- 这些数据类型都支持push/pop，add/remove及取交集和差集及更丰富的操作，而且这些操作都是原子性\n- Redis支持各种不同的排序\n- 为了保证效率，数据都是缓存在内存中\n- Redis会周期性的吧更新的数据写入到磁盘中，或者把修改操作写入追加的记录文件中\n- 并且在此基础上实现了master-slave主从同步\n\n#### 2.应用场景\n\n配合关系型数据库做高速缓存\n\n- 高频次，降低数据库IO\n- 分布式架构，做session共享\n- 缓存加速\n- 排行榜场景\n- 分布式计数器，锁，会话...\n\n#### 3.安装\n\n##### 3.1 安装C语言的编译环境\n\n> yum install gcc\n>\n> gcc --version\n\n##### 3.2 解压Redis压缩文件\n\n> tar -zxvf redis-6.2.1.tar.gz\n\n##### 3.3 进入Redis解压目录里面进行编译\n\n> cd redis-6.2.1\n>\n> make\n>\n> - make报错 -Jemalloc/jemalloc,h:没有这个文件\n> - 第一步：查看gcc 版本是否安装成功\n> - 第二步：make distclean\n> - 第三步：make 再次进行编译\n\n##### 3.4 编译好之后进行安装\n\n> make install\n\n##### 3.5 查看安装目录\n\n> cd /usr/local/bin\n>\n> 默认安装目录：\n>\n> - redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何\n> - redis-check-aof:修复有问题的AOF文件\n> - redis-check-dump:修复有问题的dump。rdb文件\n> - redis-sentinel:Redis集群使用\n> - **`redis-server`**:Redis服务器启动命令\n> - **`redis-cli`**:客户端，操作入口\n\n##### 3.6 启动Redis\n\n###### 3.6.1 前台启动(不推荐)\n\n​\t前台启动，命令行窗口不能关闭，否则服务器停止\n\n> cd /usr/local/bin\n>\n> redis-server\n\n###### 3.6.2 后台启动(推荐)\n\n​\t后台启动，命令行窗口不显示，服务器后台运行，不会停止\n\n1. **进入redis-6.2.1目录中**\n\n   > cd /opt/redis-6.2.1\n\n2. **复制redis.conf**\n\n   > cp redis.conf /etc/redis.conf\n\n3. **修改etc下的redis.conf的复制文件**\n\n   > cd /etc\n   >\n   > vi redis.conf\n   >\n   > 修改`daemonize no`改为 `yes`\n\n4. **启动**\n\n   > cd /usr/local/bin\n   >\n   > redis-server /etc/redis.conf\n   >\n   > ps -ef | grep redis   查询是否启动\n\n5. **客户端连接**\n\n   > redis-cli \n   >\n   > ping   测试连接\n\n##### 3.7 关闭Redis\n\n1. 单实例关闭：redis-cli shutdown\n2. 也可以进入终端关闭：shutdown\n3. 多实例关闭：redis-cli -p6379(端口号) shutdown\n4. kill -9 进程号  \n\n#### 4. Redis相关知识\n\n​\tRedis端口的由来：默认端口6379，6379对应的是按键机的Merz，Alessia `Merz`是一名演员\n\n- Redis默认提供了`16个数据库`，类似数组下标从0开始初始`默认使用0号数据库`\n- 使用命令 **`selec`** <dbid>来切换数据库。例如：select 8，切换到8号数据库\n- 统一密码管理。所有库同样密码\n- **`dbsize`**查看当前数据库的key的数量\n- **`flushdb`**清空当前数据库\n- **`flushall`**通杀全部库\n\n​\t多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞知道超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如**使用线程池**)\n\nMemcache：`多线程+锁(memcached)`\n\nRedis：`单线程+多路IO复用`\n\n`Redis与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用`\n\n### 三、常用的五大数据类型\n\n#### 1.Redis键(key)\n\n> - keys *查看当前库所有key(匹配：key *1)\n> - exists key 判断某个key是否存在\n> - type key 查看你的key是什么类型\n> - del key 删除指定的key数据\n> - `unlink key 根据value选择非阻塞删除`\n> - 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作\n> - expire key 10 10秒钟：为给定的key设置过期时间\n> - ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n> - select命令切换数据库\n> - dbsize查看当前数据库的key的数量\n> - flushdb清空当前库\n> - flushall通杀全部库\n\n#### 2.Redis字符串(String)\n\n##### 2.1 简介\n\n1. String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value\n2. String类型是二进制安全的，意味着Redis的String可以包含任何数据，比如jpg图片或者序列化对象\n3. String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M\n\n##### 2.2 常用命令\n\nset <key><value>添加键值对\n\nget <key>查询对应键值\n\nappend <key><value>将给定的<value>追加到原值的末尾\n\nstrlen <key>获得值的长度\n\nsetnx <key><value>只有在key不存在时 设置key的值\n\nincr <key> 将key中存储的数字增值1\n\n​\t\t   只能对数字值操作，如果为空，新增值为1\n","slug":"Redis","published":1,"updated":"2023-08-10T09:51:02.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9k000sfswo35ms2kxm","content":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h3 id=\"一、NoSQL数据库简介\"><a href=\"#一、NoSQL数据库简介\" class=\"headerlink\" title=\"一、NoSQL数据库简介\"></a>一、NoSQL数据库简介</h3><h4 id=\"1-1-NoSQL数据库概述\"><a href=\"#1-1-NoSQL数据库概述\" class=\"headerlink\" title=\"1.1 NoSQL数据库概述\"></a>1.1 NoSQL数据库概述</h4><p>NoSQL(Not Only SQL)不仅仅是SQL，泛指非关系性数据库，NoSQL不依赖业务逻辑方式存储，而以简单的Key-value模式存储，因此大大的增加了数据库的扩展能力</p>\n<blockquote>\n<p>不遵循SQL标准</p>\n<p>不支持ACID(原子性，一致性，隔离性，持久性)</p>\n<p>远超于SQL的性能</p>\n</blockquote>\n<h4 id=\"1-2-NoSQL适用场景\"><a href=\"#1-2-NoSQL适用场景\" class=\"headerlink\" title=\"1.2 NoSQL适用场景\"></a>1.2 NoSQL适用场景</h4><blockquote>\n<p>对数据高并发的读写</p>\n<p>海量数据的读写</p>\n<p>对数据高扩展性</p>\n</blockquote>\n<h4 id=\"1-3-Memcache\"><a href=\"#1-3-Memcache\" class=\"headerlink\" title=\"1.3 Memcache\"></a>1.3 Memcache</h4><ol>\n<li>数据都在内存中，一般不持久化</li>\n<li>支持简单的key-value模式，支持类型单一</li>\n<li>一般是作为缓存数据库辅助持久化的数据库</li>\n</ol>\n<h4 id=\"1-4-Redis\"><a href=\"#1-4-Redis\" class=\"headerlink\" title=\"1.4 Redis\"></a>1.4 Redis</h4><ol>\n<li>数据都在内存中，支持持久化，主要用于备份恢复</li>\n<li>除了简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset</li>\n<li>一般是作为缓存数据库辅助持久化的数据库</li>\n</ol>\n<h4 id=\"1-5-MongoDB\"><a href=\"#1-5-MongoDB\" class=\"headerlink\" title=\"1.5 MongoDB\"></a>1.5 MongoDB</h4><ol>\n<li>高性能、开源、模式自由(schema free)的文档型数据库</li>\n<li>数据都在内存中，如果内存不足，吧不常用的数据保存到硬盘</li>\n<li>虽然是key-value模式，但是对value(尤其是json)，提供了丰富的查询功能</li>\n<li>支持二进制数据及大型对象</li>\n<li>可以根据数据的特点代替RDBMS，成为独立的数据库，或者配合RDBMS，存储特定的数据</li>\n</ol>\n<h4 id=\"1-6-行式存储数据库\"><a href=\"#1-6-行式存储数据库\" class=\"headerlink\" title=\"1.6 行式存储数据库\"></a>1.6 行式存储数据库</h4><h5 id=\"1-6-1-行式数据库\"><a href=\"#1-6-1-行式数据库\" class=\"headerlink\" title=\"1.6.1 行式数据库\"></a>1.6.1 行式数据库</h5><p>​\t字段一行一行对应上面的字段存储内容</p>\n<h5 id=\"1-6-2-列式数据库\"><a href=\"#1-6-2-列式数据库\" class=\"headerlink\" title=\"1.6.2 列式数据库\"></a>1.6.2 列式数据库</h5><p>​\t一列一列存储数据</p>\n<ol>\n<li><p>Hbase</p>\n<p>Hbase是Hadoop项目中的数据库，它用于需要对大量的数据进行随机、实时的读写操作场景中</p>\n<p>Hbase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表</p>\n</li>\n<li><p>Cassandra</p>\n<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程</p>\n</li>\n</ol>\n<h4 id=\"1-7-图关系型数据库\"><a href=\"#1-7-图关系型数据库\" class=\"headerlink\" title=\"1.7 图关系型数据库\"></a>1.7 图关系型数据库</h4><p>​\t主要应用于：社会关系、公共交通网络、地图及网络拓扑 </p>\n<h3 id=\"二、Redis概述和安装\"><a href=\"#二、Redis概述和安装\" class=\"headerlink\" title=\"二、Redis概述和安装\"></a>二、Redis概述和安装</h3><h4 id=\"1-特点\"><a href=\"#1-特点\" class=\"headerlink\" title=\"1.特点\"></a>1.特点</h4><ul>\n<li>Redis是一个开源的key-value存储系统</li>\n<li>和Memcached类似，它支持存储的value类型相对更多</li>\n<li>这些数据类型都支持push&#x2F;pop，add&#x2F;remove及取交集和差集及更丰富的操作，而且这些操作都是原子性</li>\n<li>Redis支持各种不同的排序</li>\n<li>为了保证效率，数据都是缓存在内存中</li>\n<li>Redis会周期性的吧更新的数据写入到磁盘中，或者把修改操作写入追加的记录文件中</li>\n<li>并且在此基础上实现了master-slave主从同步</li>\n</ul>\n<h4 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2.应用场景\"></a>2.应用场景</h4><p>配合关系型数据库做高速缓存</p>\n<ul>\n<li>高频次，降低数据库IO</li>\n<li>分布式架构，做session共享</li>\n<li>缓存加速</li>\n<li>排行榜场景</li>\n<li>分布式计数器，锁，会话…</li>\n</ul>\n<h4 id=\"3-安装\"><a href=\"#3-安装\" class=\"headerlink\" title=\"3.安装\"></a>3.安装</h4><h5 id=\"3-1-安装C语言的编译环境\"><a href=\"#3-1-安装C语言的编译环境\" class=\"headerlink\" title=\"3.1 安装C语言的编译环境\"></a>3.1 安装C语言的编译环境</h5><blockquote>\n<p>yum install gcc</p>\n<p>gcc –version</p>\n</blockquote>\n<h5 id=\"3-2-解压Redis压缩文件\"><a href=\"#3-2-解压Redis压缩文件\" class=\"headerlink\" title=\"3.2 解压Redis压缩文件\"></a>3.2 解压Redis压缩文件</h5><blockquote>\n<p>tar -zxvf redis-6.2.1.tar.gz</p>\n</blockquote>\n<h5 id=\"3-3-进入Redis解压目录里面进行编译\"><a href=\"#3-3-进入Redis解压目录里面进行编译\" class=\"headerlink\" title=\"3.3 进入Redis解压目录里面进行编译\"></a>3.3 进入Redis解压目录里面进行编译</h5><blockquote>\n<p>cd redis-6.2.1</p>\n<p>make</p>\n<ul>\n<li>make报错 -Jemalloc&#x2F;jemalloc,h:没有这个文件</li>\n<li>第一步：查看gcc 版本是否安装成功</li>\n<li>第二步：make distclean</li>\n<li>第三步：make 再次进行编译</li>\n</ul>\n</blockquote>\n<h5 id=\"3-4-编译好之后进行安装\"><a href=\"#3-4-编译好之后进行安装\" class=\"headerlink\" title=\"3.4 编译好之后进行安装\"></a>3.4 编译好之后进行安装</h5><blockquote>\n<p>make install</p>\n</blockquote>\n<h5 id=\"3-5-查看安装目录\"><a href=\"#3-5-查看安装目录\" class=\"headerlink\" title=\"3.5 查看安装目录\"></a>3.5 查看安装目录</h5><blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>默认安装目录：</p>\n<ul>\n<li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>\n<li>redis-check-aof:修复有问题的AOF文件</li>\n<li>redis-check-dump:修复有问题的dump。rdb文件</li>\n<li>redis-sentinel:Redis集群使用</li>\n<li><strong><code>redis-server</code></strong>:Redis服务器启动命令</li>\n<li><strong><code>redis-cli</code></strong>:客户端，操作入口</li>\n</ul>\n</blockquote>\n<h5 id=\"3-6-启动Redis\"><a href=\"#3-6-启动Redis\" class=\"headerlink\" title=\"3.6 启动Redis\"></a>3.6 启动Redis</h5><h6 id=\"3-6-1-前台启动-不推荐\"><a href=\"#3-6-1-前台启动-不推荐\" class=\"headerlink\" title=\"3.6.1 前台启动(不推荐)\"></a>3.6.1 前台启动(不推荐)</h6><p>​\t前台启动，命令行窗口不能关闭，否则服务器停止</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>redis-server</p>\n</blockquote>\n<h6 id=\"3-6-2-后台启动-推荐\"><a href=\"#3-6-2-后台启动-推荐\" class=\"headerlink\" title=\"3.6.2 后台启动(推荐)\"></a>3.6.2 后台启动(推荐)</h6><p>​\t后台启动，命令行窗口不显示，服务器后台运行，不会停止</p>\n<ol>\n<li><p><strong>进入redis-6.2.1目录中</strong></p>\n<blockquote>\n<p>cd &#x2F;opt&#x2F;redis-6.2.1</p>\n</blockquote>\n</li>\n<li><p><strong>复制redis.conf</strong></p>\n<blockquote>\n<p>cp redis.conf &#x2F;etc&#x2F;redis.conf</p>\n</blockquote>\n</li>\n<li><p><strong>修改etc下的redis.conf的复制文件</strong></p>\n<blockquote>\n<p>cd &#x2F;etc</p>\n<p>vi redis.conf</p>\n<p>修改<code>daemonize no</code>改为 <code>yes</code></p>\n</blockquote>\n</li>\n<li><p><strong>启动</strong></p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>redis-server &#x2F;etc&#x2F;redis.conf</p>\n<p>ps -ef | grep redis   查询是否启动</p>\n</blockquote>\n</li>\n<li><p><strong>客户端连接</strong></p>\n<blockquote>\n<p>redis-cli </p>\n<p>ping   测试连接</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"3-7-关闭Redis\"><a href=\"#3-7-关闭Redis\" class=\"headerlink\" title=\"3.7 关闭Redis\"></a>3.7 关闭Redis</h5><ol>\n<li>单实例关闭：redis-cli shutdown</li>\n<li>也可以进入终端关闭：shutdown</li>\n<li>多实例关闭：redis-cli -p6379(端口号) shutdown</li>\n<li>kill -9 进程号</li>\n</ol>\n<h4 id=\"4-Redis相关知识\"><a href=\"#4-Redis相关知识\" class=\"headerlink\" title=\"4. Redis相关知识\"></a>4. Redis相关知识</h4><p>​\tRedis端口的由来：默认端口6379，6379对应的是按键机的Merz，Alessia <code>Merz</code>是一名演员</p>\n<ul>\n<li>Redis默认提供了<code>16个数据库</code>，类似数组下标从0开始初始<code>默认使用0号数据库</code></li>\n<li>使用命令 <strong><code>selec</code></strong> <dbid>来切换数据库。例如：select 8，切换到8号数据库</li>\n<li>统一密码管理。所有库同样密码</li>\n<li>**<code>dbsize</code>**查看当前数据库的key的数量</li>\n<li>**<code>flushdb</code>**清空当前数据库</li>\n<li>**<code>flushall</code>**通杀全部库</li>\n</ul>\n<p>​\t多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞知道超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如<strong>使用线程池</strong>)</p>\n<p>Memcache：<code>多线程+锁(memcached)</code></p>\n<p>Redis：<code>单线程+多路IO复用</code></p>\n<p><code>Redis与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用</code></p>\n<h3 id=\"三、常用的五大数据类型\"><a href=\"#三、常用的五大数据类型\" class=\"headerlink\" title=\"三、常用的五大数据类型\"></a>三、常用的五大数据类型</h3><h4 id=\"1-Redis键-key\"><a href=\"#1-Redis键-key\" class=\"headerlink\" title=\"1.Redis键(key)\"></a>1.Redis键(key)</h4><blockquote>\n<ul>\n<li>keys *查看当前库所有key(匹配：key *1)</li>\n<li>exists key 判断某个key是否存在</li>\n<li>type key 查看你的key是什么类型</li>\n<li>del key 删除指定的key数据</li>\n<li><code>unlink key 根据value选择非阻塞删除</code></li>\n<li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</li>\n<li>expire key 10 10秒钟：为给定的key设置过期时间</li>\n<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>\n<li>select命令切换数据库</li>\n<li>dbsize查看当前数据库的key的数量</li>\n<li>flushdb清空当前库</li>\n<li>flushall通杀全部库</li>\n</ul>\n</blockquote>\n<h4 id=\"2-Redis字符串-String\"><a href=\"#2-Redis字符串-String\" class=\"headerlink\" title=\"2.Redis字符串(String)\"></a>2.Redis字符串(String)</h4><h5 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h5><ol>\n<li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value</li>\n<li>String类型是二进制安全的，意味着Redis的String可以包含任何数据，比如jpg图片或者序列化对象</li>\n<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li>\n</ol>\n<h5 id=\"2-2-常用命令\"><a href=\"#2-2-常用命令\" class=\"headerlink\" title=\"2.2 常用命令\"></a>2.2 常用命令</h5><p>set <key><value>添加键值对</p>\n<p>get <key>查询对应键值</p>\n<p>append <key><value>将给定的<value>追加到原值的末尾</p>\n<p>strlen <key>获得值的长度</p>\n<p>setnx <key><value>只有在key不存在时 设置key的值</p>\n<p>incr <key> 将key中存储的数字增值1</p>\n<p>​\t\t   只能对数字值操作，如果为空，新增值为1</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h3 id=\"一、NoSQL数据库简介\"><a href=\"#一、NoSQL数据库简介\" class=\"headerlink\" title=\"一、NoSQL数据库简介\"></a>一、NoSQL数据库简介</h3><h4 id=\"1-1-NoSQL数据库概述\"><a href=\"#1-1-NoSQL数据库概述\" class=\"headerlink\" title=\"1.1 NoSQL数据库概述\"></a>1.1 NoSQL数据库概述</h4><p>NoSQL(Not Only SQL)不仅仅是SQL，泛指非关系性数据库，NoSQL不依赖业务逻辑方式存储，而以简单的Key-value模式存储，因此大大的增加了数据库的扩展能力</p>\n<blockquote>\n<p>不遵循SQL标准</p>\n<p>不支持ACID(原子性，一致性，隔离性，持久性)</p>\n<p>远超于SQL的性能</p>\n</blockquote>\n<h4 id=\"1-2-NoSQL适用场景\"><a href=\"#1-2-NoSQL适用场景\" class=\"headerlink\" title=\"1.2 NoSQL适用场景\"></a>1.2 NoSQL适用场景</h4><blockquote>\n<p>对数据高并发的读写</p>\n<p>海量数据的读写</p>\n<p>对数据高扩展性</p>\n</blockquote>\n<h4 id=\"1-3-Memcache\"><a href=\"#1-3-Memcache\" class=\"headerlink\" title=\"1.3 Memcache\"></a>1.3 Memcache</h4><ol>\n<li>数据都在内存中，一般不持久化</li>\n<li>支持简单的key-value模式，支持类型单一</li>\n<li>一般是作为缓存数据库辅助持久化的数据库</li>\n</ol>\n<h4 id=\"1-4-Redis\"><a href=\"#1-4-Redis\" class=\"headerlink\" title=\"1.4 Redis\"></a>1.4 Redis</h4><ol>\n<li>数据都在内存中，支持持久化，主要用于备份恢复</li>\n<li>除了简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset</li>\n<li>一般是作为缓存数据库辅助持久化的数据库</li>\n</ol>\n<h4 id=\"1-5-MongoDB\"><a href=\"#1-5-MongoDB\" class=\"headerlink\" title=\"1.5 MongoDB\"></a>1.5 MongoDB</h4><ol>\n<li>高性能、开源、模式自由(schema free)的文档型数据库</li>\n<li>数据都在内存中，如果内存不足，吧不常用的数据保存到硬盘</li>\n<li>虽然是key-value模式，但是对value(尤其是json)，提供了丰富的查询功能</li>\n<li>支持二进制数据及大型对象</li>\n<li>可以根据数据的特点代替RDBMS，成为独立的数据库，或者配合RDBMS，存储特定的数据</li>\n</ol>\n<h4 id=\"1-6-行式存储数据库\"><a href=\"#1-6-行式存储数据库\" class=\"headerlink\" title=\"1.6 行式存储数据库\"></a>1.6 行式存储数据库</h4><h5 id=\"1-6-1-行式数据库\"><a href=\"#1-6-1-行式数据库\" class=\"headerlink\" title=\"1.6.1 行式数据库\"></a>1.6.1 行式数据库</h5><p>​\t字段一行一行对应上面的字段存储内容</p>\n<h5 id=\"1-6-2-列式数据库\"><a href=\"#1-6-2-列式数据库\" class=\"headerlink\" title=\"1.6.2 列式数据库\"></a>1.6.2 列式数据库</h5><p>​\t一列一列存储数据</p>\n<ol>\n<li><p>Hbase</p>\n<p>Hbase是Hadoop项目中的数据库，它用于需要对大量的数据进行随机、实时的读写操作场景中</p>\n<p>Hbase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表</p>\n</li>\n<li><p>Cassandra</p>\n<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程</p>\n</li>\n</ol>\n<h4 id=\"1-7-图关系型数据库\"><a href=\"#1-7-图关系型数据库\" class=\"headerlink\" title=\"1.7 图关系型数据库\"></a>1.7 图关系型数据库</h4><p>​\t主要应用于：社会关系、公共交通网络、地图及网络拓扑 </p>\n<h3 id=\"二、Redis概述和安装\"><a href=\"#二、Redis概述和安装\" class=\"headerlink\" title=\"二、Redis概述和安装\"></a>二、Redis概述和安装</h3><h4 id=\"1-特点\"><a href=\"#1-特点\" class=\"headerlink\" title=\"1.特点\"></a>1.特点</h4><ul>\n<li>Redis是一个开源的key-value存储系统</li>\n<li>和Memcached类似，它支持存储的value类型相对更多</li>\n<li>这些数据类型都支持push&#x2F;pop，add&#x2F;remove及取交集和差集及更丰富的操作，而且这些操作都是原子性</li>\n<li>Redis支持各种不同的排序</li>\n<li>为了保证效率，数据都是缓存在内存中</li>\n<li>Redis会周期性的吧更新的数据写入到磁盘中，或者把修改操作写入追加的记录文件中</li>\n<li>并且在此基础上实现了master-slave主从同步</li>\n</ul>\n<h4 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2.应用场景\"></a>2.应用场景</h4><p>配合关系型数据库做高速缓存</p>\n<ul>\n<li>高频次，降低数据库IO</li>\n<li>分布式架构，做session共享</li>\n<li>缓存加速</li>\n<li>排行榜场景</li>\n<li>分布式计数器，锁，会话…</li>\n</ul>\n<h4 id=\"3-安装\"><a href=\"#3-安装\" class=\"headerlink\" title=\"3.安装\"></a>3.安装</h4><h5 id=\"3-1-安装C语言的编译环境\"><a href=\"#3-1-安装C语言的编译环境\" class=\"headerlink\" title=\"3.1 安装C语言的编译环境\"></a>3.1 安装C语言的编译环境</h5><blockquote>\n<p>yum install gcc</p>\n<p>gcc –version</p>\n</blockquote>\n<h5 id=\"3-2-解压Redis压缩文件\"><a href=\"#3-2-解压Redis压缩文件\" class=\"headerlink\" title=\"3.2 解压Redis压缩文件\"></a>3.2 解压Redis压缩文件</h5><blockquote>\n<p>tar -zxvf redis-6.2.1.tar.gz</p>\n</blockquote>\n<h5 id=\"3-3-进入Redis解压目录里面进行编译\"><a href=\"#3-3-进入Redis解压目录里面进行编译\" class=\"headerlink\" title=\"3.3 进入Redis解压目录里面进行编译\"></a>3.3 进入Redis解压目录里面进行编译</h5><blockquote>\n<p>cd redis-6.2.1</p>\n<p>make</p>\n<ul>\n<li>make报错 -Jemalloc&#x2F;jemalloc,h:没有这个文件</li>\n<li>第一步：查看gcc 版本是否安装成功</li>\n<li>第二步：make distclean</li>\n<li>第三步：make 再次进行编译</li>\n</ul>\n</blockquote>\n<h5 id=\"3-4-编译好之后进行安装\"><a href=\"#3-4-编译好之后进行安装\" class=\"headerlink\" title=\"3.4 编译好之后进行安装\"></a>3.4 编译好之后进行安装</h5><blockquote>\n<p>make install</p>\n</blockquote>\n<h5 id=\"3-5-查看安装目录\"><a href=\"#3-5-查看安装目录\" class=\"headerlink\" title=\"3.5 查看安装目录\"></a>3.5 查看安装目录</h5><blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>默认安装目录：</p>\n<ul>\n<li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>\n<li>redis-check-aof:修复有问题的AOF文件</li>\n<li>redis-check-dump:修复有问题的dump。rdb文件</li>\n<li>redis-sentinel:Redis集群使用</li>\n<li><strong><code>redis-server</code></strong>:Redis服务器启动命令</li>\n<li><strong><code>redis-cli</code></strong>:客户端，操作入口</li>\n</ul>\n</blockquote>\n<h5 id=\"3-6-启动Redis\"><a href=\"#3-6-启动Redis\" class=\"headerlink\" title=\"3.6 启动Redis\"></a>3.6 启动Redis</h5><h6 id=\"3-6-1-前台启动-不推荐\"><a href=\"#3-6-1-前台启动-不推荐\" class=\"headerlink\" title=\"3.6.1 前台启动(不推荐)\"></a>3.6.1 前台启动(不推荐)</h6><p>​\t前台启动，命令行窗口不能关闭，否则服务器停止</p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>redis-server</p>\n</blockquote>\n<h6 id=\"3-6-2-后台启动-推荐\"><a href=\"#3-6-2-后台启动-推荐\" class=\"headerlink\" title=\"3.6.2 后台启动(推荐)\"></a>3.6.2 后台启动(推荐)</h6><p>​\t后台启动，命令行窗口不显示，服务器后台运行，不会停止</p>\n<ol>\n<li><p><strong>进入redis-6.2.1目录中</strong></p>\n<blockquote>\n<p>cd &#x2F;opt&#x2F;redis-6.2.1</p>\n</blockquote>\n</li>\n<li><p><strong>复制redis.conf</strong></p>\n<blockquote>\n<p>cp redis.conf &#x2F;etc&#x2F;redis.conf</p>\n</blockquote>\n</li>\n<li><p><strong>修改etc下的redis.conf的复制文件</strong></p>\n<blockquote>\n<p>cd &#x2F;etc</p>\n<p>vi redis.conf</p>\n<p>修改<code>daemonize no</code>改为 <code>yes</code></p>\n</blockquote>\n</li>\n<li><p><strong>启动</strong></p>\n<blockquote>\n<p>cd &#x2F;usr&#x2F;local&#x2F;bin</p>\n<p>redis-server &#x2F;etc&#x2F;redis.conf</p>\n<p>ps -ef | grep redis   查询是否启动</p>\n</blockquote>\n</li>\n<li><p><strong>客户端连接</strong></p>\n<blockquote>\n<p>redis-cli </p>\n<p>ping   测试连接</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"3-7-关闭Redis\"><a href=\"#3-7-关闭Redis\" class=\"headerlink\" title=\"3.7 关闭Redis\"></a>3.7 关闭Redis</h5><ol>\n<li>单实例关闭：redis-cli shutdown</li>\n<li>也可以进入终端关闭：shutdown</li>\n<li>多实例关闭：redis-cli -p6379(端口号) shutdown</li>\n<li>kill -9 进程号</li>\n</ol>\n<h4 id=\"4-Redis相关知识\"><a href=\"#4-Redis相关知识\" class=\"headerlink\" title=\"4. Redis相关知识\"></a>4. Redis相关知识</h4><p>​\tRedis端口的由来：默认端口6379，6379对应的是按键机的Merz，Alessia <code>Merz</code>是一名演员</p>\n<ul>\n<li>Redis默认提供了<code>16个数据库</code>，类似数组下标从0开始初始<code>默认使用0号数据库</code></li>\n<li>使用命令 <strong><code>selec</code></strong> <dbid>来切换数据库。例如：select 8，切换到8号数据库</li>\n<li>统一密码管理。所有库同样密码</li>\n<li>**<code>dbsize</code>**查看当前数据库的key的数量</li>\n<li>**<code>flushdb</code>**清空当前数据库</li>\n<li>**<code>flushall</code>**通杀全部库</li>\n</ul>\n<p>​\t多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞知道超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如<strong>使用线程池</strong>)</p>\n<p>Memcache：<code>多线程+锁(memcached)</code></p>\n<p>Redis：<code>单线程+多路IO复用</code></p>\n<p><code>Redis与Memcache三点不同：支持多数据类型，支持持久化，单线程+多路IO复用</code></p>\n<h3 id=\"三、常用的五大数据类型\"><a href=\"#三、常用的五大数据类型\" class=\"headerlink\" title=\"三、常用的五大数据类型\"></a>三、常用的五大数据类型</h3><h4 id=\"1-Redis键-key\"><a href=\"#1-Redis键-key\" class=\"headerlink\" title=\"1.Redis键(key)\"></a>1.Redis键(key)</h4><blockquote>\n<ul>\n<li>keys *查看当前库所有key(匹配：key *1)</li>\n<li>exists key 判断某个key是否存在</li>\n<li>type key 查看你的key是什么类型</li>\n<li>del key 删除指定的key数据</li>\n<li><code>unlink key 根据value选择非阻塞删除</code></li>\n<li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</li>\n<li>expire key 10 10秒钟：为给定的key设置过期时间</li>\n<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>\n<li>select命令切换数据库</li>\n<li>dbsize查看当前数据库的key的数量</li>\n<li>flushdb清空当前库</li>\n<li>flushall通杀全部库</li>\n</ul>\n</blockquote>\n<h4 id=\"2-Redis字符串-String\"><a href=\"#2-Redis字符串-String\" class=\"headerlink\" title=\"2.Redis字符串(String)\"></a>2.Redis字符串(String)</h4><h5 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h5><ol>\n<li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value</li>\n<li>String类型是二进制安全的，意味着Redis的String可以包含任何数据，比如jpg图片或者序列化对象</li>\n<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li>\n</ol>\n<h5 id=\"2-2-常用命令\"><a href=\"#2-2-常用命令\" class=\"headerlink\" title=\"2.2 常用命令\"></a>2.2 常用命令</h5><p>set <key><value>添加键值对</p>\n<p>get <key>查询对应键值</p>\n<p>append <key><value>将给定的<value>追加到原值的末尾</p>\n<p>strlen <key>获得值的长度</p>\n<p>setnx <key><value>只有在key不存在时 设置key的值</p>\n<p>incr <key> 将key中存储的数字增值1</p>\n<p>​\t\t   只能对数字值操作，如果为空，新增值为1</p>\n"},{"title":"RabbitMQ消息队列","date":"2023-06-18T03:18:57.000Z","cover":"/img/images/Rabbit.png","_content":"\n# RabbitMQ\n\n### 1.什么是MQ\n\n​\tMQ(message queue),字面意思，本质上是一个队列，FIFO先进先出，只不过队列中存储的是消息，还是一种跨进程通信的机制，用于上下游传递消息，MQ是一种非常常见的上下游`逻辑解耦+物理解耦`的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。\n\n#### 1.1为什么要用MQ\n\n1. **流量消峰**\n\n   流量削峰，如果观看抽奖或秒杀系统的请求监控曲线，你就会发现这类系统在活动开放的时间段内会出现一个波峰，而在活动未开放时，系统的请求量、机器负载一般都是比较平稳的。为了节省机器资源，我们不可能时时都提供最大化的资源能力来支持短时间的高峰请求。所以需要使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控\n\n   **例子**：有一个订单系统，最多处理一万次订单，这个处理能力应付正常时段的下单绰绰有余，正常下单一秒就有返回结果，但是在高峰期，如果有两万次下单操作系统处理不过来，只能限制订单超过一万不允许用户下单，使用消息队列做缓冲，我们可以取消这个限制，吧一秒内下的订单分散成一段时间来处理，这时有些用户下单后十几秒后才有下单成功的结果，导致用户体验不佳。\n\n   `如果请求过多，超过服务器压力点，会导致宕机,MQ就是让高峰期的请求数达到一个可控范围，使服务器保持稳定，不会宕机`\n\n2. **应用解耦**\n\n   模块之间的调用十分复杂，为了降低模块与模块之间调用依赖，使用MQ将两系统分开,不直接调用系统接口,减轻两系统依赖关系\n\n   **例子**：电商应用为例，应用中有订单系统，库存系统，物流系统，支付系统，用户创建订单后，如果耦合调用库存系统，物流系统，支付系统，任何一个子系统出现故障，都会造成下单操作异常，当转变成基于消息队列的方式后，系统调用的问题会减少很多比如物流系统因为发送故障，需要几分钟来修复，在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成，当物流系统恢复后，继续处理订单信息即可，订单用户感受不到物流系统的故障，提升系统的可用性。\n\n3. **异步处理**\n\n   异步指一个执行中的任务，拆开成多个子任务各自执行。异步与同步处理相对，同步指多个执行中的子任务，等待所有子任务执行完再继续执行。异步的作用是使有I/O操作的任务最大化利用处理器的计算，以达到缩短任务的完成时间。\n\n### 2.RabbitMQ概念\n\n​\tRabbitMQ是一个消息中间件：它接受并转发消息，你可以把它当做一个传递点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人哪里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件，它不处理快件，而是接收，存储，转发消息数据\n\n#### 2.1四大核心概念\n\n1. 生产者\n\n   产生数据发送消息的程序是生产者\n\n2. 交换机\n\n   交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面他将消息推送到队列中，交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者吧消息丢弃，这个得有交换机类型决定\n\n3. 队列\n\n   队列是RabbitMQ内部使用得一种数据结构，尽管消息流经RabbitMQ和应用程序，但他们只能存储在队列中，队列受主机得内存和磁盘限制和约束，本质上是一个大得消息缓冲区，许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据，这就是我们使用队列得方式\n\n4. 消费者\n\n   消费与接收具有相似得含义。消费者大多时候是一个等待接收消息得程序，请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。\n\n3.RabbitMQ核心部分\n\n1. Hello World(简单模式)\n2. Work queues(工作模式)\n3. Publish/Subscribe(发布订阅模式)\n4. Routing(路由模式)\n5. Topics(主题模式)\n6. Publisher Confirms(发布确认模式)\n\n### 3.安装RabbitMQ\n\nRbbitMQ官网：https://www.rabbitmq.com/\n\nRabbitMQ及环境下载：https://packagecloud.io/rabbitmq/\n\n1. 安装Erlang环境\n\n```linux\nrpm -ivh erlang-xx.x-x.linux版本.x86_64.rpm\n```\n\n2. 安装socat依赖\n\n```\nyum install socat -y\n```\n\n3. 安装rabbitMQ-server\n\n```\nrpm -ivh rabbitmq-server-x.x.x-linux版本.noarch.rpm\n```\n\n#### 3.1**常用命令**\n\n1. 添加开机启动RabbitMQ服务\n\n   ```\n   chkconfig rabbitmq-server on\n   ```\n\n2. 启动RabbitMQ服务\n\n   ```\n   /sbin/service rabbitmq-server start\n   ```\n\n3. 查看RabbitMQ服务状态\n\n   ```\n   /sbin/service rabbitmq-server status\n   ```\n\n4. 停止RabbitMQ服务状态\n\n   ```\n   /sbin/service rabbitmq-server stop\n   ```\n\n5. 开启Web管理插件\n\n   ```\n   rabbitmq-plugins enable rabbitmq_management\n   \n   用默认账户密码(guest)访问地址http：//安装rabbitmq的主机ip地址:15672\n   这里会出现一个权限问题\n   ```\n\n   > 注意：15672端口必须开启或者关闭防火墙否则无法访问,正式项目不建议关闭防火墙\n   >\n   > systemctl stop firewalld  \n   >\n   > systemctl enabled firewalld\n   >\n   > systemctl start firewalld\n   >\n   > systemctl status firewalld\n\n6. 查看RabbitMQ有那些用户\n\n   ```\n   rabbitmqctl list_users\n   ```\n\n7. 添加一个新的用户\n\n   1. 创建账号\n\n      > rabbitmqctl add_user 用户名 密码\n\n   2. 设置用户角色\n\n      > rabbitmqctl set_user_tags 用户名 权限\n      >\n      > 例：rabbitmqctl set_user_tags user administrator\n\n   3. 设置用户权限\n\n      > set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n      >\n      > 例如：rabbitmq set_permissions -p\"/\" admin \".*\" \".*\"\".*\"\n      >\n      > 用户user_admin具有/vhost1这个virtual host中所有资源的配置、写、读权限\n\n   4. 修改密码\n\n      > rabbitmqctl  change_password  用户名  '新密码'\n      >\n      > 例：rabbitmqctl  change_password  admin  'root'\n\n### 4.Hello World(简单模式)\n\n#### 4.1创建maven项目\n\n#### 4.2导入依赖\n\n> <!--        rabbitmq依赖客户端-->\n>\n> <dependency>    \n>\n> ​\t<groupId>com.rabbitmq</groupId>    \n>\n> ​\t<artifactId>amqp-client</artifactId>    \n>\n> ​\t<version>5.18.0</version>\n>\n> </dependency>\n>\n> <!--        操作文件流依赖-->\n>\n> <dependency>    \n>\n> ​\t<groupId>commons-io</groupId>    \n>\n> ​\t<artifactId>commons-io</artifactId>    \n>\n> ​\t<version>2.11.0</version>\n>\n> </dependency>\n\n#### 4.3构建代码\n\n​\t构建一个生产者P端，消费者C端，通过P端发消息给队列传递给C端，这个队列采用RabbitMQ来保留消息缓冲区\n\n##### 4.3.1构建生产者\n\n```java\n/**\n * 生产者\n * 生产者：发送消息\n */\npublic class Producer {\n    //队列名称\n    public static final String QUEUE_NAME = \"hello\";\n    //发消息\n    public static void main(String[] args) throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        //设置工厂ip,连接RabbitMQ的队列\n        factory.setHost(\"192.168.100.137\");\n        //设置用户名和密码\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"root\");\n        //创建连接  此处需要处理一个异常\n        Connection connection = factory.newConnection();\n        //获取信道\n        Channel channel = connection.createChannel();\n        /**\n         * 生成一个队列\n         * @param String queue,                 队列名称\n         * @param boolean durable               是否保存消息,队列里的消息是否持久化，默认队列里的消息存储在内存中\n         * @param boolean exclusive,            该队列是否只对一个消费者提供消费， 是否进行消息的共享，true可以多个消费者消费，默认情况下false：只能一个消费者\n         * @param boolean autoDelete            是否自动删除，最后一个消费者断开连接后该队列是否自动删除\n         * @param Map<String, Object> arguments 其他参数，如死信消息、延迟消息、\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        //发送消息\n        String message = \"hello world\";\n        //利用信道发布消息\n        /**\n         *@param String exchange            交换机   默认交换机，可以忽略\n         * @param String routingKey         路由key   填写队列名称\n         * @param BasicProperties props     参数      无，填写null\n         * @param byte[] body               消息体\n         */\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n        System.out.println(\"发送完毕\");\n    }\n}\n```\n\n> 注意：还需要开放一个5672客户端端口，并且设置当前用户Permissions权限\n\n##### 4.3.1构建消费者\n\n```java\n//消费者\n//接收消息\npublic class Consumer {\n    //队列名称   接收此队列消息\n    public static final String QUEUE_NAME = \"hello\";\n    //接收消息\n    public static void main(String[] args) throws Exception {\n        //创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"192.168.100.137\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"root\");\n        Connection connection = factory.newConnection();\n        //建立信道  利用信道接收消息\n        Channel channel = connection.createChannel();\n        //声明  接收消息\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            System.out.println(\"消息体：\" + new String(message.getBody()));\n        };\n        //声明  取消消息\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println(\"消费消息被中断时执行\");\n        // 消费者，接收消息\n        /**\n         * @parma String queue                      队列名\n         * @parma boolean autoAck                   是否自动应答   消费成功后是否自动应答\n         * @parma DeliverCallback deliverCallback   消息的回调     消息未成功消费的回调\n         * @parma CancelCallback cancelCallback     消息的回调     消费者取消消息的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n}\n```\n\n### 5.Work Queues(工作模式)\n\n​\t工作队列(任务队列)的主要思想是避免立即执行资源密集型任务。而不得不等待它完成。相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终稿执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n#### 5.1轮询分发消息\n\n1. 抽取工具类\n\n   ```java\n   //rabbitmq创建连接信道\n   public class RabbitMQUtils {\n       //得到一个连接信道\n       public static Channel getChannel() throws Exception {\n           ConnectionFactory factory = new ConnectionFactory();\n           factory.setHost(\"192.168.100.137\");\n           factory.setUsername(\"admin\");\n           factory.setPassword(\"root\");\n           Connection connection = factory.newConnection();\n           Channel channel = connection.createChannel();\n           return channel;\n       }\n   }\n   ```\n   \n2. 消费者代码(接收消息的工作线程)\n\n   ```java\n   //工作线程01\n   public class Work01 {\n       //队列名称\n       public static final String QUEUE_NAME = \"hello\";\n       //接收消息\n       public static void main(String[] args) throws Exception {\n   \n           Channel channel = RabbitMQUtils.getChannel();\n           //消息接收\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(new String(message.getBody()));\n           //消息取消\n           CancelCallback cancelCallback = (consumerTag) -> System.out.println(\"消息被消费者取消：\" + consumerTag);\n           //消息的接收\n           System.out.println(\"C1线程等待中...\");\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n       }\n   }\n   ```\n\n3. 生产者代码(发送消息)\n\n   ```java\n   public class Task01 {\n       //队列名称\n       public static final String QUEUE_NAME = \"hello\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明队列\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //从控制台当中接收信息\n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               System.out.println(\"发送消息完成：\" + message);\n           }\n       }\n   }\n   ```\n\n#### 5.2消息应答\n\n1. 消息应答概念\n\n   消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然挂掉了，RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因它无法接收到。\n\n   `为了保证消息在发送过程中不丢失，rabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉rabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。`\n\n2. 自动应答\n\n   消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递消息的数量进行限制，当然这样有可能使得消费者这把由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这样的消息的情况下使用\n\n3. 消息应答的方法\n\n   A.Channel.basicAck(用于肯定确认)\n\n   ​\tRabbitMQ已经知道该消息并且成功处理的消息，可以将其丢弃了\n\n   B.Channel.basicNack(用于否定确认)\n\n   C.Channel.basicReject(用于否定确认)\n\n   ​\t与Channel.basicNack相比少一个参数(批量处理)，不处理该消息了直接拒绝，可以将其丢弃\n\n4. Multiple的解释\n\n   手动应答的好处就是可以批量应答并且减少网络拥堵\n\n   ```java\n   channel.basicAck(deliveryTag,true);\n   ```\n\n   multiple的true和false代表不同意思\n\n   true：代表批量应答channel上未应答的消息\n\n   例：channel上有传送tag的消息5，6，7，8当前tag是8那么此时5-8的这些还未应答的消息都会被确认收到消息的应答\n\n   false：如true相反。一对一应答\n\n5. 消息自动重新入队\n\n   如果消费者由于某些原因丢失连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对列重新排队，如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者，这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息\n\n6. 消息手动应答(代码)\n\n   默认采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n   ```java\n   //消息手动应答并不丢失，并且放回消息队列\n   public class Task02 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n   ```java\n   public class Worker01 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           System.out.println(\"C1等待接收消息处理，短时间处理\");\n           DeliverCallback deliverCallback = ((consumerTag, message) -> {\n               //沉睡一秒\n               try {\n                   Thread.sleep(1000);\n               } catch (InterruptedException e) {\n                   throw new RuntimeException(e);\n               }\n               System.out.println(\"接收到的消息：\" + new String(message.getBody(), \"UTF-8\"));\n               //手动应答\n               /**\n                * @param long deliveryTag     消息的标识\n                * @param boolean multiple     是否批量应答\n                */\n               channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n           });\n           boolean autoAck = false;\n           channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -> System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\")));\n       }\n   }\n   ```\n\n   ```java\n   public class Worker02 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           System.out.println(\"C2等待接收消息处理，长时间处理\");\n           DeliverCallback deliverCallback = ((consumerTag, message) -> {\n               //沉睡一秒\n               try {\n                   Thread.sleep(30000);\n               } catch (InterruptedException e) {\n                   throw new RuntimeException(e);\n               }\n               System.out.println(\"接收到的消息：\" + new String(message.getBody(), \"UTF-8\"));\n               //手动应答\n               /**\n                * @param long deliveryTag     消息的标识\n                * @param boolean multiple     是否批量应答\n                */\n               channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n           });\n           boolean autoAck = false;\n           channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -> System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\")));\n       }\n   }\n   ```\n\n#### 5.3RabbitMQ持久化\n\n1. ##### 概念\n\n   如果保证当RabbitMQ服务突然停掉以后消息生产者发送过来的消息不丢失。默认情况下RabbitMQ退出或由于某种原因崩溃了，它忽视队列和消息，除非告知它不要这么做，确保消息不会丢失需要做两件事`我们需要将队列和消息都标记为持久化`\n\n2. ##### 队列如何实现持久化\n\n   RabbitMQ中的队列默认是非持久化的，RabbitMQ如果重启，该队列就会被删除掉，如果要队列实现持久化，需要声明队列的时候把durable参数设置为持久化\n\n   ```java\n    channel.queueDeclare(QUEUE_NAME, `true持久化，false非持久化`, false, false, null);\n   ```\n\n   > 注意：如果之前声明队列不是持久化，需要把原先队列删除，或者重新创建一个新的持久化队列，不然会出错\n   >\n   > `ITION_FAILED - inequivalent arg 'durable' for queue 'task_queue' in vhost '/': received 'true' but current is 'false'`\n\n3. ##### 消息实现持久化\n\n   消息持久化需要在消息生产者中添加属性，`MessageProperties.PERSISTENT_TEXT_PLAIN`\n\n   ```java\n   channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\"));\n   ```\n\n   > 将消息持久化并不能完全保证消息不丢失，尽管它告诉RabbitMQ将消息保存在磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘，持久性保证并不强，但是对于简单的任务队列来说绰绰有余，如果需要更强的持久化策略，可以用发布确认\n\n4. ##### 不公平分发\n\n   能者多劳，一台机器处理快，一台机器处理慢，轮询分发会导致处理快的机器有一个空闲期等待处理慢的机器处理完毕，为了提高利用每台机器的最高性能，建议使用不公平分发，谁处理的快谁就多处理一点，处理慢的就少处理点\n\n   `为了避免这种情况，创建信道设置参数channel.basicQos(1);默认为轮询分发`\n\n5. ##### 预取值\n\n   本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能`限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。`这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。`该值定义通道上允许的未确认消息的最大数量`。一旦数量达到配置的数量RabbitMO 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ.将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。`虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗`(随机存取存诸器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并目不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中，对于大多数来说，稍微高一点的值将是最佳的\n   \n### 6.发布确认\n\n#### 6.1发布确认原理\n\n​    生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\n​    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n#### 6.2发布确认的策略\n\n1. ##### 开启发布确认的方法\n\n   发布确认默认是没有开启的，如果要开启需要调用方法confirmSelect，每当你要想使用发布确认，都需要在channel上调用该方法\n\n   ```\n   Channel channel = connection.createChannel();\n   channel.confirmSelect();\n   ```\n\n2. ##### 单个确认发布\n\n   这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n   这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n   ```java\n    public static void publishMessageIndividually() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n   \n           for (int i = 0; i < 1000; i++) {\n               String message = \"单个确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               boolean flag = channel.waitForConfirms();\n               if (flag) {\n                   System.out.println(\"消息 \" + i + \" 发送成功\");\n               }\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布单个确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n3. ##### 批量确认发布\n\n   上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n   ```java\n   public static void publishMessageBatch() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n   \n           //批量确认消息大小\n           int batchSize = 100;\n   \n           //开始时间\n           long startTime = System.currentTimeMillis();\n           for (int i = 0; i < 1000; i++) {\n               String message = \"单个确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               //判断是否达到消息大小\n               if (i % batchSize == 0)\n                   //发布确认\n                   channel.waitForConfirms();\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n4. ##### 异步确认发布\n\n   异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说他是利用回调函数来达到消息可靠性传递的,这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的。\t\n\n   ```java\n    //异步确认消息\n       public static void publishMessageAsync() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n           //准备消息的监听器 监听那些消息成功了 那些失败了\n           //消息确认成功，回调函数\n           ConfirmCallback ackCallback = (deliveryTag, multiple) -> {\n               System.out.println(\"确认的消息：\" + deliveryTag);\n           };\n           //消息确认失败，回调函数\n           /**\n            * deliveryTag      消息的标识\n            * multiple         是否批量确认\n            */\n           ConfirmCallback nackCallback = (deliveryTag, multiple) -> {\n               System.out.println(\"未确认的消息：\" + deliveryTag);\n           };\n           //监听失败也监听成功\n           channel.addConfirmListener(ackCallback, nackCallback); //异步通知\n           //批量发送消息\n           for (int i = 0; i < 1000; i++) {\n               String message = \"异步确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n5. ##### 如何处理异步未确认消息\n\n   最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递\n\n   ```java\n   /异步确认消息\n       public static void publishMessageAsync() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n   \n           //线程安全有序的一个哈希表 适用于高并发的情况下\n           //1.轻松的将消息和序号进行关联\n           //2.轻松批量删除条目  只要给到序号\n           //3.支持高并发\n           ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n           //准备消息的监听器 监听那些消息成功了 那些失败了\n           //消息确认成功，回调函数\n           ConfirmCallback ackCallback = (deliveryTag, multiple) -> {\n               //2.删除已经确认的消息  剩下的就是未确认的消息\n               //判断是否为批量\n               if (multiple) {\n                   ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(deliveryTag);\n                   confirmed.clear();\n               } else {\n                   outstandingConfirms.remove(deliveryTag);\n               }\n   \n               System.out.println(\"确认的消息：\" + deliveryTag);\n           };\n           ConfirmCallback nackCallback = (deliveryTag, multiple) -> {\n               //3.打印未确认的消息\n               String message = outstandingConfirms.get(deliveryTag);\n               System.out.println(\"未确认的消息内容\" + message);\n               System.out.println(\"未确认的消息标识：\" + deliveryTag);\n           };\n           //监听失败也监听成功\n           channel.addConfirmListener(ackCallback, nackCallback); //异步通知\n           //批量发送消息\n           for (int i = 0; i < 1000; i++) {\n               String message = \"异步确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               //1.记录所有要发送的消息  消息的总和\n               outstandingConfirms.put(channel.getNextPublishSeqNo(), message);\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n6. ##### 以上三种发布确认速度对比\n\n   **单个确认：**发布1000个消息到同一队列,耗时1863ms。\n\n   **批量确认：**发布1000个批量消息到同一队列,耗时150ms。\n\n   **异步确认：**发布1000个异步消息到同一队列,耗时99ms\n\n### 7.交换机\n\n​\t 在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布/订阅”.为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者\n\n#### 7.1 Exchanges\n\n1. **Exchanges概念**\n\n   ​\tRabbitMO 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n   ​\t相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n2. **Exchanges的类型**\n\n   1. 直接(direct)    路由类型\n   2. 主题(topic)\n   3. 标题(headers)   头类型(不常用)\n   4. 扇出(fanot)     发布订阅类型\n\n3. **无名Exchange**(默认类型)\n\n   在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(\"\")进行标识。\n\n   ```java\n   channel.basicPublish(\"\",\"hello\",null,message.getBytes());\n   ```\n\n   第一个参数是交换机的名称。空字符串表示默认或无名称交换机: 消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n\n#### 7.2 临时队列\n\n​\t每当我们连接到 Rabbt 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列：channel.queueDeclare().getQueue()\n\n#### 7.3 绑定(bindings)\n\nbinding就是exchange和queue之间的桥梁，告诉我们那个队列对应那个交换机\n\n### 8. Fanout(发布订阅模式)\n\n1. Fanout介绍\n\n   Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型\n\n2. Fanout实战\n\n   ```java\n   public class ReceiveLogs01 {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明一个交换机\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n           //声明一个队列   临时队列\n           String queue = channel.queueDeclare().getQueue();\n           //绑定交换机和队列\n           channel.queueBind(queue, EXCHANGES_NAME, \"\");\n           System.out.println(\"等待接收消息...\");\n           //接收消息\n           DeliverCallback deliverCallback = ((consumerTag, message) -> System.out.println(\"01接收到的消息：\" + new String(message.getBody())));\n           channel.basicConsume(queue, true, deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   public class ReceiveLogs02 {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明一个交换机\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n           //声明一个队列   临时队列\n           String queue = channel.queueDeclare().getQueue();\n           //绑定交换机和队列\n           channel.queueBind(queue, EXCHANGES_NAME, \"\");\n           System.out.println(\"等待接收消息...\");\n           //接收消息\n           DeliverCallback deliverCallback = ((consumerTag, message) -> System.out.println(\"02接收到的消息：\" + new String(message.getBody())));\n           channel.basicConsume(queue, true, deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   \n   ```\n\n   ```java\n   //发送消息   交换机\n   public class EmitLog {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n   \n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(EXCHANGES_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n### 9. Direct Exchange(路由模式)\n\n1. Direct Exchange\n\n   队列只对它绑定的交换机的消息感兴趣。绑定用参数: routingKey 来表示也可称该参数为 binding key,创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME,\"routingKey\");绑定之后的意义由其交换类型决定\n\n2. 多重绑定\n\n   当然果exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和fanout 有点类似了，就跟广播差不多\n\n3. 实战\n\n   ```java\n   public class ReceiveLogsDirect01 {\n       //交换机名字\n       private static final String EXCHANGE_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明交换机\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n           channel.queueDeclare(\"console\", false, false, false, null);\n           channel.queueBind(\"console\", EXCHANGE_NAME, \"info\");\n           channel.queueBind(\"console\", EXCHANGE_NAME, \"warning\");\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"一号队列接收到的消息：\" + new String(message.getBody()));\n           channel.basicConsume(\"console\", deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   \n   public class ReceiveLogsDirect02 {\n       //交换机名字\n       private static final String EXCHANGE_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明交换机\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n           channel.queueDeclare(\"disk\", false, false, false, null);\n           channel.queueBind(\"disk\", EXCHANGE_NAME, \"error\");\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"二号队列接收到的消息：\" + new String(message.getBody()));\n           channel.basicConsume(\"disk\", deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   public class DirectLogs {\n       private static final String EXCHANGES_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGES_NAME, BuiltinExchangeType.DIRECT);\n   \n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(EXCHANGES_NAME, \"error\", null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n### 10. Topics(主题模式)\n\n1. 之前类型的问题\n\n   尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型\n\n2. Topic的要求\n\n   ​\t发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它**必须是一个单词列表，以点号分隔开**。这些单词可以是任意单词\n\n   比如说:\"stockusd.nyse\"，\"nyse.vmw”\"quick.orange.rabbit\".这种类型的。当然这个单词列表**最多不能超过 255 个字节**。\n\n   > *(星号)可以代替一个单词\n   >\n   > #(井号)可以代替零个或多个单词\n   >\n   > 当一个队列绑定#，那么这个队列将接收所有数据，就像fanout\n   >\n   > 当一个队列没有出现*和#，那么该队列绑定类型就是direct\n\n3. 实战\n\n   ```java\n   public class ReceiverLogsTopic01 {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n           String QUEUE_NAME = \"Q1\";\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.orange.*\");\n           System.out.println(\"等待接收消息。。。\");\n           //接收消息\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C1接收到的消息：\" + new String(message.getBody(), \"UTF-8\")+ \" 绑定的key：\" + message.getEnvelope().getRoutingKey());\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> System.out.println(consumerTag));\n       }\n   }\n   ```\n\n   ```java\n   public class ReceiverLogsTopic02 {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n           String QUEUE_NAME = \"Q2\";\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"**.rabbit\");\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"lazy.#\");\n           System.out.println(\"等待接收消息。。。\");\n           //接收消息\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C2接收到的消息：\" + new String(message.getBody(), \"UTF-8\")+ \" 绑定的key：\" + message.getEnvelope().getRoutingKey());\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> System.out.println(consumerTag));\n       }\n   }\n   ```\n\n   ```java\n   public class EmitLogTopic {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           Map<String, String> map = new HashMap<>();\n           map.put(\"quick.orange.rabbit\", \"被队列Q1Q2接收\");\n           map.put(\"lazy.orange.elephant\", \"被队列Q1Q2接收\");\n           map.put(\"quick.orange.fox\", \"被队列Q1接收\");\n           map.put(\"lazy.brown.fox\", \"被队列Q2接收\");\n           map.put(\"lazy.pink.rabbit\", \"虽然满足两个绑定但只被队列Q2接收一次\");\n           map.put(\"quick.brown.fox\", \"不匹配任何绑定，没有队列接收，会被丢弃\");\n           map.put(\"quick.orange.male.rabbit\", \"是四个单词不匹配任何绑定会被丢弃\");\n           map.put(\"lazy.orange.male.rabbit\", \"是四个单词但匹配Q2\");\n           for (Map.Entry<String, String> entry : map.entrySet()) {\n               String routingKey = entry.getKey();\n               String message = entry.getValue();\n               channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送：\" + message);\n           }\n       }\n   }\n   ```\n\n### 11. 死信队列\n\n**11.1 死信的概念**\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n**应用场景**：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\n\n**11.2 死信的来源**\n\n- 消息 TTL（存活时间） 过期\n- 队列达到最大长度(队列满了，无法再添加数据到队列中)\n- 消息被拒绝（消费方拒绝应答：basic.reject 或 basic.nack）并且（不放回队列中： requeue=false）\n\n**11.3 死信实战**\n\n消息 TTL（存活时间） 过期\n\n```java\n//死信队列\n//消费者1\npublic class Consumer01 {\n    //普通交换机\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机\n    public static final String DEAD_EXCHANGE = \"dead_exchange\";\n    //普通队列名\n    public static final String NORMAL_QUEUE_NAME = \"normal_queue\";\n    //死信队列名\n    public static final String DEAD_QUEUE_NAME = \"dead_queue\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        //声明交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //声明队列\n        //普通队列\n        /**\n         * 参数 ，满足死信三个条件转发到死信队列\n         */\n        Map<String, Object> arguments = new HashMap<>();\n        //过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长\n        //arguments.put(\"x-message-ttl\", 10000);\n        // 正常队列设置死信交换机\n        arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //设置死信RoutingKey\n        arguments.put(\"x-dead-letter-routing-key\", \"lisi\");\n        channel.queueDeclare(NORMAL_QUEUE_NAME, false, false, false, arguments);\n        //死信队列\n        channel.queueDeclare(DEAD_QUEUE_NAME, false, false, false, null);\n        //绑定交换机和队列\n        channel.queueBind(NORMAL_QUEUE_NAME, NORMAL_EXCHANGE, \"zhangsan\");\n        channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE, \"lisi\");\n        System.out.println(\"等待接收消息....\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C1接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n        channel.basicConsume(NORMAL_QUEUE_NAME, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n```java\n//死信队列\n//消费者2\npublic class Consumer02 {\n    //死信队列名\n    public static final String DEAD_QUEUE_NAME = \"dead_queue\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        System.out.println(\"等待接收消息....\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C2接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n        channel.basicConsume(DEAD_QUEUE_NAME, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n```\n\n```java\n//死信队列\n//生产者\npublic class Producer {\n    //普通交换机\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        //死信消息  设置TTl\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\"10000\").build();\n\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n        }\n    }\n}\n```\n\n队列达到最大长度\n\n```java\n//声明队列\n//普通队列\n/**\n* 参数 ，满足死信三个条件转发到死信队列\n*/\nMap<String, Object> arguments = new HashMap<>();\n//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长\n//arguments.put(\"x-message-ttl\", 10000);\n// 正常队列设置死信交换机\narguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n//设设置队列最大长度\narguments.put(\"x-max-length\",6);\n//设置死信RoutingKey\narguments.put(\"x-dead-letter-routing-key\", \"lisi\");\nchannel.queueDeclare(NORMAL_QUEUE_NAME, false, false, false, arguments);\n```\n\n消息被拒绝\n\n```java\n DeliverCallback deliverCallback = (consumerTag, message) -> {\n if(\"info5\".equals(message)){\n    System.out.println(\"C1拒绝此消息：\"+new String(message.getBody(), \"UTF-8\"));\n    channel.basicReject(message.getEnvelope().getDeliveryTag(),false(是否放回队列))\n }else{\n      System.out.println(\"C1接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n     channel.basicAck(message.getEnvelope().getDeliveryTag(),false)\n }\n }\n//开启手动应答\n channel.basicConsume(NORMAL_QUEUE_NAME, false, deliverCallback, consumerTag -> {\n        });\n```\n\n### 12.延迟队列\n\n##### 12.1 延迟队列概念\n\n延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。\n\n##### 12.2 延迟队列使用场景\n\n1. 订单在十分钟为支付则自动取消\n\n2. 新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒\n\n3. 用户注册成功后，如果三天没有登录则进行短信提示\n\n4. 用户发起退款，如果三天没有得到处理则通知相关运营人员\n\n5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n   这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如:发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭;看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗? 如果数据量比较少，确实可以这样做，比如: 对于“如果账单一周内未支付则进行自动结算”这样的需求如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如:“订单十分钟内末支付则关闭“，短期内末支付的订单数据可能会有很多，活动期间甚至会达到百万甚至干万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n##### 12.3 springboot整合\n\n1. 创建项目\n\n2. 导入依赖\n\n   > <dependency>\n   >     <groupId>org.springframework.boot</groupId>\n   >     <artifactId>spring-boot-starter-amqp</artifactId>\n   > </dependency>\n   >\n   > <dependency>\n   >     <groupId>org.springframework.amqp</groupId>\n   >     <artifactId>spring-rabbit-test</artifactId>\n   >     <scope>test</scope>\n   > </dependency>\n   >\n   > 其他的按自己需求导入\n\n3. 配置队列TTL配置文件\n\n   ```java\n   @Configuration\n   public class TtlQueueConfig {\n   \n       //声明交换机\n       private static final String X_EXCHANGE = \"x\";\n       private static final String Y_DEAD_EXCHANGE = \"y\";\n       //声明队列\n       private static final String QUEUE_A = \"QA\";\n       private static final String QUEUE_B = \"QB\";\n       private static final String QUEUE_DEAD_B = \"QD\";\n   \n       //声明普通交换机\n       @Bean(\"xExchange\")\n       public DirectExchange xExchange() {\n           return new DirectExchange(X_EXCHANGE);\n       }\n   \n       //声明死信交换机\n       @Bean(\"yExchange\")\n       public DirectExchange yExchange() {\n           return new DirectExchange(Y_DEAD_EXCHANGE);\n       }\n   \n       //声明普通队列    TTL=10s\n       @Bean(\"queueA\")\n       public Queue queueA() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"YD\");\n           //设置TTL\n           map.put(\"x-message-ttl\", 10000);\n           return QueueBuilder.durable(QUEUE_A).withArguments(map).build();\n       }\n   \n       //声明普通队列    TTL=10s\n       @Bean(\"queueB\")\n       public Queue queueB() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"YD\");\n           //设置TTL\n           map.put(\"x-message-ttl\", 40000);\n           return QueueBuilder.durable(QUEUE_B).withArguments(map).build();\n       }\n   \n       //死信队列\n       @Bean()\n       public Queue queueD() {\n           return QueueBuilder.durable(QUEUE_DEAD_B).build();\n       }\n   \n       //绑定\n       @Bean\n       public Binding queueABindingX(@Qualifier(\"queueA\") Queue queueA,\n                                     @Qualifier(\"xExchange\") DirectExchange xExchange) {\n           return BindingBuilder.bind(queueA).to(xExchange).with(\"XA\");\n       }\n       @Bean\n       public Binding queueBBindingX(@Qualifier(\"queueB\") Queue queueB,\n                                     @Qualifier(\"xExchange\") DirectExchange xExchange) {\n           return BindingBuilder.bind(queueB).to(xExchange).with(\"XB\");\n       }\n       @Bean\n       public Binding queueDBindingY(@Qualifier(\"queueD\") Queue queueD,\n                                     @Qualifier(\"yExchange\") DirectExchange yExchange) {\n           return BindingBuilder.bind(queueD).to(yExchange).with(\"YB\");\n       }\n   }\n   ```\n\n4. 生产者代码\n\n   ```java\n   //发送延迟消息\n   @RestController\n   @RequestMapping(\"/ttl\")\n   @Slf4j\n   public class SendMsgController {\n   \n       @Autowired\n       private RabbitTemplate rabbitTemplate;\n   \n       //开始发送消息\n       @GetMapping(\"/sendMsg/{message}\")\n       public void sendMsg(@PathVariable String message) {\n           log.info(\"当前时间：{}，发送一条信息给两个TTL队列：{}\", new Date().toString(), message);\n           rabbitTemplate.convertAndSend(\"X\", \"XA\", \"消息来自ttl为10s的队列:\" + message);\n           rabbitTemplate.convertAndSend(\"X\", \"XB\", \"消息来自ttl为40s的队列:\" + message);\n       }\n   }消费者\n   ```\n   \n5. 消费者代码\n\n   ```java\n   @Slf4j\n   @Component\n   public class DeadLetterQueue {\n       //接收消息\n       @RabbitListener(queues = \"QD\")\n       public void receiveD(Message message, Channel channel) {\n           String msg = new String(message.getBody());\n           log.info(\"当前时间：{}，收到死信队列的消息：{}\", new Date().toString(), msg);\n       }\n   }\n   ```\n   \n6. 代码优化(自定义消息时长)\n\n   优化配置类\n\n   ```java\n   @Configuration\n   public class TtlQueueConfig {\n    private static final String QUEUE_C = \"QC\";\n         @Bean(\"queueC\")\n       public Queue queueC() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"XC\");\n           return QueueBuilder.durable(QUEUE_C).withArguments(map).build();\n       }\n   }\n   ```\n\n   优化生产者\n\n   ```java\n    @GetMapping(\"/sendExpirationMsg/{message}/{ttlTime}\")\n       public void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n           log.info(\"当前时间：{}，发送一条时长{}毫秒TTL信息给队列QC：{}\", new Date().toString(), ttlTime, message);\n           rabbitTemplate.convertAndSend(\"X\", \"XC\", \"\" + message, msg -> {\n               //发送消息的时候，设置时长\n               msg.getMessageProperties().setExpiration(ttlTime);\n               return msg;\n           });\n       }\n   ```\n\n   看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 **RabbitMo 只会检查第一个消息是否过期**，如果过期则丢到死信队列**如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/RabbitMQ.md","raw":"---\ntitle: RabbitMQ消息队列\ndate: 2023-06-18 11:18:57\ntags: 中间件\ncategories: 中间件\ncover: /img/images/Rabbit.png\n---\n\n# RabbitMQ\n\n### 1.什么是MQ\n\n​\tMQ(message queue),字面意思，本质上是一个队列，FIFO先进先出，只不过队列中存储的是消息，还是一种跨进程通信的机制，用于上下游传递消息，MQ是一种非常常见的上下游`逻辑解耦+物理解耦`的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。\n\n#### 1.1为什么要用MQ\n\n1. **流量消峰**\n\n   流量削峰，如果观看抽奖或秒杀系统的请求监控曲线，你就会发现这类系统在活动开放的时间段内会出现一个波峰，而在活动未开放时，系统的请求量、机器负载一般都是比较平稳的。为了节省机器资源，我们不可能时时都提供最大化的资源能力来支持短时间的高峰请求。所以需要使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控\n\n   **例子**：有一个订单系统，最多处理一万次订单，这个处理能力应付正常时段的下单绰绰有余，正常下单一秒就有返回结果，但是在高峰期，如果有两万次下单操作系统处理不过来，只能限制订单超过一万不允许用户下单，使用消息队列做缓冲，我们可以取消这个限制，吧一秒内下的订单分散成一段时间来处理，这时有些用户下单后十几秒后才有下单成功的结果，导致用户体验不佳。\n\n   `如果请求过多，超过服务器压力点，会导致宕机,MQ就是让高峰期的请求数达到一个可控范围，使服务器保持稳定，不会宕机`\n\n2. **应用解耦**\n\n   模块之间的调用十分复杂，为了降低模块与模块之间调用依赖，使用MQ将两系统分开,不直接调用系统接口,减轻两系统依赖关系\n\n   **例子**：电商应用为例，应用中有订单系统，库存系统，物流系统，支付系统，用户创建订单后，如果耦合调用库存系统，物流系统，支付系统，任何一个子系统出现故障，都会造成下单操作异常，当转变成基于消息队列的方式后，系统调用的问题会减少很多比如物流系统因为发送故障，需要几分钟来修复，在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成，当物流系统恢复后，继续处理订单信息即可，订单用户感受不到物流系统的故障，提升系统的可用性。\n\n3. **异步处理**\n\n   异步指一个执行中的任务，拆开成多个子任务各自执行。异步与同步处理相对，同步指多个执行中的子任务，等待所有子任务执行完再继续执行。异步的作用是使有I/O操作的任务最大化利用处理器的计算，以达到缩短任务的完成时间。\n\n### 2.RabbitMQ概念\n\n​\tRabbitMQ是一个消息中间件：它接受并转发消息，你可以把它当做一个传递点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人哪里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件，它不处理快件，而是接收，存储，转发消息数据\n\n#### 2.1四大核心概念\n\n1. 生产者\n\n   产生数据发送消息的程序是生产者\n\n2. 交换机\n\n   交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面他将消息推送到队列中，交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者吧消息丢弃，这个得有交换机类型决定\n\n3. 队列\n\n   队列是RabbitMQ内部使用得一种数据结构，尽管消息流经RabbitMQ和应用程序，但他们只能存储在队列中，队列受主机得内存和磁盘限制和约束，本质上是一个大得消息缓冲区，许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据，这就是我们使用队列得方式\n\n4. 消费者\n\n   消费与接收具有相似得含义。消费者大多时候是一个等待接收消息得程序，请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。\n\n3.RabbitMQ核心部分\n\n1. Hello World(简单模式)\n2. Work queues(工作模式)\n3. Publish/Subscribe(发布订阅模式)\n4. Routing(路由模式)\n5. Topics(主题模式)\n6. Publisher Confirms(发布确认模式)\n\n### 3.安装RabbitMQ\n\nRbbitMQ官网：https://www.rabbitmq.com/\n\nRabbitMQ及环境下载：https://packagecloud.io/rabbitmq/\n\n1. 安装Erlang环境\n\n```linux\nrpm -ivh erlang-xx.x-x.linux版本.x86_64.rpm\n```\n\n2. 安装socat依赖\n\n```\nyum install socat -y\n```\n\n3. 安装rabbitMQ-server\n\n```\nrpm -ivh rabbitmq-server-x.x.x-linux版本.noarch.rpm\n```\n\n#### 3.1**常用命令**\n\n1. 添加开机启动RabbitMQ服务\n\n   ```\n   chkconfig rabbitmq-server on\n   ```\n\n2. 启动RabbitMQ服务\n\n   ```\n   /sbin/service rabbitmq-server start\n   ```\n\n3. 查看RabbitMQ服务状态\n\n   ```\n   /sbin/service rabbitmq-server status\n   ```\n\n4. 停止RabbitMQ服务状态\n\n   ```\n   /sbin/service rabbitmq-server stop\n   ```\n\n5. 开启Web管理插件\n\n   ```\n   rabbitmq-plugins enable rabbitmq_management\n   \n   用默认账户密码(guest)访问地址http：//安装rabbitmq的主机ip地址:15672\n   这里会出现一个权限问题\n   ```\n\n   > 注意：15672端口必须开启或者关闭防火墙否则无法访问,正式项目不建议关闭防火墙\n   >\n   > systemctl stop firewalld  \n   >\n   > systemctl enabled firewalld\n   >\n   > systemctl start firewalld\n   >\n   > systemctl status firewalld\n\n6. 查看RabbitMQ有那些用户\n\n   ```\n   rabbitmqctl list_users\n   ```\n\n7. 添加一个新的用户\n\n   1. 创建账号\n\n      > rabbitmqctl add_user 用户名 密码\n\n   2. 设置用户角色\n\n      > rabbitmqctl set_user_tags 用户名 权限\n      >\n      > 例：rabbitmqctl set_user_tags user administrator\n\n   3. 设置用户权限\n\n      > set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n      >\n      > 例如：rabbitmq set_permissions -p\"/\" admin \".*\" \".*\"\".*\"\n      >\n      > 用户user_admin具有/vhost1这个virtual host中所有资源的配置、写、读权限\n\n   4. 修改密码\n\n      > rabbitmqctl  change_password  用户名  '新密码'\n      >\n      > 例：rabbitmqctl  change_password  admin  'root'\n\n### 4.Hello World(简单模式)\n\n#### 4.1创建maven项目\n\n#### 4.2导入依赖\n\n> <!--        rabbitmq依赖客户端-->\n>\n> <dependency>    \n>\n> ​\t<groupId>com.rabbitmq</groupId>    \n>\n> ​\t<artifactId>amqp-client</artifactId>    \n>\n> ​\t<version>5.18.0</version>\n>\n> </dependency>\n>\n> <!--        操作文件流依赖-->\n>\n> <dependency>    \n>\n> ​\t<groupId>commons-io</groupId>    \n>\n> ​\t<artifactId>commons-io</artifactId>    \n>\n> ​\t<version>2.11.0</version>\n>\n> </dependency>\n\n#### 4.3构建代码\n\n​\t构建一个生产者P端，消费者C端，通过P端发消息给队列传递给C端，这个队列采用RabbitMQ来保留消息缓冲区\n\n##### 4.3.1构建生产者\n\n```java\n/**\n * 生产者\n * 生产者：发送消息\n */\npublic class Producer {\n    //队列名称\n    public static final String QUEUE_NAME = \"hello\";\n    //发消息\n    public static void main(String[] args) throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        //设置工厂ip,连接RabbitMQ的队列\n        factory.setHost(\"192.168.100.137\");\n        //设置用户名和密码\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"root\");\n        //创建连接  此处需要处理一个异常\n        Connection connection = factory.newConnection();\n        //获取信道\n        Channel channel = connection.createChannel();\n        /**\n         * 生成一个队列\n         * @param String queue,                 队列名称\n         * @param boolean durable               是否保存消息,队列里的消息是否持久化，默认队列里的消息存储在内存中\n         * @param boolean exclusive,            该队列是否只对一个消费者提供消费， 是否进行消息的共享，true可以多个消费者消费，默认情况下false：只能一个消费者\n         * @param boolean autoDelete            是否自动删除，最后一个消费者断开连接后该队列是否自动删除\n         * @param Map<String, Object> arguments 其他参数，如死信消息、延迟消息、\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        //发送消息\n        String message = \"hello world\";\n        //利用信道发布消息\n        /**\n         *@param String exchange            交换机   默认交换机，可以忽略\n         * @param String routingKey         路由key   填写队列名称\n         * @param BasicProperties props     参数      无，填写null\n         * @param byte[] body               消息体\n         */\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n        System.out.println(\"发送完毕\");\n    }\n}\n```\n\n> 注意：还需要开放一个5672客户端端口，并且设置当前用户Permissions权限\n\n##### 4.3.1构建消费者\n\n```java\n//消费者\n//接收消息\npublic class Consumer {\n    //队列名称   接收此队列消息\n    public static final String QUEUE_NAME = \"hello\";\n    //接收消息\n    public static void main(String[] args) throws Exception {\n        //创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"192.168.100.137\");\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"root\");\n        Connection connection = factory.newConnection();\n        //建立信道  利用信道接收消息\n        Channel channel = connection.createChannel();\n        //声明  接收消息\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            System.out.println(\"消息体：\" + new String(message.getBody()));\n        };\n        //声明  取消消息\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println(\"消费消息被中断时执行\");\n        // 消费者，接收消息\n        /**\n         * @parma String queue                      队列名\n         * @parma boolean autoAck                   是否自动应答   消费成功后是否自动应答\n         * @parma DeliverCallback deliverCallback   消息的回调     消息未成功消费的回调\n         * @parma CancelCallback cancelCallback     消息的回调     消费者取消消息的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n}\n```\n\n### 5.Work Queues(工作模式)\n\n​\t工作队列(任务队列)的主要思想是避免立即执行资源密集型任务。而不得不等待它完成。相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终稿执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n#### 5.1轮询分发消息\n\n1. 抽取工具类\n\n   ```java\n   //rabbitmq创建连接信道\n   public class RabbitMQUtils {\n       //得到一个连接信道\n       public static Channel getChannel() throws Exception {\n           ConnectionFactory factory = new ConnectionFactory();\n           factory.setHost(\"192.168.100.137\");\n           factory.setUsername(\"admin\");\n           factory.setPassword(\"root\");\n           Connection connection = factory.newConnection();\n           Channel channel = connection.createChannel();\n           return channel;\n       }\n   }\n   ```\n   \n2. 消费者代码(接收消息的工作线程)\n\n   ```java\n   //工作线程01\n   public class Work01 {\n       //队列名称\n       public static final String QUEUE_NAME = \"hello\";\n       //接收消息\n       public static void main(String[] args) throws Exception {\n   \n           Channel channel = RabbitMQUtils.getChannel();\n           //消息接收\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(new String(message.getBody()));\n           //消息取消\n           CancelCallback cancelCallback = (consumerTag) -> System.out.println(\"消息被消费者取消：\" + consumerTag);\n           //消息的接收\n           System.out.println(\"C1线程等待中...\");\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n       }\n   }\n   ```\n\n3. 生产者代码(发送消息)\n\n   ```java\n   public class Task01 {\n       //队列名称\n       public static final String QUEUE_NAME = \"hello\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明队列\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //从控制台当中接收信息\n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               System.out.println(\"发送消息完成：\" + message);\n           }\n       }\n   }\n   ```\n\n#### 5.2消息应答\n\n1. 消息应答概念\n\n   消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然挂掉了，RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因它无法接收到。\n\n   `为了保证消息在发送过程中不丢失，rabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉rabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。`\n\n2. 自动应答\n\n   消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递消息的数量进行限制，当然这样有可能使得消费者这把由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这样的消息的情况下使用\n\n3. 消息应答的方法\n\n   A.Channel.basicAck(用于肯定确认)\n\n   ​\tRabbitMQ已经知道该消息并且成功处理的消息，可以将其丢弃了\n\n   B.Channel.basicNack(用于否定确认)\n\n   C.Channel.basicReject(用于否定确认)\n\n   ​\t与Channel.basicNack相比少一个参数(批量处理)，不处理该消息了直接拒绝，可以将其丢弃\n\n4. Multiple的解释\n\n   手动应答的好处就是可以批量应答并且减少网络拥堵\n\n   ```java\n   channel.basicAck(deliveryTag,true);\n   ```\n\n   multiple的true和false代表不同意思\n\n   true：代表批量应答channel上未应答的消息\n\n   例：channel上有传送tag的消息5，6，7，8当前tag是8那么此时5-8的这些还未应答的消息都会被确认收到消息的应答\n\n   false：如true相反。一对一应答\n\n5. 消息自动重新入队\n\n   如果消费者由于某些原因丢失连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对列重新排队，如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者，这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息\n\n6. 消息手动应答(代码)\n\n   默认采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n   ```java\n   //消息手动应答并不丢失，并且放回消息队列\n   public class Task02 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n   ```java\n   public class Worker01 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           System.out.println(\"C1等待接收消息处理，短时间处理\");\n           DeliverCallback deliverCallback = ((consumerTag, message) -> {\n               //沉睡一秒\n               try {\n                   Thread.sleep(1000);\n               } catch (InterruptedException e) {\n                   throw new RuntimeException(e);\n               }\n               System.out.println(\"接收到的消息：\" + new String(message.getBody(), \"UTF-8\"));\n               //手动应答\n               /**\n                * @param long deliveryTag     消息的标识\n                * @param boolean multiple     是否批量应答\n                */\n               channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n           });\n           boolean autoAck = false;\n           channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -> System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\")));\n       }\n   }\n   ```\n\n   ```java\n   public class Worker02 {\n       private static final String QUEUE_NAME = \"ack_queue\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           System.out.println(\"C2等待接收消息处理，长时间处理\");\n           DeliverCallback deliverCallback = ((consumerTag, message) -> {\n               //沉睡一秒\n               try {\n                   Thread.sleep(30000);\n               } catch (InterruptedException e) {\n                   throw new RuntimeException(e);\n               }\n               System.out.println(\"接收到的消息：\" + new String(message.getBody(), \"UTF-8\"));\n               //手动应答\n               /**\n                * @param long deliveryTag     消息的标识\n                * @param boolean multiple     是否批量应答\n                */\n               channel.basicAck(message.getEnvelope().getDeliveryTag(), false);\n           });\n           boolean autoAck = false;\n           channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -> System.out.println(consumerTag + \"消费者取消消费接口回调逻辑\")));\n       }\n   }\n   ```\n\n#### 5.3RabbitMQ持久化\n\n1. ##### 概念\n\n   如果保证当RabbitMQ服务突然停掉以后消息生产者发送过来的消息不丢失。默认情况下RabbitMQ退出或由于某种原因崩溃了，它忽视队列和消息，除非告知它不要这么做，确保消息不会丢失需要做两件事`我们需要将队列和消息都标记为持久化`\n\n2. ##### 队列如何实现持久化\n\n   RabbitMQ中的队列默认是非持久化的，RabbitMQ如果重启，该队列就会被删除掉，如果要队列实现持久化，需要声明队列的时候把durable参数设置为持久化\n\n   ```java\n    channel.queueDeclare(QUEUE_NAME, `true持久化，false非持久化`, false, false, null);\n   ```\n\n   > 注意：如果之前声明队列不是持久化，需要把原先队列删除，或者重新创建一个新的持久化队列，不然会出错\n   >\n   > `ITION_FAILED - inequivalent arg 'durable' for queue 'task_queue' in vhost '/': received 'true' but current is 'false'`\n\n3. ##### 消息实现持久化\n\n   消息持久化需要在消息生产者中添加属性，`MessageProperties.PERSISTENT_TEXT_PLAIN`\n\n   ```java\n   channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\"));\n   ```\n\n   > 将消息持久化并不能完全保证消息不丢失，尽管它告诉RabbitMQ将消息保存在磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘，持久性保证并不强，但是对于简单的任务队列来说绰绰有余，如果需要更强的持久化策略，可以用发布确认\n\n4. ##### 不公平分发\n\n   能者多劳，一台机器处理快，一台机器处理慢，轮询分发会导致处理快的机器有一个空闲期等待处理慢的机器处理完毕，为了提高利用每台机器的最高性能，建议使用不公平分发，谁处理的快谁就多处理一点，处理慢的就少处理点\n\n   `为了避免这种情况，创建信道设置参数channel.basicQos(1);默认为轮询分发`\n\n5. ##### 预取值\n\n   本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能`限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。`这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。`该值定义通道上允许的未确认消息的最大数量`。一旦数量达到配置的数量RabbitMO 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ.将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。`虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗`(随机存取存诸器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并目不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中，对于大多数来说，稍微高一点的值将是最佳的\n   \n### 6.发布确认\n\n#### 6.1发布确认原理\n\n​    生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\n​    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n#### 6.2发布确认的策略\n\n1. ##### 开启发布确认的方法\n\n   发布确认默认是没有开启的，如果要开启需要调用方法confirmSelect，每当你要想使用发布确认，都需要在channel上调用该方法\n\n   ```\n   Channel channel = connection.createChannel();\n   channel.confirmSelect();\n   ```\n\n2. ##### 单个确认发布\n\n   这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n   这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n   ```java\n    public static void publishMessageIndividually() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n   \n           for (int i = 0; i < 1000; i++) {\n               String message = \"单个确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               boolean flag = channel.waitForConfirms();\n               if (flag) {\n                   System.out.println(\"消息 \" + i + \" 发送成功\");\n               }\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布单个确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n3. ##### 批量确认发布\n\n   上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n   ```java\n   public static void publishMessageBatch() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n   \n           //批量确认消息大小\n           int batchSize = 100;\n   \n           //开始时间\n           long startTime = System.currentTimeMillis();\n           for (int i = 0; i < 1000; i++) {\n               String message = \"单个确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               //判断是否达到消息大小\n               if (i % batchSize == 0)\n                   //发布确认\n                   channel.waitForConfirms();\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n4. ##### 异步确认发布\n\n   异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说他是利用回调函数来达到消息可靠性传递的,这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的。\t\n\n   ```java\n    //异步确认消息\n       public static void publishMessageAsync() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n           //准备消息的监听器 监听那些消息成功了 那些失败了\n           //消息确认成功，回调函数\n           ConfirmCallback ackCallback = (deliveryTag, multiple) -> {\n               System.out.println(\"确认的消息：\" + deliveryTag);\n           };\n           //消息确认失败，回调函数\n           /**\n            * deliveryTag      消息的标识\n            * multiple         是否批量确认\n            */\n           ConfirmCallback nackCallback = (deliveryTag, multiple) -> {\n               System.out.println(\"未确认的消息：\" + deliveryTag);\n           };\n           //监听失败也监听成功\n           channel.addConfirmListener(ackCallback, nackCallback); //异步通知\n           //批量发送消息\n           for (int i = 0; i < 1000; i++) {\n               String message = \"异步确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n5. ##### 如何处理异步未确认消息\n\n   最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递\n\n   ```java\n   /异步确认消息\n       public static void publishMessageAsync() throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           String QUEUE_NAME = UUID.randomUUID().toString();\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           //开启发布确认\n           channel.confirmSelect();\n   \n           //线程安全有序的一个哈希表 适用于高并发的情况下\n           //1.轻松的将消息和序号进行关联\n           //2.轻松批量删除条目  只要给到序号\n           //3.支持高并发\n           ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();\n           //开始时间\n           long startTime = System.currentTimeMillis();\n           //准备消息的监听器 监听那些消息成功了 那些失败了\n           //消息确认成功，回调函数\n           ConfirmCallback ackCallback = (deliveryTag, multiple) -> {\n               //2.删除已经确认的消息  剩下的就是未确认的消息\n               //判断是否为批量\n               if (multiple) {\n                   ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(deliveryTag);\n                   confirmed.clear();\n               } else {\n                   outstandingConfirms.remove(deliveryTag);\n               }\n   \n               System.out.println(\"确认的消息：\" + deliveryTag);\n           };\n           ConfirmCallback nackCallback = (deliveryTag, multiple) -> {\n               //3.打印未确认的消息\n               String message = outstandingConfirms.get(deliveryTag);\n               System.out.println(\"未确认的消息内容\" + message);\n               System.out.println(\"未确认的消息标识：\" + deliveryTag);\n           };\n           //监听失败也监听成功\n           channel.addConfirmListener(ackCallback, nackCallback); //异步通知\n           //批量发送消息\n           for (int i = 0; i < 1000; i++) {\n               String message = \"异步确认\" + i;\n               channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n               //1.记录所有要发送的消息  消息的总和\n               outstandingConfirms.put(channel.getNextPublishSeqNo(), message);\n           }\n           //结束时间\n           long stopTime = System.currentTimeMillis();\n           System.out.println(\"发布批量确认消息耗时：\" + (stopTime - startTime) + \"ms\");\n       }\n   ```\n\n6. ##### 以上三种发布确认速度对比\n\n   **单个确认：**发布1000个消息到同一队列,耗时1863ms。\n\n   **批量确认：**发布1000个批量消息到同一队列,耗时150ms。\n\n   **异步确认：**发布1000个异步消息到同一队列,耗时99ms\n\n### 7.交换机\n\n​\t 在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布/订阅”.为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者\n\n#### 7.1 Exchanges\n\n1. **Exchanges概念**\n\n   ​\tRabbitMO 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n   ​\t相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n2. **Exchanges的类型**\n\n   1. 直接(direct)    路由类型\n   2. 主题(topic)\n   3. 标题(headers)   头类型(不常用)\n   4. 扇出(fanot)     发布订阅类型\n\n3. **无名Exchange**(默认类型)\n\n   在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(\"\")进行标识。\n\n   ```java\n   channel.basicPublish(\"\",\"hello\",null,message.getBytes());\n   ```\n\n   第一个参数是交换机的名称。空字符串表示默认或无名称交换机: 消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n\n#### 7.2 临时队列\n\n​\t每当我们连接到 Rabbt 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列：channel.queueDeclare().getQueue()\n\n#### 7.3 绑定(bindings)\n\nbinding就是exchange和queue之间的桥梁，告诉我们那个队列对应那个交换机\n\n### 8. Fanout(发布订阅模式)\n\n1. Fanout介绍\n\n   Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型\n\n2. Fanout实战\n\n   ```java\n   public class ReceiveLogs01 {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明一个交换机\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n           //声明一个队列   临时队列\n           String queue = channel.queueDeclare().getQueue();\n           //绑定交换机和队列\n           channel.queueBind(queue, EXCHANGES_NAME, \"\");\n           System.out.println(\"等待接收消息...\");\n           //接收消息\n           DeliverCallback deliverCallback = ((consumerTag, message) -> System.out.println(\"01接收到的消息：\" + new String(message.getBody())));\n           channel.basicConsume(queue, true, deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   public class ReceiveLogs02 {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明一个交换机\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n           //声明一个队列   临时队列\n           String queue = channel.queueDeclare().getQueue();\n           //绑定交换机和队列\n           channel.queueBind(queue, EXCHANGES_NAME, \"\");\n           System.out.println(\"等待接收消息...\");\n           //接收消息\n           DeliverCallback deliverCallback = ((consumerTag, message) -> System.out.println(\"02接收到的消息：\" + new String(message.getBody())));\n           channel.basicConsume(queue, true, deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   \n   ```\n\n   ```java\n   //发送消息   交换机\n   public class EmitLog {\n       private static final String EXCHANGES_NAME = \"logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGES_NAME, \"fanout\");\n   \n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(EXCHANGES_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n### 9. Direct Exchange(路由模式)\n\n1. Direct Exchange\n\n   队列只对它绑定的交换机的消息感兴趣。绑定用参数: routingKey 来表示也可称该参数为 binding key,创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME,\"routingKey\");绑定之后的意义由其交换类型决定\n\n2. 多重绑定\n\n   当然果exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和fanout 有点类似了，就跟广播差不多\n\n3. 实战\n\n   ```java\n   public class ReceiveLogsDirect01 {\n       //交换机名字\n       private static final String EXCHANGE_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明交换机\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n           channel.queueDeclare(\"console\", false, false, false, null);\n           channel.queueBind(\"console\", EXCHANGE_NAME, \"info\");\n           channel.queueBind(\"console\", EXCHANGE_NAME, \"warning\");\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"一号队列接收到的消息：\" + new String(message.getBody()));\n           channel.basicConsume(\"console\", deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   \n   public class ReceiveLogsDirect02 {\n       //交换机名字\n       private static final String EXCHANGE_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           //声明交换机\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n           channel.queueDeclare(\"disk\", false, false, false, null);\n           channel.queueBind(\"disk\", EXCHANGE_NAME, \"error\");\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"二号队列接收到的消息：\" + new String(message.getBody()));\n           channel.basicConsume(\"disk\", deliverCallback, consumerTag -> {\n           });\n       }\n   }\n   ```\n\n   ```java\n   public class DirectLogs {\n       private static final String EXCHANGES_NAME = \"direct_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGES_NAME, BuiltinExchangeType.DIRECT);\n   \n           Scanner scanner = new Scanner(System.in);\n           while (scanner.hasNext()) {\n               String message = scanner.next();\n               channel.basicPublish(EXCHANGES_NAME, \"error\", null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送消息：\" + message);\n           }\n       }\n   }\n   ```\n\n### 10. Topics(主题模式)\n\n1. 之前类型的问题\n\n   尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型\n\n2. Topic的要求\n\n   ​\t发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它**必须是一个单词列表，以点号分隔开**。这些单词可以是任意单词\n\n   比如说:\"stockusd.nyse\"，\"nyse.vmw”\"quick.orange.rabbit\".这种类型的。当然这个单词列表**最多不能超过 255 个字节**。\n\n   > *(星号)可以代替一个单词\n   >\n   > #(井号)可以代替零个或多个单词\n   >\n   > 当一个队列绑定#，那么这个队列将接收所有数据，就像fanout\n   >\n   > 当一个队列没有出现*和#，那么该队列绑定类型就是direct\n\n3. 实战\n\n   ```java\n   public class ReceiverLogsTopic01 {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n           String QUEUE_NAME = \"Q1\";\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.orange.*\");\n           System.out.println(\"等待接收消息。。。\");\n           //接收消息\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C1接收到的消息：\" + new String(message.getBody(), \"UTF-8\")+ \" 绑定的key：\" + message.getEnvelope().getRoutingKey());\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> System.out.println(consumerTag));\n       }\n   }\n   ```\n\n   ```java\n   public class ReceiverLogsTopic02 {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n   \n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n           String QUEUE_NAME = \"Q2\";\n           channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"**.rabbit\");\n           channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"lazy.#\");\n           System.out.println(\"等待接收消息。。。\");\n           //接收消息\n           DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C2接收到的消息：\" + new String(message.getBody(), \"UTF-8\")+ \" 绑定的key：\" + message.getEnvelope().getRoutingKey());\n           channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> System.out.println(consumerTag));\n       }\n   }\n   ```\n\n   ```java\n   public class EmitLogTopic {\n       //交换机名称\n       public static final String EXCHANGE_NAME = \"topic_logs\";\n       public static void main(String[] args) throws Exception {\n           Channel channel = RabbitMQUtils.getChannel();\n           Map<String, String> map = new HashMap<>();\n           map.put(\"quick.orange.rabbit\", \"被队列Q1Q2接收\");\n           map.put(\"lazy.orange.elephant\", \"被队列Q1Q2接收\");\n           map.put(\"quick.orange.fox\", \"被队列Q1接收\");\n           map.put(\"lazy.brown.fox\", \"被队列Q2接收\");\n           map.put(\"lazy.pink.rabbit\", \"虽然满足两个绑定但只被队列Q2接收一次\");\n           map.put(\"quick.brown.fox\", \"不匹配任何绑定，没有队列接收，会被丢弃\");\n           map.put(\"quick.orange.male.rabbit\", \"是四个单词不匹配任何绑定会被丢弃\");\n           map.put(\"lazy.orange.male.rabbit\", \"是四个单词但匹配Q2\");\n           for (Map.Entry<String, String> entry : map.entrySet()) {\n               String routingKey = entry.getKey();\n               String message = entry.getValue();\n               channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\"));\n               System.out.println(\"生产者发送：\" + message);\n           }\n       }\n   }\n   ```\n\n### 11. 死信队列\n\n**11.1 死信的概念**\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n**应用场景**：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\n\n**11.2 死信的来源**\n\n- 消息 TTL（存活时间） 过期\n- 队列达到最大长度(队列满了，无法再添加数据到队列中)\n- 消息被拒绝（消费方拒绝应答：basic.reject 或 basic.nack）并且（不放回队列中： requeue=false）\n\n**11.3 死信实战**\n\n消息 TTL（存活时间） 过期\n\n```java\n//死信队列\n//消费者1\npublic class Consumer01 {\n    //普通交换机\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    //死信交换机\n    public static final String DEAD_EXCHANGE = \"dead_exchange\";\n    //普通队列名\n    public static final String NORMAL_QUEUE_NAME = \"normal_queue\";\n    //死信队列名\n    public static final String DEAD_QUEUE_NAME = \"dead_queue\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        //声明交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //声明队列\n        //普通队列\n        /**\n         * 参数 ，满足死信三个条件转发到死信队列\n         */\n        Map<String, Object> arguments = new HashMap<>();\n        //过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长\n        //arguments.put(\"x-message-ttl\", 10000);\n        // 正常队列设置死信交换机\n        arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n        //设置死信RoutingKey\n        arguments.put(\"x-dead-letter-routing-key\", \"lisi\");\n        channel.queueDeclare(NORMAL_QUEUE_NAME, false, false, false, arguments);\n        //死信队列\n        channel.queueDeclare(DEAD_QUEUE_NAME, false, false, false, null);\n        //绑定交换机和队列\n        channel.queueBind(NORMAL_QUEUE_NAME, NORMAL_EXCHANGE, \"zhangsan\");\n        channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE, \"lisi\");\n        System.out.println(\"等待接收消息....\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C1接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n        channel.basicConsume(NORMAL_QUEUE_NAME, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n```\n\n```java\n//死信队列\n//消费者2\npublic class Consumer02 {\n    //死信队列名\n    public static final String DEAD_QUEUE_NAME = \"dead_queue\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        System.out.println(\"等待接收消息....\");\n\n        DeliverCallback deliverCallback = (consumerTag, message) -> System.out.println(\"C2接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n        channel.basicConsume(DEAD_QUEUE_NAME, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n```\n\n```java\n//死信队列\n//生产者\npublic class Producer {\n    //普通交换机\n    public static final String NORMAL_EXCHANGE = \"normal_exchange\";\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMQUtils.getChannel();\n        //死信消息  设置TTl\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\"10000\").build();\n\n        for (int i = 1; i < 11; i++) {\n            String message = \"info\" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, \"zhangsan\", properties, message.getBytes());\n        }\n    }\n}\n```\n\n队列达到最大长度\n\n```java\n//声明队列\n//普通队列\n/**\n* 参数 ，满足死信三个条件转发到死信队列\n*/\nMap<String, Object> arguments = new HashMap<>();\n//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长\n//arguments.put(\"x-message-ttl\", 10000);\n// 正常队列设置死信交换机\narguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE);\n//设设置队列最大长度\narguments.put(\"x-max-length\",6);\n//设置死信RoutingKey\narguments.put(\"x-dead-letter-routing-key\", \"lisi\");\nchannel.queueDeclare(NORMAL_QUEUE_NAME, false, false, false, arguments);\n```\n\n消息被拒绝\n\n```java\n DeliverCallback deliverCallback = (consumerTag, message) -> {\n if(\"info5\".equals(message)){\n    System.out.println(\"C1拒绝此消息：\"+new String(message.getBody(), \"UTF-8\"));\n    channel.basicReject(message.getEnvelope().getDeliveryTag(),false(是否放回队列))\n }else{\n      System.out.println(\"C1接收的消息\" + new String(message.getBody(), \"UTF-8\"));\n     channel.basicAck(message.getEnvelope().getDeliveryTag(),false)\n }\n }\n//开启手动应答\n channel.basicConsume(NORMAL_QUEUE_NAME, false, deliverCallback, consumerTag -> {\n        });\n```\n\n### 12.延迟队列\n\n##### 12.1 延迟队列概念\n\n延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。\n\n##### 12.2 延迟队列使用场景\n\n1. 订单在十分钟为支付则自动取消\n\n2. 新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒\n\n3. 用户注册成功后，如果三天没有登录则进行短信提示\n\n4. 用户发起退款，如果三天没有得到处理则通知相关运营人员\n\n5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n   这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如:发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭;看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗? 如果数据量比较少，确实可以这样做，比如: 对于“如果账单一周内未支付则进行自动结算”这样的需求如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如:“订单十分钟内末支付则关闭“，短期内末支付的订单数据可能会有很多，活动期间甚至会达到百万甚至干万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n##### 12.3 springboot整合\n\n1. 创建项目\n\n2. 导入依赖\n\n   > <dependency>\n   >     <groupId>org.springframework.boot</groupId>\n   >     <artifactId>spring-boot-starter-amqp</artifactId>\n   > </dependency>\n   >\n   > <dependency>\n   >     <groupId>org.springframework.amqp</groupId>\n   >     <artifactId>spring-rabbit-test</artifactId>\n   >     <scope>test</scope>\n   > </dependency>\n   >\n   > 其他的按自己需求导入\n\n3. 配置队列TTL配置文件\n\n   ```java\n   @Configuration\n   public class TtlQueueConfig {\n   \n       //声明交换机\n       private static final String X_EXCHANGE = \"x\";\n       private static final String Y_DEAD_EXCHANGE = \"y\";\n       //声明队列\n       private static final String QUEUE_A = \"QA\";\n       private static final String QUEUE_B = \"QB\";\n       private static final String QUEUE_DEAD_B = \"QD\";\n   \n       //声明普通交换机\n       @Bean(\"xExchange\")\n       public DirectExchange xExchange() {\n           return new DirectExchange(X_EXCHANGE);\n       }\n   \n       //声明死信交换机\n       @Bean(\"yExchange\")\n       public DirectExchange yExchange() {\n           return new DirectExchange(Y_DEAD_EXCHANGE);\n       }\n   \n       //声明普通队列    TTL=10s\n       @Bean(\"queueA\")\n       public Queue queueA() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"YD\");\n           //设置TTL\n           map.put(\"x-message-ttl\", 10000);\n           return QueueBuilder.durable(QUEUE_A).withArguments(map).build();\n       }\n   \n       //声明普通队列    TTL=10s\n       @Bean(\"queueB\")\n       public Queue queueB() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"YD\");\n           //设置TTL\n           map.put(\"x-message-ttl\", 40000);\n           return QueueBuilder.durable(QUEUE_B).withArguments(map).build();\n       }\n   \n       //死信队列\n       @Bean()\n       public Queue queueD() {\n           return QueueBuilder.durable(QUEUE_DEAD_B).build();\n       }\n   \n       //绑定\n       @Bean\n       public Binding queueABindingX(@Qualifier(\"queueA\") Queue queueA,\n                                     @Qualifier(\"xExchange\") DirectExchange xExchange) {\n           return BindingBuilder.bind(queueA).to(xExchange).with(\"XA\");\n       }\n       @Bean\n       public Binding queueBBindingX(@Qualifier(\"queueB\") Queue queueB,\n                                     @Qualifier(\"xExchange\") DirectExchange xExchange) {\n           return BindingBuilder.bind(queueB).to(xExchange).with(\"XB\");\n       }\n       @Bean\n       public Binding queueDBindingY(@Qualifier(\"queueD\") Queue queueD,\n                                     @Qualifier(\"yExchange\") DirectExchange yExchange) {\n           return BindingBuilder.bind(queueD).to(yExchange).with(\"YB\");\n       }\n   }\n   ```\n\n4. 生产者代码\n\n   ```java\n   //发送延迟消息\n   @RestController\n   @RequestMapping(\"/ttl\")\n   @Slf4j\n   public class SendMsgController {\n   \n       @Autowired\n       private RabbitTemplate rabbitTemplate;\n   \n       //开始发送消息\n       @GetMapping(\"/sendMsg/{message}\")\n       public void sendMsg(@PathVariable String message) {\n           log.info(\"当前时间：{}，发送一条信息给两个TTL队列：{}\", new Date().toString(), message);\n           rabbitTemplate.convertAndSend(\"X\", \"XA\", \"消息来自ttl为10s的队列:\" + message);\n           rabbitTemplate.convertAndSend(\"X\", \"XB\", \"消息来自ttl为40s的队列:\" + message);\n       }\n   }消费者\n   ```\n   \n5. 消费者代码\n\n   ```java\n   @Slf4j\n   @Component\n   public class DeadLetterQueue {\n       //接收消息\n       @RabbitListener(queues = \"QD\")\n       public void receiveD(Message message, Channel channel) {\n           String msg = new String(message.getBody());\n           log.info(\"当前时间：{}，收到死信队列的消息：{}\", new Date().toString(), msg);\n       }\n   }\n   ```\n   \n6. 代码优化(自定义消息时长)\n\n   优化配置类\n\n   ```java\n   @Configuration\n   public class TtlQueueConfig {\n    private static final String QUEUE_C = \"QC\";\n         @Bean(\"queueC\")\n       public Queue queueC() {\n           Map<String, Object> map = new HashMap<>(3);\n           //设置死信交换机\n           map.put(\"x-dead-letter-exchange\", Y_DEAD_EXCHANGE);\n           //设置死信key\n           map.put(\"x-dead-letter-routing-key\", \"XC\");\n           return QueueBuilder.durable(QUEUE_C).withArguments(map).build();\n       }\n   }\n   ```\n\n   优化生产者\n\n   ```java\n    @GetMapping(\"/sendExpirationMsg/{message}/{ttlTime}\")\n       public void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n           log.info(\"当前时间：{}，发送一条时长{}毫秒TTL信息给队列QC：{}\", new Date().toString(), ttlTime, message);\n           rabbitTemplate.convertAndSend(\"X\", \"XC\", \"\" + message, msg -> {\n               //发送消息的时候，设置时长\n               msg.getMessageProperties().setExpiration(ttlTime);\n               return msg;\n           });\n       }\n   ```\n\n   看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 **RabbitMo 只会检查第一个消息是否过期**，如果过期则丢到死信队列**如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"RabbitMQ","published":1,"updated":"2023-08-10T09:50:56.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9m000xfswoh026163j","content":"<h1 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h1><h3 id=\"1-什么是MQ\"><a href=\"#1-什么是MQ\" class=\"headerlink\" title=\"1.什么是MQ\"></a>1.什么是MQ</h3><p>​\tMQ(message queue),字面意思，本质上是一个队列，FIFO先进先出，只不过队列中存储的是消息，还是一种跨进程通信的机制，用于上下游传递消息，MQ是一种非常常见的上下游<code>逻辑解耦+物理解耦</code>的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>\n<h4 id=\"1-1为什么要用MQ\"><a href=\"#1-1为什么要用MQ\" class=\"headerlink\" title=\"1.1为什么要用MQ\"></a>1.1为什么要用MQ</h4><ol>\n<li><p><strong>流量消峰</strong></p>\n<p>流量削峰，如果观看抽奖或秒杀系统的请求监控曲线，你就会发现这类系统在活动开放的时间段内会出现一个波峰，而在活动未开放时，系统的请求量、机器负载一般都是比较平稳的。为了节省机器资源，我们不可能时时都提供最大化的资源能力来支持短时间的高峰请求。所以需要使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控</p>\n<p><strong>例子</strong>：有一个订单系统，最多处理一万次订单，这个处理能力应付正常时段的下单绰绰有余，正常下单一秒就有返回结果，但是在高峰期，如果有两万次下单操作系统处理不过来，只能限制订单超过一万不允许用户下单，使用消息队列做缓冲，我们可以取消这个限制，吧一秒内下的订单分散成一段时间来处理，这时有些用户下单后十几秒后才有下单成功的结果，导致用户体验不佳。</p>\n<p><code>如果请求过多，超过服务器压力点，会导致宕机,MQ就是让高峰期的请求数达到一个可控范围，使服务器保持稳定，不会宕机</code></p>\n</li>\n<li><p><strong>应用解耦</strong></p>\n<p>模块之间的调用十分复杂，为了降低模块与模块之间调用依赖，使用MQ将两系统分开,不直接调用系统接口,减轻两系统依赖关系</p>\n<p><strong>例子</strong>：电商应用为例，应用中有订单系统，库存系统，物流系统，支付系统，用户创建订单后，如果耦合调用库存系统，物流系统，支付系统，任何一个子系统出现故障，都会造成下单操作异常，当转变成基于消息队列的方式后，系统调用的问题会减少很多比如物流系统因为发送故障，需要几分钟来修复，在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成，当物流系统恢复后，继续处理订单信息即可，订单用户感受不到物流系统的故障，提升系统的可用性。</p>\n</li>\n<li><p><strong>异步处理</strong></p>\n<p>异步指一个执行中的任务，拆开成多个子任务各自执行。异步与同步处理相对，同步指多个执行中的子任务，等待所有子任务执行完再继续执行。异步的作用是使有I&#x2F;O操作的任务最大化利用处理器的计算，以达到缩短任务的完成时间。</p>\n</li>\n</ol>\n<h3 id=\"2-RabbitMQ概念\"><a href=\"#2-RabbitMQ概念\" class=\"headerlink\" title=\"2.RabbitMQ概念\"></a>2.RabbitMQ概念</h3><p>​\tRabbitMQ是一个消息中间件：它接受并转发消息，你可以把它当做一个传递点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人哪里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件，它不处理快件，而是接收，存储，转发消息数据</p>\n<h4 id=\"2-1四大核心概念\"><a href=\"#2-1四大核心概念\" class=\"headerlink\" title=\"2.1四大核心概念\"></a>2.1四大核心概念</h4><ol>\n<li><p>生产者</p>\n<p>产生数据发送消息的程序是生产者</p>\n</li>\n<li><p>交换机</p>\n<p>交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面他将消息推送到队列中，交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者吧消息丢弃，这个得有交换机类型决定</p>\n</li>\n<li><p>队列</p>\n<p>队列是RabbitMQ内部使用得一种数据结构，尽管消息流经RabbitMQ和应用程序，但他们只能存储在队列中，队列受主机得内存和磁盘限制和约束，本质上是一个大得消息缓冲区，许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据，这就是我们使用队列得方式</p>\n</li>\n<li><p>消费者</p>\n<p>消费与接收具有相似得含义。消费者大多时候是一个等待接收消息得程序，请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。</p>\n</li>\n</ol>\n<p>3.RabbitMQ核心部分</p>\n<ol>\n<li>Hello World(简单模式)</li>\n<li>Work queues(工作模式)</li>\n<li>Publish&#x2F;Subscribe(发布订阅模式)</li>\n<li>Routing(路由模式)</li>\n<li>Topics(主题模式)</li>\n<li>Publisher Confirms(发布确认模式)</li>\n</ol>\n<h3 id=\"3-安装RabbitMQ\"><a href=\"#3-安装RabbitMQ\" class=\"headerlink\" title=\"3.安装RabbitMQ\"></a>3.安装RabbitMQ</h3><p>RbbitMQ官网：<a href=\"https://www.rabbitmq.com/\">https://www.rabbitmq.com/</a></p>\n<p>RabbitMQ及环境下载：<a href=\"https://packagecloud.io/rabbitmq/\">https://packagecloud.io/rabbitmq/</a></p>\n<ol>\n<li>安装Erlang环境</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh erlang-xx.x-x.linux版本.x86_64.rpm</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>安装socat依赖</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install socat -y</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>安装rabbitMQ-server</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh rabbitmq-server-x.x.x-linux版本.noarch.rpm</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1常用命令\"><a href=\"#3-1常用命令\" class=\"headerlink\" title=\"3.1常用命令\"></a>3.1<strong>常用命令</strong></h4><ol>\n<li><p>添加开机启动RabbitMQ服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动RabbitMQ服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看RabbitMQ服务状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止RabbitMQ服务状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server stop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启Web管理插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br><span class=\"line\"></span><br><span class=\"line\">用默认账户密码(guest)访问地址http：//安装rabbitmq的主机ip地址:15672</span><br><span class=\"line\">这里会出现一个权限问题</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：15672端口必须开启或者关闭防火墙否则无法访问,正式项目不建议关闭防火墙</p>\n<p>systemctl stop firewalld  </p>\n<p>systemctl enabled firewalld</p>\n<p>systemctl start firewalld</p>\n<p>systemctl status firewalld</p>\n</blockquote>\n</li>\n<li><p>查看RabbitMQ有那些用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个新的用户</p>\n<ol>\n<li><p>创建账号</p>\n<blockquote>\n<p>rabbitmqctl add_user 用户名 密码</p>\n</blockquote>\n</li>\n<li><p>设置用户角色</p>\n<blockquote>\n<p>rabbitmqctl set_user_tags 用户名 权限</p>\n<p>例：rabbitmqctl set_user_tags user administrator</p>\n</blockquote>\n</li>\n<li><p>设置用户权限</p>\n<blockquote>\n<p>set_permissions [-p <vhostpath>] <user> <conf> <write> <read></p>\n<p>例如：rabbitmq set_permissions -p”&#x2F;“ admin “.<em>“ “.</em>“”.*”</p>\n<p>用户user_admin具有&#x2F;vhost1这个virtual host中所有资源的配置、写、读权限</p>\n</blockquote>\n</li>\n<li><p>修改密码</p>\n<blockquote>\n<p>rabbitmqctl  change_password  用户名  ‘新密码’</p>\n<p>例：rabbitmqctl  change_password  admin  ‘root’</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-Hello-World-简单模式\"><a href=\"#4-Hello-World-简单模式\" class=\"headerlink\" title=\"4.Hello World(简单模式)\"></a>4.Hello World(简单模式)</h3><h4 id=\"4-1创建maven项目\"><a href=\"#4-1创建maven项目\" class=\"headerlink\" title=\"4.1创建maven项目\"></a>4.1创建maven项目</h4><h4 id=\"4-2导入依赖\"><a href=\"#4-2导入依赖\" class=\"headerlink\" title=\"4.2导入依赖\"></a>4.2导入依赖</h4><blockquote>\n<!--        rabbitmq依赖客户端-->\n\n<dependency>    \n\n<p>​\t<groupId>com.rabbitmq</groupId>    </p>\n<p>​\t<artifactId>amqp-client</artifactId>    </p>\n<p>​\t<version>5.18.0</version></p>\n</dependency>\n\n<!--        操作文件流依赖-->\n\n<dependency>    \n\n<p>​\t<groupId>commons-io</groupId>    </p>\n<p>​\t<artifactId>commons-io</artifactId>    </p>\n<p>​\t<version>2.11.0</version></p>\n</dependency>\n</blockquote>\n<h4 id=\"4-3构建代码\"><a href=\"#4-3构建代码\" class=\"headerlink\" title=\"4.3构建代码\"></a>4.3构建代码</h4><p>​\t构建一个生产者P端，消费者C端，通过P端发消息给队列传递给C端，这个队列采用RabbitMQ来保留消息缓冲区</p>\n<h5 id=\"4-3-1构建生产者\"><a href=\"#4-3-1构建生产者\" class=\"headerlink\" title=\"4.3.1构建生产者\"></a>4.3.1构建生产者</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者：发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//发消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        <span class=\"comment\">//设置工厂ip,连接RabbitMQ的队列</span></span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置用户名和密码</span></span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建连接  此处需要处理一个异常</span></span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//获取信道</span></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> String queue,                 队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean durable               是否保存消息,队列里的消息是否持久化，默认队列里的消息存储在内存中</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean exclusive,            该队列是否只对一个消费者提供消费， 是否进行消息的共享，true可以多个消费者消费，默认情况下false：只能一个消费者</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean autoDelete            是否自动删除，最后一个消费者断开连接后该队列是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> Map&lt;String, Object&gt; arguments 其他参数，如死信消息、延迟消息、</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//利用信道发布消息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         *<span class=\"doctag\">@param</span> String exchange            交换机   默认交换机，可以忽略</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> String routingKey         路由key   填写队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> BasicProperties props     参数      无，填写null</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> byte[] body               消息体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发送完毕&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：还需要开放一个5672客户端端口，并且设置当前用户Permissions权限</p>\n</blockquote>\n<h5 id=\"4-3-1构建消费者\"><a href=\"#4-3-1构建消费者\" class=\"headerlink\" title=\"4.3.1构建消费者\"></a>4.3.1构建消费者</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称   接收此队列消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建连接工厂</span></span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//建立信道  利用信道接收消息</span></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明  接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息体：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//声明  取消消息</span></span><br><span class=\"line\">        <span class=\"type\">CancelCallback</span> <span class=\"variable\">cancelCallback</span> <span class=\"operator\">=</span> (consumerTag) -&gt; System.out.println(<span class=\"string\">&quot;消费消息被中断时执行&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费者，接收消息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> String queue                      队列名</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> boolean autoAck                   是否自动应答   消费成功后是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> DeliverCallback deliverCallback   消息的回调     消息未成功消费的回调</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> CancelCallback cancelCallback     消息的回调     消费者取消消息的回调</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Work-Queues-工作模式\"><a href=\"#5-Work-Queues-工作模式\" class=\"headerlink\" title=\"5.Work Queues(工作模式)\"></a>5.Work Queues(工作模式)</h3><p>​\t工作队列(任务队列)的主要思想是避免立即执行资源密集型任务。而不得不等待它完成。相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终稿执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。</p>\n<h4 id=\"5-1轮询分发消息\"><a href=\"#5-1轮询分发消息\" class=\"headerlink\" title=\"5.1轮询分发消息\"></a>5.1轮询分发消息</h4><ol>\n<li><p>抽取工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//rabbitmq创建连接信道</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitMQUtils</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个连接信道</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title function_\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者代码(接收消息的工作线程)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//工作线程01</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Work01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//消息接收</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">//消息取消</span></span><br><span class=\"line\">        <span class=\"type\">CancelCallback</span> <span class=\"variable\">cancelCallback</span> <span class=\"operator\">=</span> (consumerTag) -&gt; System.out.println(<span class=\"string\">&quot;消息被消费者取消：&quot;</span> + consumerTag);</span><br><span class=\"line\">        <span class=\"comment\">//消息的接收</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1线程等待中...&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者代码(发送消息)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//从控制台当中接收信息</span></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息完成：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"5-2消息应答\"><a href=\"#5-2消息应答\" class=\"headerlink\" title=\"5.2消息应答\"></a>5.2消息应答</h4><ol>\n<li><p>消息应答概念</p>\n<p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然挂掉了，RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因它无法接收到。</p>\n<p><code>为了保证消息在发送过程中不丢失，rabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉rabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。</code></p>\n</li>\n<li><p>自动应答</p>\n<p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递消息的数量进行限制，当然这样有可能使得消费者这把由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这样的消息的情况下使用</p>\n</li>\n<li><p>消息应答的方法</p>\n<p>A.Channel.basicAck(用于肯定确认)</p>\n<p>​\tRabbitMQ已经知道该消息并且成功处理的消息，可以将其丢弃了</p>\n<p>B.Channel.basicNack(用于否定确认)</p>\n<p>C.Channel.basicReject(用于否定确认)</p>\n<p>​\t与Channel.basicNack相比少一个参数(批量处理)，不处理该消息了直接拒绝，可以将其丢弃</p>\n</li>\n<li><p>Multiple的解释</p>\n<p>手动应答的好处就是可以批量应答并且减少网络拥堵</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicAck(deliveryTag,<span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>multiple的true和false代表不同意思</p>\n<p>true：代表批量应答channel上未应答的消息</p>\n<p>例：channel上有传送tag的消息5，6，7，8当前tag是8那么此时5-8的这些还未应答的消息都会被确认收到消息的应答</p>\n<p>false：如true相反。一对一应答</p>\n</li>\n<li><p>消息自动重新入队</p>\n<p>如果消费者由于某些原因丢失连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对列重新排队，如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者，这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息</p>\n</li>\n<li><p>消息手动应答(代码)</p>\n<p>默认采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消息手动应答并不丢失，并且放回消息队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1等待接收消息处理，短时间处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//沉睡一秒</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//手动应答</span></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> long deliveryTag     消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> boolean multiple     是否批量应答</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">autoAck</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -&gt; System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C2等待接收消息处理，长时间处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//沉睡一秒</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">30000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//手动应答</span></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> long deliveryTag     消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> boolean multiple     是否批量应答</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">autoAck</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -&gt; System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"5-3RabbitMQ持久化\"><a href=\"#5-3RabbitMQ持久化\" class=\"headerlink\" title=\"5.3RabbitMQ持久化\"></a>5.3RabbitMQ持久化</h4><ol>\n<li><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>如果保证当RabbitMQ服务突然停掉以后消息生产者发送过来的消息不丢失。默认情况下RabbitMQ退出或由于某种原因崩溃了，它忽视队列和消息，除非告知它不要这么做，确保消息不会丢失需要做两件事<code>我们需要将队列和消息都标记为持久化</code></p>\n</li>\n<li><h5 id=\"队列如何实现持久化\"><a href=\"#队列如何实现持久化\" class=\"headerlink\" title=\"队列如何实现持久化\"></a>队列如何实现持久化</h5><p>RabbitMQ中的队列默认是非持久化的，RabbitMQ如果重启，该队列就会被删除掉，如果要队列实现持久化，需要声明队列的时候把durable参数设置为持久化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.queueDeclare(QUEUE_NAME, `<span class=\"literal\">true</span>持久化，<span class=\"literal\">false</span>非持久化`, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果之前声明队列不是持久化，需要把原先队列删除，或者重新创建一个新的持久化队列，不然会出错</p>\n<p><code>ITION_FAILED - inequivalent arg &#39;durable&#39; for queue &#39;task_queue&#39; in vhost &#39;/&#39;: received &#39;true&#39; but current is &#39;false&#39;</code></p>\n</blockquote>\n</li>\n<li><h5 id=\"消息实现持久化\"><a href=\"#消息实现持久化\" class=\"headerlink\" title=\"消息实现持久化\"></a>消息实现持久化</h5><p>消息持久化需要在消息生产者中添加属性，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将消息持久化并不能完全保证消息不丢失，尽管它告诉RabbitMQ将消息保存在磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘，持久性保证并不强，但是对于简单的任务队列来说绰绰有余，如果需要更强的持久化策略，可以用发布确认</p>\n</blockquote>\n</li>\n<li><h5 id=\"不公平分发\"><a href=\"#不公平分发\" class=\"headerlink\" title=\"不公平分发\"></a>不公平分发</h5><p>能者多劳，一台机器处理快，一台机器处理慢，轮询分发会导致处理快的机器有一个空闲期等待处理慢的机器处理完毕，为了提高利用每台机器的最高性能，建议使用不公平分发，谁处理的快谁就多处理一点，处理慢的就少处理点</p>\n<p><code>为了避免这种情况，创建信道设置参数channel.basicQos(1);默认为轮询分发</code></p>\n</li>\n<li><h5 id=\"预取值\"><a href=\"#预取值\" class=\"headerlink\" title=\"预取值\"></a>预取值</h5><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<code>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</code>这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。<code>该值定义通道上允许的未确认消息的最大数量</code>。一旦数量达到配置的数量RabbitMO 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ.将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<code>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</code>(随机存取存诸器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并目不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中，对于大多数来说，稍微高一点的值将是最佳的</p>\n</li>\n</ol>\n<h3 id=\"6-发布确认\"><a href=\"#6-发布确认\" class=\"headerlink\" title=\"6.发布确认\"></a>6.发布确认</h3><h4 id=\"6-1发布确认原理\"><a href=\"#6-1发布确认原理\" class=\"headerlink\" title=\"6.1发布确认原理\"></a>6.1发布确认原理</h4><p>​    生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>\n<p>​    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>\n<h4 id=\"6-2发布确认的策略\"><a href=\"#6-2发布确认的策略\" class=\"headerlink\" title=\"6.2发布确认的策略\"></a>6.2发布确认的策略</h4><ol>\n<li><h5 id=\"开启发布确认的方法\"><a href=\"#开启发布确认的方法\" class=\"headerlink\" title=\"开启发布确认的方法\"></a>开启发布确认的方法</h5><p>发布确认默认是没有开启的，如果要开启需要调用方法confirmSelect，每当你要想使用发布确认，都需要在channel上调用该方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel channel = connection.createChannel();</span><br><span class=\"line\">channel.confirmSelect();</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"单个确认发布\"><a href=\"#单个确认发布\" class=\"headerlink\" title=\"单个确认发布\"></a>单个确认发布</h5><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。<br>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageIndividually</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">       <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">       channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">       channel.confirmSelect();</span><br><span class=\"line\">       <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;单个确认&quot;</span> + i;</span><br><span class=\"line\">           channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">           <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> channel.waitForConfirms();</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;消息 &quot;</span> + i + <span class=\"string\">&quot; 发送成功&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;发布单个确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"批量确认发布\"><a href=\"#批量确认发布\" class=\"headerlink\" title=\"批量确认发布\"></a>批量确认发布</h5><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageBatch</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">        channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//批量确认消息大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">batchSize</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;单个确认&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            <span class=\"comment\">//判断是否达到消息大小</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % batchSize == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"comment\">//发布确认</span></span><br><span class=\"line\">                channel.waitForConfirms();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"异步确认发布\"><a href=\"#异步确认发布\" class=\"headerlink\" title=\"异步确认发布\"></a>异步确认发布</h5><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说他是利用回调函数来达到消息可靠性传递的,这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的。\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//异步确认消息</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageAsync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">       <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">       channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">       channel.confirmSelect();</span><br><span class=\"line\">       <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       <span class=\"comment\">//准备消息的监听器 监听那些消息成功了 那些失败了</span></span><br><span class=\"line\">       <span class=\"comment\">//消息确认成功，回调函数</span></span><br><span class=\"line\">       <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">ackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"comment\">//消息确认失败，回调函数</span></span><br><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * deliveryTag      消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">        * multiple         是否批量确认</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">nackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;未确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"comment\">//监听失败也监听成功</span></span><br><span class=\"line\">       channel.addConfirmListener(ackCallback, nackCallback); <span class=\"comment\">//异步通知</span></span><br><span class=\"line\">       <span class=\"comment\">//批量发送消息</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;异步确认&quot;</span> + i;</span><br><span class=\"line\">           channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"如何处理异步未确认消息\"><a href=\"#如何处理异步未确认消息\" class=\"headerlink\" title=\"如何处理异步未确认消息\"></a>如何处理异步未确认消息</h5><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/异步确认消息</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageAsync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">        channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//线程安全有序的一个哈希表 适用于高并发的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">//1.轻松的将消息和序号进行关联</span></span><br><span class=\"line\">        <span class=\"comment\">//2.轻松批量删除条目  只要给到序号</span></span><br><span class=\"line\">        <span class=\"comment\">//3.支持高并发</span></span><br><span class=\"line\">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">//准备消息的监听器 监听那些消息成功了 那些失败了</span></span><br><span class=\"line\">        <span class=\"comment\">//消息确认成功，回调函数</span></span><br><span class=\"line\">        <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">ackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//2.删除已经确认的消息  剩下的就是未确认的消息</span></span><br><span class=\"line\">            <span class=\"comment\">//判断是否为批量</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multiple) &#123;</span><br><span class=\"line\">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class=\"line\">                confirmed.clear();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                outstandingConfirms.remove(deliveryTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">nackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//3.打印未确认的消息</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未确认的消息内容&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未确认的消息标识：&quot;</span> + deliveryTag);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//监听失败也监听成功</span></span><br><span class=\"line\">        channel.addConfirmListener(ackCallback, nackCallback); <span class=\"comment\">//异步通知</span></span><br><span class=\"line\">        <span class=\"comment\">//批量发送消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;异步确认&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            <span class=\"comment\">//1.记录所有要发送的消息  消息的总和</span></span><br><span class=\"line\">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"以上三种发布确认速度对比\"><a href=\"#以上三种发布确认速度对比\" class=\"headerlink\" title=\"以上三种发布确认速度对比\"></a>以上三种发布确认速度对比</h5><p><strong>单个确认：</strong>发布1000个消息到同一队列,耗时1863ms。</p>\n<p><strong>批量确认：</strong>发布1000个批量消息到同一队列,耗时150ms。</p>\n<p><strong>异步确认：</strong>发布1000个异步消息到同一队列,耗时99ms</p>\n</li>\n</ol>\n<h3 id=\"7-交换机\"><a href=\"#7-交换机\" class=\"headerlink\" title=\"7.交换机\"></a>7.交换机</h3><p>​\t 在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布&#x2F;订阅”.为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</p>\n<h4 id=\"7-1-Exchanges\"><a href=\"#7-1-Exchanges\" class=\"headerlink\" title=\"7.1 Exchanges\"></a>7.1 Exchanges</h4><ol>\n<li><p><strong>Exchanges概念</strong></p>\n<p>​\tRabbitMO 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。<br>​\t相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n</li>\n<li><p><strong>Exchanges的类型</strong></p>\n<ol>\n<li>直接(direct)    路由类型</li>\n<li>主题(topic)</li>\n<li>标题(headers)   头类型(不常用)</li>\n<li>扇出(fanot)     发布订阅类型</li>\n</ol>\n</li>\n<li><p><strong>无名Exchange</strong>(默认类型)</p>\n<p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;hello&quot;</span>,<span class=\"literal\">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机: 消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p>\n</li>\n</ol>\n<h4 id=\"7-2-临时队列\"><a href=\"#7-2-临时队列\" class=\"headerlink\" title=\"7.2 临时队列\"></a>7.2 临时队列</h4><p>​\t每当我们连接到 Rabbt 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p>\n<p>创建临时队列：channel.queueDeclare().getQueue()</p>\n<h4 id=\"7-3-绑定-bindings\"><a href=\"#7-3-绑定-bindings\" class=\"headerlink\" title=\"7.3 绑定(bindings)\"></a>7.3 绑定(bindings)</h4><p>binding就是exchange和queue之间的桥梁，告诉我们那个队列对应那个交换机</p>\n<h3 id=\"8-Fanout-发布订阅模式\"><a href=\"#8-Fanout-发布订阅模式\" class=\"headerlink\" title=\"8. Fanout(发布订阅模式)\"></a>8. Fanout(发布订阅模式)</h3><ol>\n<li><p>Fanout介绍</p>\n<p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型</p>\n</li>\n<li><p>Fanout实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogs01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明一个交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明一个队列   临时队列</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;01接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody())));</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogs02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明一个交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明一个队列   临时队列</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;02接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody())));</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息   交换机</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmitLog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"9-Direct-Exchange-路由模式\"><a href=\"#9-Direct-Exchange-路由模式\" class=\"headerlink\" title=\"9. Direct Exchange(路由模式)\"></a>9. Direct Exchange(路由模式)</h3><ol>\n<li><p>Direct Exchange</p>\n<p>队列只对它绑定的交换机的消息感兴趣。绑定用参数: routingKey 来表示也可称该参数为 binding key,创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME,”routingKey”);绑定之后的意义由其交换类型决定</p>\n</li>\n<li><p>多重绑定</p>\n<p>当然果exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和fanout 有点类似了，就跟广播差不多</p>\n</li>\n<li><p>实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogsDirect01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名字</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.queueDeclare(<span class=\"string\">&quot;console&quot;</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;console&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;console&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;一号队列接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        channel.basicConsume(<span class=\"string\">&quot;console&quot;</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogsDirect02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名字</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.queueDeclare(<span class=\"string\">&quot;disk&quot;</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;disk&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;二号队列接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        channel.basicConsume(<span class=\"string\">&quot;disk&quot;</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DirectLogs</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGES_NAME, <span class=\"string\">&quot;error&quot;</span>, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"10-Topics-主题模式\"><a href=\"#10-Topics-主题模式\" class=\"headerlink\" title=\"10. Topics(主题模式)\"></a>10. Topics(主题模式)</h3><ol>\n<li><p>之前类型的问题</p>\n<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型</p>\n</li>\n<li><p>Topic的要求</p>\n<p>​\t发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开</strong>。这些单词可以是任意单词</p>\n<p>比如说:”stockusd.nyse”，”nyse.vmw””quick.orange.rabbit”.这种类型的。当然这个单词列表<strong>最多不能超过 255 个字节</strong>。</p>\n<blockquote>\n<p>*(星号)可以代替一个单词</p>\n<p>#(井号)可以代替零个或多个单词</p>\n<p>当一个队列绑定#，那么这个队列将接收所有数据，就像fanout</p>\n<p>当一个队列没有出现*和#，那么该队列绑定类型就是direct</p>\n</blockquote>\n</li>\n<li><p>实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiverLogsTopic01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q1&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;*.orange.*&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息。。。&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C1接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>)+ <span class=\"string\">&quot; 绑定的key：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; System.out.println(consumerTag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiverLogsTopic02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q2&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;**.rabbit&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;lazy.#&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息。。。&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C2接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>)+ <span class=\"string\">&quot; 绑定的key：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; System.out.println(consumerTag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmitLogTopic</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.rabbit&quot;</span>, <span class=\"string\">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.orange.elephant&quot;</span>, <span class=\"string\">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.fox&quot;</span>, <span class=\"string\">&quot;被队列Q1接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.brown.fox&quot;</span>, <span class=\"string\">&quot;被队列Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.pink.rabbit&quot;</span>, <span class=\"string\">&quot;虽然满足两个绑定但只被队列Q2接收一次&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.brown.fox&quot;</span>, <span class=\"string\">&quot;不匹配任何绑定，没有队列接收，会被丢弃&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词但匹配Q2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">routingKey</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> entry.getValue();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"11-死信队列\"><a href=\"#11-死信队列\" class=\"headerlink\" title=\"11. 死信队列\"></a>11. 死信队列</h3><p><strong>11.1 死信的概念</strong></p>\n<p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<p><strong>应用场景</strong>：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>\n<p><strong>11.2 死信的来源</strong></p>\n<ul>\n<li>消息 TTL（存活时间） 过期</li>\n<li>队列达到最大长度(队列满了，无法再添加数据到队列中)</li>\n<li>消息被拒绝（消费方拒绝应答：basic.reject 或 basic.nack）并且（不放回队列中： requeue&#x3D;false）</li>\n</ul>\n<p><strong>11.3 死信实战</strong></p>\n<p>消息 TTL（存活时间） 过期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//消费者1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//普通队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        <span class=\"comment\">//普通队列</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数 ，满足死信三个条件转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长</span></span><br><span class=\"line\">        <span class=\"comment\">//arguments.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 正常队列设置死信交换机</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信RoutingKey</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        channel.queueDeclare(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, arguments);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(NORMAL_QUEUE_NAME, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息....&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C1接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">        channel.basicConsume(NORMAL_QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//消费者2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息....&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C2接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">        channel.basicConsume(DEAD_QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//生产者</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//死信消息  设置TTl</span></span><br><span class=\"line\">        AMQP.<span class=\"type\">BasicProperties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AMQP</span>.BasicProperties().builder().expiration(<span class=\"string\">&quot;10000&quot;</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>队列达到最大长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明队列</span></span><br><span class=\"line\"><span class=\"comment\">//普通队列</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 ，满足死信三个条件转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长</span></span><br><span class=\"line\"><span class=\"comment\">//arguments.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class=\"line\"><span class=\"comment\">// 正常队列设置死信交换机</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\"><span class=\"comment\">//设设置队列最大长度</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-max-length&quot;</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置死信RoutingKey</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">channel.queueDeclare(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p>消息被拒绝</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;info5&quot;</span>.equals(message))&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;C1拒绝此消息：&quot;</span>+<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class=\"literal\">false</span>(是否放回队列))</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;C1接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">     channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class=\"literal\">false</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//开启手动应答</span></span><br><span class=\"line\"> channel.basicConsume(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-延迟队列\"><a href=\"#12-延迟队列\" class=\"headerlink\" title=\"12.延迟队列\"></a>12.延迟队列</h3><h5 id=\"12-1-延迟队列概念\"><a href=\"#12-1-延迟队列概念\" class=\"headerlink\" title=\"12.1 延迟队列概念\"></a>12.1 延迟队列概念</h5><p>延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>\n<h5 id=\"12-2-延迟队列使用场景\"><a href=\"#12-2-延迟队列使用场景\" class=\"headerlink\" title=\"12.2 延迟队列使用场景\"></a>12.2 延迟队列使用场景</h5><ol>\n<li><p>订单在十分钟为支付则自动取消</p>\n</li>\n<li><p>新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒</p>\n</li>\n<li><p>用户注册成功后，如果三天没有登录则进行短信提示</p>\n</li>\n<li><p>用户发起退款，如果三天没有得到处理则通知相关运营人员</p>\n</li>\n<li><p>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p>\n<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如:发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭;看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗? 如果数据量比较少，确实可以这样做，比如: 对于“如果账单一周内未支付则进行自动结算”这样的需求如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如:“订单十分钟内末支付则关闭“，短期内末支付的订单数据可能会有很多，活动期间甚至会达到百万甚至干万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>\n</li>\n</ol>\n<h5 id=\"12-3-springboot整合\"><a href=\"#12-3-springboot整合\" class=\"headerlink\" title=\"12.3 springboot整合\"></a>12.3 springboot整合</h5><ol>\n<li><p>创建项目</p>\n</li>\n<li><p>导入依赖</p>\n<blockquote>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.amqp</groupId>\n    <artifactId>spring-rabbit-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n<p>其他的按自己需求导入</p>\n</blockquote>\n</li>\n<li><p>配置队列TTL配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TtlQueueConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">X_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;x&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">Y_DEAD_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;y&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_A</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QA&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_B</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QB&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_DEAD_B</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QD&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;xExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">xExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(X_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;yExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">yExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(Y_DEAD_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通队列    TTL=10s</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueA&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置TTL</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_A).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通队列    TTL=10s</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueB&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置TTL</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">40000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_B).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean()</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueD</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_DEAD_B).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueABindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class=\"string\">&quot;XA&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueBBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class=\"string\">&quot;XB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueDBindingY</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class=\"string\">&quot;YB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送延迟消息</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SendMsgController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//开始发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，发送一条信息给两个TTL队列：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XA&quot;</span>, <span class=\"string\">&quot;消息来自ttl为10s的队列:&quot;</span> + message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XB&quot;</span>, <span class=\"string\">&quot;消息来自ttl为40s的队列:&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;消费者</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLetterQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveD</span><span class=\"params\">(Message message, Channel channel)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码优化(自定义消息时长)</p>\n<p>优化配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TtlQueueConfig</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_C</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QC&quot;</span>;</span><br><span class=\"line\">      <span class=\"meta\">@Bean(&quot;queueC&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueC</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化生产者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，发送一条时长&#123;&#125;毫秒TTL信息给队列QC：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), ttlTime, message);</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>, <span class=\"string\">&quot;&quot;</span> + message, msg -&gt; &#123;</span><br><span class=\"line\">           <span class=\"comment\">//发送消息的时候，设置时长</span></span><br><span class=\"line\">           msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 <strong>RabbitMo 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列<strong>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></p>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h1><h3 id=\"1-什么是MQ\"><a href=\"#1-什么是MQ\" class=\"headerlink\" title=\"1.什么是MQ\"></a>1.什么是MQ</h3><p>​\tMQ(message queue),字面意思，本质上是一个队列，FIFO先进先出，只不过队列中存储的是消息，还是一种跨进程通信的机制，用于上下游传递消息，MQ是一种非常常见的上下游<code>逻辑解耦+物理解耦</code>的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>\n<h4 id=\"1-1为什么要用MQ\"><a href=\"#1-1为什么要用MQ\" class=\"headerlink\" title=\"1.1为什么要用MQ\"></a>1.1为什么要用MQ</h4><ol>\n<li><p><strong>流量消峰</strong></p>\n<p>流量削峰，如果观看抽奖或秒杀系统的请求监控曲线，你就会发现这类系统在活动开放的时间段内会出现一个波峰，而在活动未开放时，系统的请求量、机器负载一般都是比较平稳的。为了节省机器资源，我们不可能时时都提供最大化的资源能力来支持短时间的高峰请求。所以需要使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控</p>\n<p><strong>例子</strong>：有一个订单系统，最多处理一万次订单，这个处理能力应付正常时段的下单绰绰有余，正常下单一秒就有返回结果，但是在高峰期，如果有两万次下单操作系统处理不过来，只能限制订单超过一万不允许用户下单，使用消息队列做缓冲，我们可以取消这个限制，吧一秒内下的订单分散成一段时间来处理，这时有些用户下单后十几秒后才有下单成功的结果，导致用户体验不佳。</p>\n<p><code>如果请求过多，超过服务器压力点，会导致宕机,MQ就是让高峰期的请求数达到一个可控范围，使服务器保持稳定，不会宕机</code></p>\n</li>\n<li><p><strong>应用解耦</strong></p>\n<p>模块之间的调用十分复杂，为了降低模块与模块之间调用依赖，使用MQ将两系统分开,不直接调用系统接口,减轻两系统依赖关系</p>\n<p><strong>例子</strong>：电商应用为例，应用中有订单系统，库存系统，物流系统，支付系统，用户创建订单后，如果耦合调用库存系统，物流系统，支付系统，任何一个子系统出现故障，都会造成下单操作异常，当转变成基于消息队列的方式后，系统调用的问题会减少很多比如物流系统因为发送故障，需要几分钟来修复，在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成，当物流系统恢复后，继续处理订单信息即可，订单用户感受不到物流系统的故障，提升系统的可用性。</p>\n</li>\n<li><p><strong>异步处理</strong></p>\n<p>异步指一个执行中的任务，拆开成多个子任务各自执行。异步与同步处理相对，同步指多个执行中的子任务，等待所有子任务执行完再继续执行。异步的作用是使有I&#x2F;O操作的任务最大化利用处理器的计算，以达到缩短任务的完成时间。</p>\n</li>\n</ol>\n<h3 id=\"2-RabbitMQ概念\"><a href=\"#2-RabbitMQ概念\" class=\"headerlink\" title=\"2.RabbitMQ概念\"></a>2.RabbitMQ概念</h3><p>​\tRabbitMQ是一个消息中间件：它接受并转发消息，你可以把它当做一个传递点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人哪里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件，它不处理快件，而是接收，存储，转发消息数据</p>\n<h4 id=\"2-1四大核心概念\"><a href=\"#2-1四大核心概念\" class=\"headerlink\" title=\"2.1四大核心概念\"></a>2.1四大核心概念</h4><ol>\n<li><p>生产者</p>\n<p>产生数据发送消息的程序是生产者</p>\n</li>\n<li><p>交换机</p>\n<p>交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面他将消息推送到队列中，交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者吧消息丢弃，这个得有交换机类型决定</p>\n</li>\n<li><p>队列</p>\n<p>队列是RabbitMQ内部使用得一种数据结构，尽管消息流经RabbitMQ和应用程序，但他们只能存储在队列中，队列受主机得内存和磁盘限制和约束，本质上是一个大得消息缓冲区，许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据，这就是我们使用队列得方式</p>\n</li>\n<li><p>消费者</p>\n<p>消费与接收具有相似得含义。消费者大多时候是一个等待接收消息得程序，请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又是可以是消费者。</p>\n</li>\n</ol>\n<p>3.RabbitMQ核心部分</p>\n<ol>\n<li>Hello World(简单模式)</li>\n<li>Work queues(工作模式)</li>\n<li>Publish&#x2F;Subscribe(发布订阅模式)</li>\n<li>Routing(路由模式)</li>\n<li>Topics(主题模式)</li>\n<li>Publisher Confirms(发布确认模式)</li>\n</ol>\n<h3 id=\"3-安装RabbitMQ\"><a href=\"#3-安装RabbitMQ\" class=\"headerlink\" title=\"3.安装RabbitMQ\"></a>3.安装RabbitMQ</h3><p>RbbitMQ官网：<a href=\"https://www.rabbitmq.com/\">https://www.rabbitmq.com/</a></p>\n<p>RabbitMQ及环境下载：<a href=\"https://packagecloud.io/rabbitmq/\">https://packagecloud.io/rabbitmq/</a></p>\n<ol>\n<li>安装Erlang环境</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh erlang-xx.x-x.linux版本.x86_64.rpm</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>安装socat依赖</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install socat -y</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>安装rabbitMQ-server</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh rabbitmq-server-x.x.x-linux版本.noarch.rpm</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1常用命令\"><a href=\"#3-1常用命令\" class=\"headerlink\" title=\"3.1常用命令\"></a>3.1<strong>常用命令</strong></h4><ol>\n<li><p>添加开机启动RabbitMQ服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动RabbitMQ服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看RabbitMQ服务状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止RabbitMQ服务状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin/service rabbitmq-server stop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启Web管理插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br><span class=\"line\"></span><br><span class=\"line\">用默认账户密码(guest)访问地址http：//安装rabbitmq的主机ip地址:15672</span><br><span class=\"line\">这里会出现一个权限问题</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：15672端口必须开启或者关闭防火墙否则无法访问,正式项目不建议关闭防火墙</p>\n<p>systemctl stop firewalld  </p>\n<p>systemctl enabled firewalld</p>\n<p>systemctl start firewalld</p>\n<p>systemctl status firewalld</p>\n</blockquote>\n</li>\n<li><p>查看RabbitMQ有那些用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加一个新的用户</p>\n<ol>\n<li><p>创建账号</p>\n<blockquote>\n<p>rabbitmqctl add_user 用户名 密码</p>\n</blockquote>\n</li>\n<li><p>设置用户角色</p>\n<blockquote>\n<p>rabbitmqctl set_user_tags 用户名 权限</p>\n<p>例：rabbitmqctl set_user_tags user administrator</p>\n</blockquote>\n</li>\n<li><p>设置用户权限</p>\n<blockquote>\n<p>set_permissions [-p <vhostpath>] <user> <conf> <write> <read></p>\n<p>例如：rabbitmq set_permissions -p”&#x2F;“ admin “.<em>“ “.</em>“”.*”</p>\n<p>用户user_admin具有&#x2F;vhost1这个virtual host中所有资源的配置、写、读权限</p>\n</blockquote>\n</li>\n<li><p>修改密码</p>\n<blockquote>\n<p>rabbitmqctl  change_password  用户名  ‘新密码’</p>\n<p>例：rabbitmqctl  change_password  admin  ‘root’</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-Hello-World-简单模式\"><a href=\"#4-Hello-World-简单模式\" class=\"headerlink\" title=\"4.Hello World(简单模式)\"></a>4.Hello World(简单模式)</h3><h4 id=\"4-1创建maven项目\"><a href=\"#4-1创建maven项目\" class=\"headerlink\" title=\"4.1创建maven项目\"></a>4.1创建maven项目</h4><h4 id=\"4-2导入依赖\"><a href=\"#4-2导入依赖\" class=\"headerlink\" title=\"4.2导入依赖\"></a>4.2导入依赖</h4><blockquote>\n<!--        rabbitmq依赖客户端-->\n\n<dependency>    \n\n<p>​\t<groupId>com.rabbitmq</groupId>    </p>\n<p>​\t<artifactId>amqp-client</artifactId>    </p>\n<p>​\t<version>5.18.0</version></p>\n</dependency>\n\n<!--        操作文件流依赖-->\n\n<dependency>    \n\n<p>​\t<groupId>commons-io</groupId>    </p>\n<p>​\t<artifactId>commons-io</artifactId>    </p>\n<p>​\t<version>2.11.0</version></p>\n</dependency>\n</blockquote>\n<h4 id=\"4-3构建代码\"><a href=\"#4-3构建代码\" class=\"headerlink\" title=\"4.3构建代码\"></a>4.3构建代码</h4><p>​\t构建一个生产者P端，消费者C端，通过P端发消息给队列传递给C端，这个队列采用RabbitMQ来保留消息缓冲区</p>\n<h5 id=\"4-3-1构建生产者\"><a href=\"#4-3-1构建生产者\" class=\"headerlink\" title=\"4.3.1构建生产者\"></a>4.3.1构建生产者</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者：发送消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//发消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个连接工厂</span></span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        <span class=\"comment\">//设置工厂ip,连接RabbitMQ的队列</span></span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置用户名和密码</span></span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建连接  此处需要处理一个异常</span></span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//获取信道</span></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 生成一个队列</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> String queue,                 队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean durable               是否保存消息,队列里的消息是否持久化，默认队列里的消息存储在内存中</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean exclusive,            该队列是否只对一个消费者提供消费， 是否进行消息的共享，true可以多个消费者消费，默认情况下false：只能一个消费者</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> boolean autoDelete            是否自动删除，最后一个消费者断开连接后该队列是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> Map&lt;String, Object&gt; arguments 其他参数，如死信消息、延迟消息、</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送消息</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//利用信道发布消息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         *<span class=\"doctag\">@param</span> String exchange            交换机   默认交换机，可以忽略</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> String routingKey         路由key   填写队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> BasicProperties props     参数      无，填写null</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> byte[] body               消息体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发送完毕&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：还需要开放一个5672客户端端口，并且设置当前用户Permissions权限</p>\n</blockquote>\n<h5 id=\"4-3-1构建消费者\"><a href=\"#4-3-1构建消费者\" class=\"headerlink\" title=\"4.3.1构建消费者\"></a>4.3.1构建消费者</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\"><span class=\"comment\">//接收消息</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称   接收此队列消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建连接工厂</span></span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">//建立信道  利用信道接收消息</span></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明  接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消息体：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//声明  取消消息</span></span><br><span class=\"line\">        <span class=\"type\">CancelCallback</span> <span class=\"variable\">cancelCallback</span> <span class=\"operator\">=</span> (consumerTag) -&gt; System.out.println(<span class=\"string\">&quot;消费消息被中断时执行&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费者，接收消息</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> String queue                      队列名</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> boolean autoAck                   是否自动应答   消费成功后是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> DeliverCallback deliverCallback   消息的回调     消息未成功消费的回调</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@parma</span> CancelCallback cancelCallback     消息的回调     消费者取消消息的回调</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Work-Queues-工作模式\"><a href=\"#5-Work-Queues-工作模式\" class=\"headerlink\" title=\"5.Work Queues(工作模式)\"></a>5.Work Queues(工作模式)</h3><p>​\t工作队列(任务队列)的主要思想是避免立即执行资源密集型任务。而不得不等待它完成。相反我们安排任务在之后执行，我们把任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终稿执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。</p>\n<h4 id=\"5-1轮询分发消息\"><a href=\"#5-1轮询分发消息\" class=\"headerlink\" title=\"5.1轮询分发消息\"></a>5.1轮询分发消息</h4><ol>\n<li><p>抽取工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//rabbitmq创建连接信道</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitMQUtils</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个连接信道</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title function_\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ConnectionFactory</span> <span class=\"variable\">factory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactory</span>();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;192.168.100.137&quot;</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> factory.newConnection();</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> connection.createChannel();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者代码(接收消息的工作线程)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//工作线程01</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Work01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//消息接收</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">//消息取消</span></span><br><span class=\"line\">        <span class=\"type\">CancelCallback</span> <span class=\"variable\">cancelCallback</span> <span class=\"operator\">=</span> (consumerTag) -&gt; System.out.println(<span class=\"string\">&quot;消息被消费者取消：&quot;</span> + consumerTag);</span><br><span class=\"line\">        <span class=\"comment\">//消息的接收</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1线程等待中...&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者代码(发送消息)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//队列名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//从控制台当中接收信息</span></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息完成：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"5-2消息应答\"><a href=\"#5-2消息应答\" class=\"headerlink\" title=\"5.2消息应答\"></a>5.2消息应答</h4><ol>\n<li><p>消息应答概念</p>\n<p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然挂掉了，RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因它无法接收到。</p>\n<p><code>为了保证消息在发送过程中不丢失，rabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉rabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。</code></p>\n</li>\n<li><p>自动应答</p>\n<p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递消息的数量进行限制，当然这样有可能使得消费者这把由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这样的消息的情况下使用</p>\n</li>\n<li><p>消息应答的方法</p>\n<p>A.Channel.basicAck(用于肯定确认)</p>\n<p>​\tRabbitMQ已经知道该消息并且成功处理的消息，可以将其丢弃了</p>\n<p>B.Channel.basicNack(用于否定确认)</p>\n<p>C.Channel.basicReject(用于否定确认)</p>\n<p>​\t与Channel.basicNack相比少一个参数(批量处理)，不处理该消息了直接拒绝，可以将其丢弃</p>\n</li>\n<li><p>Multiple的解释</p>\n<p>手动应答的好处就是可以批量应答并且减少网络拥堵</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicAck(deliveryTag,<span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>multiple的true和false代表不同意思</p>\n<p>true：代表批量应答channel上未应答的消息</p>\n<p>例：channel上有传送tag的消息5，6，7，8当前tag是8那么此时5-8的这些还未应答的消息都会被确认收到消息的应答</p>\n<p>false：如true相反。一对一应答</p>\n</li>\n<li><p>消息自动重新入队</p>\n<p>如果消费者由于某些原因丢失连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对列重新排队，如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者，这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息</p>\n</li>\n<li><p>消息手动应答(代码)</p>\n<p>默认采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消息手动应答并不丢失，并且放回消息队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C1等待接收消息处理，短时间处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//沉睡一秒</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//手动应答</span></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> long deliveryTag     消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> boolean multiple     是否批量应答</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">autoAck</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -&gt; System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Worker02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ack_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;C2等待接收消息处理，长时间处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//沉睡一秒</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">30000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//手动应答</span></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> long deliveryTag     消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">             * <span class=\"doctag\">@param</span> boolean multiple     是否批量应答</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">autoAck</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, ((consumerTag, message) -&gt; System.out.println(consumerTag + <span class=\"string\">&quot;消费者取消消费接口回调逻辑&quot;</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"5-3RabbitMQ持久化\"><a href=\"#5-3RabbitMQ持久化\" class=\"headerlink\" title=\"5.3RabbitMQ持久化\"></a>5.3RabbitMQ持久化</h4><ol>\n<li><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>如果保证当RabbitMQ服务突然停掉以后消息生产者发送过来的消息不丢失。默认情况下RabbitMQ退出或由于某种原因崩溃了，它忽视队列和消息，除非告知它不要这么做，确保消息不会丢失需要做两件事<code>我们需要将队列和消息都标记为持久化</code></p>\n</li>\n<li><h5 id=\"队列如何实现持久化\"><a href=\"#队列如何实现持久化\" class=\"headerlink\" title=\"队列如何实现持久化\"></a>队列如何实现持久化</h5><p>RabbitMQ中的队列默认是非持久化的，RabbitMQ如果重启，该队列就会被删除掉，如果要队列实现持久化，需要声明队列的时候把durable参数设置为持久化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.queueDeclare(QUEUE_NAME, `<span class=\"literal\">true</span>持久化，<span class=\"literal\">false</span>非持久化`, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果之前声明队列不是持久化，需要把原先队列删除，或者重新创建一个新的持久化队列，不然会出错</p>\n<p><code>ITION_FAILED - inequivalent arg &#39;durable&#39; for queue &#39;task_queue&#39; in vhost &#39;/&#39;: received &#39;true&#39; but current is &#39;false&#39;</code></p>\n</blockquote>\n</li>\n<li><h5 id=\"消息实现持久化\"><a href=\"#消息实现持久化\" class=\"headerlink\" title=\"消息实现持久化\"></a>消息实现持久化</h5><p>消息持久化需要在消息生产者中添加属性，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将消息持久化并不能完全保证消息不丢失，尽管它告诉RabbitMQ将消息保存在磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘，持久性保证并不强，但是对于简单的任务队列来说绰绰有余，如果需要更强的持久化策略，可以用发布确认</p>\n</blockquote>\n</li>\n<li><h5 id=\"不公平分发\"><a href=\"#不公平分发\" class=\"headerlink\" title=\"不公平分发\"></a>不公平分发</h5><p>能者多劳，一台机器处理快，一台机器处理慢，轮询分发会导致处理快的机器有一个空闲期等待处理慢的机器处理完毕，为了提高利用每台机器的最高性能，建议使用不公平分发，谁处理的快谁就多处理一点，处理慢的就少处理点</p>\n<p><code>为了避免这种情况，创建信道设置参数channel.basicQos(1);默认为轮询分发</code></p>\n</li>\n<li><h5 id=\"预取值\"><a href=\"#预取值\" class=\"headerlink\" title=\"预取值\"></a>预取值</h5><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<code>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</code>这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。<code>该值定义通道上允许的未确认消息的最大数量</code>。一旦数量达到配置的数量RabbitMO 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ.将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<code>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</code>(随机存取存诸器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并目不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中，对于大多数来说，稍微高一点的值将是最佳的</p>\n</li>\n</ol>\n<h3 id=\"6-发布确认\"><a href=\"#6-发布确认\" class=\"headerlink\" title=\"6.发布确认\"></a>6.发布确认</h3><h4 id=\"6-1发布确认原理\"><a href=\"#6-1发布确认原理\" class=\"headerlink\" title=\"6.1发布确认原理\"></a>6.1发布确认原理</h4><p>​    生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>\n<p>​    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>\n<h4 id=\"6-2发布确认的策略\"><a href=\"#6-2发布确认的策略\" class=\"headerlink\" title=\"6.2发布确认的策略\"></a>6.2发布确认的策略</h4><ol>\n<li><h5 id=\"开启发布确认的方法\"><a href=\"#开启发布确认的方法\" class=\"headerlink\" title=\"开启发布确认的方法\"></a>开启发布确认的方法</h5><p>发布确认默认是没有开启的，如果要开启需要调用方法confirmSelect，每当你要想使用发布确认，都需要在channel上调用该方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel channel = connection.createChannel();</span><br><span class=\"line\">channel.confirmSelect();</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"单个确认发布\"><a href=\"#单个确认发布\" class=\"headerlink\" title=\"单个确认发布\"></a>单个确认发布</h5><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。<br>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageIndividually</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">       <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">       channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">       channel.confirmSelect();</span><br><span class=\"line\">       <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;单个确认&quot;</span> + i;</span><br><span class=\"line\">           channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">           <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> channel.waitForConfirms();</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">&quot;消息 &quot;</span> + i + <span class=\"string\">&quot; 发送成功&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;发布单个确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"批量确认发布\"><a href=\"#批量确认发布\" class=\"headerlink\" title=\"批量确认发布\"></a>批量确认发布</h5><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageBatch</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">        channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//批量确认消息大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">batchSize</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;单个确认&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            <span class=\"comment\">//判断是否达到消息大小</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % batchSize == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"comment\">//发布确认</span></span><br><span class=\"line\">                channel.waitForConfirms();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"异步确认发布\"><a href=\"#异步确认发布\" class=\"headerlink\" title=\"异步确认发布\"></a>异步确认发布</h5><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说他是利用回调函数来达到消息可靠性传递的,这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的。\t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//异步确认消息</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageAsync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">       <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">       channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">       channel.confirmSelect();</span><br><span class=\"line\">       <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       <span class=\"comment\">//准备消息的监听器 监听那些消息成功了 那些失败了</span></span><br><span class=\"line\">       <span class=\"comment\">//消息确认成功，回调函数</span></span><br><span class=\"line\">       <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">ackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"comment\">//消息确认失败，回调函数</span></span><br><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * deliveryTag      消息的标识</span></span><br><span class=\"line\"><span class=\"comment\">        * multiple         是否批量确认</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">nackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;未确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       <span class=\"comment\">//监听失败也监听成功</span></span><br><span class=\"line\">       channel.addConfirmListener(ackCallback, nackCallback); <span class=\"comment\">//异步通知</span></span><br><span class=\"line\">       <span class=\"comment\">//批量发送消息</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;异步确认&quot;</span> + i;</span><br><span class=\"line\">           channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"如何处理异步未确认消息\"><a href=\"#如何处理异步未确认消息\" class=\"headerlink\" title=\"如何处理异步未确认消息\"></a>如何处理异步未确认消息</h5><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/异步确认消息</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publishMessageAsync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> UUID.randomUUID().toString();</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//开启发布确认</span></span><br><span class=\"line\">        channel.confirmSelect();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//线程安全有序的一个哈希表 适用于高并发的情况下</span></span><br><span class=\"line\">        <span class=\"comment\">//1.轻松的将消息和序号进行关联</span></span><br><span class=\"line\">        <span class=\"comment\">//2.轻松批量删除条目  只要给到序号</span></span><br><span class=\"line\">        <span class=\"comment\">//3.支持高并发</span></span><br><span class=\"line\">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">//准备消息的监听器 监听那些消息成功了 那些失败了</span></span><br><span class=\"line\">        <span class=\"comment\">//消息确认成功，回调函数</span></span><br><span class=\"line\">        <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">ackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//2.删除已经确认的消息  剩下的就是未确认的消息</span></span><br><span class=\"line\">            <span class=\"comment\">//判断是否为批量</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (multiple) &#123;</span><br><span class=\"line\">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class=\"line\">                confirmed.clear();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                outstandingConfirms.remove(deliveryTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">ConfirmCallback</span> <span class=\"variable\">nackCallback</span> <span class=\"operator\">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//3.打印未确认的消息</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未确认的消息内容&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未确认的消息标识：&quot;</span> + deliveryTag);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//监听失败也监听成功</span></span><br><span class=\"line\">        channel.addConfirmListener(ackCallback, nackCallback); <span class=\"comment\">//异步通知</span></span><br><span class=\"line\">        <span class=\"comment\">//批量发送消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;异步确认&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"literal\">null</span>, message.getBytes());</span><br><span class=\"line\">            <span class=\"comment\">//1.记录所有要发送的消息  消息的总和</span></span><br><span class=\"line\">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">stopTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;发布批量确认消息耗时：&quot;</span> + (stopTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"以上三种发布确认速度对比\"><a href=\"#以上三种发布确认速度对比\" class=\"headerlink\" title=\"以上三种发布确认速度对比\"></a>以上三种发布确认速度对比</h5><p><strong>单个确认：</strong>发布1000个消息到同一队列,耗时1863ms。</p>\n<p><strong>批量确认：</strong>发布1000个批量消息到同一队列,耗时150ms。</p>\n<p><strong>异步确认：</strong>发布1000个异步消息到同一队列,耗时99ms</p>\n</li>\n</ol>\n<h3 id=\"7-交换机\"><a href=\"#7-交换机\" class=\"headerlink\" title=\"7.交换机\"></a>7.交换机</h3><p>​\t 在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布&#x2F;订阅”.为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</p>\n<h4 id=\"7-1-Exchanges\"><a href=\"#7-1-Exchanges\" class=\"headerlink\" title=\"7.1 Exchanges\"></a>7.1 Exchanges</h4><ol>\n<li><p><strong>Exchanges概念</strong></p>\n<p>​\tRabbitMO 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。<br>​\t相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n</li>\n<li><p><strong>Exchanges的类型</strong></p>\n<ol>\n<li>直接(direct)    路由类型</li>\n<li>主题(topic)</li>\n<li>标题(headers)   头类型(不常用)</li>\n<li>扇出(fanot)     发布订阅类型</li>\n</ol>\n</li>\n<li><p><strong>无名Exchange</strong>(默认类型)</p>\n<p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;hello&quot;</span>,<span class=\"literal\">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机: 消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的，如果它存在的话</p>\n</li>\n</ol>\n<h4 id=\"7-2-临时队列\"><a href=\"#7-2-临时队列\" class=\"headerlink\" title=\"7.2 临时队列\"></a>7.2 临时队列</h4><p>​\t每当我们连接到 Rabbt 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p>\n<p>创建临时队列：channel.queueDeclare().getQueue()</p>\n<h4 id=\"7-3-绑定-bindings\"><a href=\"#7-3-绑定-bindings\" class=\"headerlink\" title=\"7.3 绑定(bindings)\"></a>7.3 绑定(bindings)</h4><p>binding就是exchange和queue之间的桥梁，告诉我们那个队列对应那个交换机</p>\n<h3 id=\"8-Fanout-发布订阅模式\"><a href=\"#8-Fanout-发布订阅模式\" class=\"headerlink\" title=\"8. Fanout(发布订阅模式)\"></a>8. Fanout(发布订阅模式)</h3><ol>\n<li><p>Fanout介绍</p>\n<p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型</p>\n</li>\n<li><p>Fanout实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogs01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明一个交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明一个队列   临时队列</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;01接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody())));</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogs02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明一个交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//声明一个队列   临时队列</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> ((consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;02接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody())));</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息   交换机</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmitLog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGES_NAME, <span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"9-Direct-Exchange-路由模式\"><a href=\"#9-Direct-Exchange-路由模式\" class=\"headerlink\" title=\"9. Direct Exchange(路由模式)\"></a>9. Direct Exchange(路由模式)</h3><ol>\n<li><p>Direct Exchange</p>\n<p>队列只对它绑定的交换机的消息感兴趣。绑定用参数: routingKey 来表示也可称该参数为 binding key,创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME,”routingKey”);绑定之后的意义由其交换类型决定</p>\n</li>\n<li><p>多重绑定</p>\n<p>当然果exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和fanout 有点类似了，就跟广播差不多</p>\n</li>\n<li><p>实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogsDirect01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名字</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.queueDeclare(<span class=\"string\">&quot;console&quot;</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;console&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;console&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;一号队列接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        channel.basicConsume(<span class=\"string\">&quot;console&quot;</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiveLogsDirect02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名字</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.queueDeclare(<span class=\"string\">&quot;disk&quot;</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(<span class=\"string\">&quot;disk&quot;</span>, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;二号队列接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody()));</span><br><span class=\"line\">        channel.basicConsume(<span class=\"string\">&quot;disk&quot;</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DirectLogs</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGES_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGES_NAME, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGES_NAME, <span class=\"string\">&quot;error&quot;</span>, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"10-Topics-主题模式\"><a href=\"#10-Topics-主题模式\" class=\"headerlink\" title=\"10. Topics(主题模式)\"></a>10. Topics(主题模式)</h3><ol>\n<li><p>之前类型的问题</p>\n<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型</p>\n</li>\n<li><p>Topic的要求</p>\n<p>​\t发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开</strong>。这些单词可以是任意单词</p>\n<p>比如说:”stockusd.nyse”，”nyse.vmw””quick.orange.rabbit”.这种类型的。当然这个单词列表<strong>最多不能超过 255 个字节</strong>。</p>\n<blockquote>\n<p>*(星号)可以代替一个单词</p>\n<p>#(井号)可以代替零个或多个单词</p>\n<p>当一个队列绑定#，那么这个队列将接收所有数据，就像fanout</p>\n<p>当一个队列没有出现*和#，那么该队列绑定类型就是direct</p>\n</blockquote>\n</li>\n<li><p>实战</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiverLogsTopic01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q1&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;*.orange.*&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息。。。&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C1接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>)+ <span class=\"string\">&quot; 绑定的key：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; System.out.println(consumerTag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReceiverLogsTopic02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Q2&quot;</span>;</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;**.rabbit&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;lazy.#&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息。。。&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C2接收到的消息：&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>)+ <span class=\"string\">&quot; 绑定的key：&quot;</span> + message.getEnvelope().getRoutingKey());</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; System.out.println(consumerTag));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmitLogTopic</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//交换机名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">EXCHANGE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;topic_logs&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.rabbit&quot;</span>, <span class=\"string\">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.orange.elephant&quot;</span>, <span class=\"string\">&quot;被队列Q1Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.fox&quot;</span>, <span class=\"string\">&quot;被队列Q1接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.brown.fox&quot;</span>, <span class=\"string\">&quot;被队列Q2接收&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.pink.rabbit&quot;</span>, <span class=\"string\">&quot;虽然满足两个绑定但只被队列Q2接收一次&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.brown.fox&quot;</span>, <span class=\"string\">&quot;不匹配任何绑定，没有队列接收，会被丢弃&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;quick.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;lazy.orange.male.rabbit&quot;</span>, <span class=\"string\">&quot;是四个单词但匹配Q2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">routingKey</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> entry.getValue();</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"literal\">null</span>, message.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;生产者发送：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"11-死信队列\"><a href=\"#11-死信队列\" class=\"headerlink\" title=\"11. 死信队列\"></a>11. 死信队列</h3><p><strong>11.1 死信的概念</strong></p>\n<p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<p><strong>应用场景</strong>：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>\n<p><strong>11.2 死信的来源</strong></p>\n<ul>\n<li>消息 TTL（存活时间） 过期</li>\n<li>队列达到最大长度(队列满了，无法再添加数据到队列中)</li>\n<li>消息被拒绝（消费方拒绝应答：basic.reject 或 basic.nack）并且（不放回队列中： requeue&#x3D;false）</li>\n</ul>\n<p><strong>11.3 死信实战</strong></p>\n<p>消息 TTL（存活时间） 过期</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//消费者1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer01</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//普通队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class=\"line\">        <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">        <span class=\"comment\">//普通队列</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数 ，满足死信三个条件转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长</span></span><br><span class=\"line\">        <span class=\"comment\">//arguments.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 正常队列设置死信交换机</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信RoutingKey</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        channel.queueDeclare(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, arguments);</span><br><span class=\"line\">        <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绑定交换机和队列</span></span><br><span class=\"line\">        channel.queueBind(NORMAL_QUEUE_NAME, NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息....&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C1接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">        channel.basicConsume(NORMAL_QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//消费者2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer02</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//死信队列名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEAD_QUEUE_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;dead_queue&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;等待接收消息....&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; System.out.println(<span class=\"string\">&quot;C2接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">        channel.basicConsume(DEAD_QUEUE_NAME, <span class=\"literal\">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//生产者</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NORMAL_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;normal_exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> RabbitMQUtils.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//死信消息  设置TTl</span></span><br><span class=\"line\">        AMQP.<span class=\"type\">BasicProperties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AMQP</span>.BasicProperties().builder().expiration(<span class=\"string\">&quot;10000&quot;</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">11</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;info&quot;</span> + i;</span><br><span class=\"line\">            channel.basicPublish(NORMAL_EXCHANGE, <span class=\"string\">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>队列达到最大长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明队列</span></span><br><span class=\"line\"><span class=\"comment\">//普通队列</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 参数 ，满足死信三个条件转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//过期时间(单位：毫秒)   生产者发送的时候可以设置该消息时长</span></span><br><span class=\"line\"><span class=\"comment\">//arguments.put(&quot;x-message-ttl&quot;, 10000);</span></span><br><span class=\"line\"><span class=\"comment\">// 正常队列设置死信交换机</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class=\"line\"><span class=\"comment\">//设设置队列最大长度</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-max-length&quot;</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置死信RoutingKey</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">channel.queueDeclare(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p>消息被拒绝</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">DeliverCallback</span> <span class=\"variable\">deliverCallback</span> <span class=\"operator\">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"string\">&quot;info5&quot;</span>.equals(message))&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;C1拒绝此消息：&quot;</span>+<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class=\"literal\">false</span>(是否放回队列))</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;C1接收的消息&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody(), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">     channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class=\"literal\">false</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//开启手动应答</span></span><br><span class=\"line\"> channel.basicConsume(NORMAL_QUEUE_NAME, <span class=\"literal\">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-延迟队列\"><a href=\"#12-延迟队列\" class=\"headerlink\" title=\"12.延迟队列\"></a>12.延迟队列</h3><h5 id=\"12-1-延迟队列概念\"><a href=\"#12-1-延迟队列概念\" class=\"headerlink\" title=\"12.1 延迟队列概念\"></a>12.1 延迟队列概念</h5><p>延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>\n<h5 id=\"12-2-延迟队列使用场景\"><a href=\"#12-2-延迟队列使用场景\" class=\"headerlink\" title=\"12.2 延迟队列使用场景\"></a>12.2 延迟队列使用场景</h5><ol>\n<li><p>订单在十分钟为支付则自动取消</p>\n</li>\n<li><p>新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒</p>\n</li>\n<li><p>用户注册成功后，如果三天没有登录则进行短信提示</p>\n</li>\n<li><p>用户发起退款，如果三天没有得到处理则通知相关运营人员</p>\n</li>\n<li><p>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p>\n<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如:发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭;看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗? 如果数据量比较少，确实可以这样做，比如: 对于“如果账单一周内未支付则进行自动结算”这样的需求如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如:“订单十分钟内末支付则关闭“，短期内末支付的订单数据可能会有很多，活动期间甚至会达到百万甚至干万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>\n</li>\n</ol>\n<h5 id=\"12-3-springboot整合\"><a href=\"#12-3-springboot整合\" class=\"headerlink\" title=\"12.3 springboot整合\"></a>12.3 springboot整合</h5><ol>\n<li><p>创建项目</p>\n</li>\n<li><p>导入依赖</p>\n<blockquote>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.amqp</groupId>\n    <artifactId>spring-rabbit-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n<p>其他的按自己需求导入</p>\n</blockquote>\n</li>\n<li><p>配置队列TTL配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TtlQueueConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">X_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;x&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">Y_DEAD_EXCHANGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;y&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//声明队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_A</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QA&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_B</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QB&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_DEAD_B</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QD&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;xExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">xExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(X_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明死信交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;yExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">yExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(Y_DEAD_EXCHANGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通队列    TTL=10s</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueA&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置TTL</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_A).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//声明普通队列    TTL=10s</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;queueB&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;YD&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置TTL</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">40000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_B).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//死信队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean()</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueD</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_DEAD_B).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueABindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class=\"string\">&quot;XA&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueBBindingX</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class=\"string\">&quot;XB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">queueDBindingY</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span><br><span class=\"line\"><span class=\"params\">                                  <span class=\"meta\">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class=\"string\">&quot;YB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送延迟消息</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SendMsgController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//开始发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message)</span> &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，发送一条信息给两个TTL队列：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XA&quot;</span>, <span class=\"string\">&quot;消息来自ttl为10s的队列:&quot;</span> + message);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XB&quot;</span>, <span class=\"string\">&quot;消息来自ttl为40s的队列:&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;消费者</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLetterQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//接收消息</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveD</span><span class=\"params\">(Message message, Channel channel)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody());</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码优化(自定义消息时长)</p>\n<p>优化配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TtlQueueConfig</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">QUEUE_C</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;QC&quot;</span>;</span><br><span class=\"line\">      <span class=\"meta\">@Bean(&quot;queueC&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">queueC</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信交换机</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);</span><br><span class=\"line\">        <span class=\"comment\">//设置死信key</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化生产者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMsg</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String message, <span class=\"meta\">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class=\"line\">       log.info(<span class=\"string\">&quot;当前时间：&#123;&#125;，发送一条时长&#123;&#125;毫秒TTL信息给队列QC：&#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().toString(), ttlTime, message);</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;XC&quot;</span>, <span class=\"string\">&quot;&quot;</span> + message, msg -&gt; &#123;</span><br><span class=\"line\">           <span class=\"comment\">//发送消息的时候，设置时长</span></span><br><span class=\"line\">           msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 <strong>RabbitMo 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列<strong>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></p>\n</li>\n</ol>\n"},{"title":"SSM框架开发项目","date":"2023-03-15T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# SSM\n\n## Spring\n\n1. **IOC**\n\n   Inverse of Control（控制反转）指把创建对象过程交给Spring进行管理\n\n   1.1 依赖注入\n\n   依赖注入实现了控制反转的思想\n\n   依赖注入常见的实现方式包括两种：\n\n   ​\t第一种：Set注入\n\n   ​\t第二种：构造注入\n\n   1.2 基于XML管理Bean\n\n   ​\t1.2.1获取bean\n\n     1. 根据id获取\n\n        由于id属性指定了bean的唯一标识，所以根据bean标签的id属性可以精确获取到一个组件对象\n\n     2. 根据类型获取\n\n        ```java\n        @Test\n        public void testHelloWorld(){\n        \tApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");\n        \tHelloWorld bean = ac.getBean(HelloWorld.class);\n        \tbean.sayHello();\n        }\n        ```\n\n        \n\n     3. 根据id和类型\n\n   ```java\n   @Test\n   public void testHelloWorld(){\n   \tApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");\n   \tHelloWorld bean = ac.getBean(\"helloworld\",HelloWorld.class);\n   \tbean.sayHello();\n   }\n   ```\n\n   bean的作用域\n\n   | 取值            | 含义                                                      |\n   | --------------- | --------------------------------------------------------- |\n   | singleton(默认) | 在IOC容器中，这个bean的对象始终为单实例，容器初始化时创建 |\n   | prototype       | 这个bean在容器中有多个实例，获取bean时创建                |\n\n   \n\n2. **AOP**\n\n​\tAspect Oriented Programming（面向切面编程）AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，Aop还解决一些系统层面上的问题比如日志，事务、权限等\n\n\n\n\n\n1. Bean的生命周期\n\n   > bean对象创建（调用无参数构造）\n   >\n   > 给bean对象设置相关属性\n   >\n   > bean后置处理器（初始化之前）\n   >\n   > bean对象初始化（调用指定初始化方法）\n   >\n   > bean后置处理器（初始化之后）\n   >\n   > bean对象创建完成了，可以使用了\n   >\n   > bean对象销毁（配置指定销毁的方法）\n   >\n   > IOC容器关闭\n\n   \n\n2. 自动装配\n\n   > 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定bean中所依赖的类类型或接口类型属性赋值\n   >\n   > 例如：注意autowire属性的配置\n   >\n   > > ```java\n   > > <bean \n   > >    id=\"userController\"\n   > >    class=\"com.spring6.iocxml.auto.controller.UserController\"\n   > >    autowire=\"byType\"></bean>\n   >     \n   > byName：必须保证属性名称和bean的id名称保持一致\n\n3. 集合注入\n\n4. 声明式事务处理\n\n5. Spring注解\n\n   它是一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理，开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。\n\n   > Spring 通过注解实现自动装配的步骤如下：\n   >\n   > 1. 引入依赖\n   > 2. 开始组件扫描\n   > 3. 使用注解定义Bean\n   > 4. 依赖注入\n\n| 注解        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| @Component  | 该注解用于描述Spring中的Bean，他是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如Service层、Dao层等。使用时只需将该注解标注在相应类上即可。 |\n| @Repository | 该注解用于将数据访问层（Dao层）的类标识为Spring中的Bean，其功能与@Component相同 |\n| @Service    | 该注解通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同 |\n| @Controller | 该注解通常作用在控制层（如SpringMVC的Controller），用于将控制层的类标识为Spring中的Bean，其功能与@Component相同 |\n\n\n\n## SpringMVC\n\n1. handlerMapping\n\n2. RequestMapping\n\n3. springMVC参数传递\n\n4. 适配器\n\n5. 拦截器\n\n6. 试图和模型\n\n7. 上传文件\n\n8. 请求方式\n\n   > PUT\n\n   > POST\n\n   > GET\n\n   > DELETE\n\n\n\n## MyBatis\n\n#### 一、概念\n\n1. 为什么要用ORM\n2. 为什么使用MyBatis\n3. Mybatis快速入门\n\n#### 二、进阶\n\n1. MyBatis的配置\n2. 映射器的配置\n3. 动态SQL\n4. 整合Spring\n5. 缓存\n6. 关联查询\n7. 多对多查询\n8. 代码生成器\n\n\n\n#### 三、高级\n\n1. 源码分析\n2. 插件开发\n3. 分页插件使用与源码分析","source":"_posts/SSM.md","raw":"---\ntitle: SSM框架开发项目\ndate: 2023-03-15 11:18:57\ntags: 框架\ncategories: 框架\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# SSM\n\n## Spring\n\n1. **IOC**\n\n   Inverse of Control（控制反转）指把创建对象过程交给Spring进行管理\n\n   1.1 依赖注入\n\n   依赖注入实现了控制反转的思想\n\n   依赖注入常见的实现方式包括两种：\n\n   ​\t第一种：Set注入\n\n   ​\t第二种：构造注入\n\n   1.2 基于XML管理Bean\n\n   ​\t1.2.1获取bean\n\n     1. 根据id获取\n\n        由于id属性指定了bean的唯一标识，所以根据bean标签的id属性可以精确获取到一个组件对象\n\n     2. 根据类型获取\n\n        ```java\n        @Test\n        public void testHelloWorld(){\n        \tApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");\n        \tHelloWorld bean = ac.getBean(HelloWorld.class);\n        \tbean.sayHello();\n        }\n        ```\n\n        \n\n     3. 根据id和类型\n\n   ```java\n   @Test\n   public void testHelloWorld(){\n   \tApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");\n   \tHelloWorld bean = ac.getBean(\"helloworld\",HelloWorld.class);\n   \tbean.sayHello();\n   }\n   ```\n\n   bean的作用域\n\n   | 取值            | 含义                                                      |\n   | --------------- | --------------------------------------------------------- |\n   | singleton(默认) | 在IOC容器中，这个bean的对象始终为单实例，容器初始化时创建 |\n   | prototype       | 这个bean在容器中有多个实例，获取bean时创建                |\n\n   \n\n2. **AOP**\n\n​\tAspect Oriented Programming（面向切面编程）AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，Aop还解决一些系统层面上的问题比如日志，事务、权限等\n\n\n\n\n\n1. Bean的生命周期\n\n   > bean对象创建（调用无参数构造）\n   >\n   > 给bean对象设置相关属性\n   >\n   > bean后置处理器（初始化之前）\n   >\n   > bean对象初始化（调用指定初始化方法）\n   >\n   > bean后置处理器（初始化之后）\n   >\n   > bean对象创建完成了，可以使用了\n   >\n   > bean对象销毁（配置指定销毁的方法）\n   >\n   > IOC容器关闭\n\n   \n\n2. 自动装配\n\n   > 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定bean中所依赖的类类型或接口类型属性赋值\n   >\n   > 例如：注意autowire属性的配置\n   >\n   > > ```java\n   > > <bean \n   > >    id=\"userController\"\n   > >    class=\"com.spring6.iocxml.auto.controller.UserController\"\n   > >    autowire=\"byType\"></bean>\n   >     \n   > byName：必须保证属性名称和bean的id名称保持一致\n\n3. 集合注入\n\n4. 声明式事务处理\n\n5. Spring注解\n\n   它是一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理，开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。\n\n   > Spring 通过注解实现自动装配的步骤如下：\n   >\n   > 1. 引入依赖\n   > 2. 开始组件扫描\n   > 3. 使用注解定义Bean\n   > 4. 依赖注入\n\n| 注解        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| @Component  | 该注解用于描述Spring中的Bean，他是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如Service层、Dao层等。使用时只需将该注解标注在相应类上即可。 |\n| @Repository | 该注解用于将数据访问层（Dao层）的类标识为Spring中的Bean，其功能与@Component相同 |\n| @Service    | 该注解通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同 |\n| @Controller | 该注解通常作用在控制层（如SpringMVC的Controller），用于将控制层的类标识为Spring中的Bean，其功能与@Component相同 |\n\n\n\n## SpringMVC\n\n1. handlerMapping\n\n2. RequestMapping\n\n3. springMVC参数传递\n\n4. 适配器\n\n5. 拦截器\n\n6. 试图和模型\n\n7. 上传文件\n\n8. 请求方式\n\n   > PUT\n\n   > POST\n\n   > GET\n\n   > DELETE\n\n\n\n## MyBatis\n\n#### 一、概念\n\n1. 为什么要用ORM\n2. 为什么使用MyBatis\n3. Mybatis快速入门\n\n#### 二、进阶\n\n1. MyBatis的配置\n2. 映射器的配置\n3. 动态SQL\n4. 整合Spring\n5. 缓存\n6. 关联查询\n7. 多对多查询\n8. 代码生成器\n\n\n\n#### 三、高级\n\n1. 源码分析\n2. 插件开发\n3. 分页插件使用与源码分析","slug":"SSM","published":1,"updated":"2023-08-10T09:51:09.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9o000zfswo4xmo7t1p","content":"<h1 id=\"SSM\"><a href=\"#SSM\" class=\"headerlink\" title=\"SSM\"></a>SSM</h1><h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><ol>\n<li><p><strong>IOC</strong></p>\n<p>Inverse of Control（控制反转）指把创建对象过程交给Spring进行管理</p>\n<p>1.1 依赖注入</p>\n<p>依赖注入实现了控制反转的思想</p>\n<p>依赖注入常见的实现方式包括两种：</p>\n<p>​\t第一种：Set注入</p>\n<p>​\t第二种：构造注入</p>\n<p>1.2 基于XML管理Bean</p>\n<p>​\t1.2.1获取bean</p>\n<ol>\n<li><p>根据id获取</p>\n<p>由于id属性指定了bean的唯一标识，所以根据bean标签的id属性可以精确获取到一个组件对象</p>\n</li>\n<li><p>根据类型获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testHelloWorld</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">ApplicationContext</span> <span class=\"variable\">ac</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean.xml&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">HelloWorld</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> ac.getBean(HelloWorld.class);</span><br><span class=\"line\">\tbean.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>根据id和类型</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testHelloWorld</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">ApplicationContext</span> <span class=\"variable\">ac</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean.xml&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">HelloWorld</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> ac.getBean(<span class=\"string\">&quot;helloworld&quot;</span>,HelloWorld.class);</span><br><span class=\"line\">\tbean.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>bean的作用域</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singleton(默认)</td>\n<td>在IOC容器中，这个bean的对象始终为单实例，容器初始化时创建</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>这个bean在容器中有多个实例，获取bean时创建</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>AOP</strong></p>\n</li>\n</ol>\n<p>​\tAspect Oriented Programming（面向切面编程）AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，Aop还解决一些系统层面上的问题比如日志，事务、权限等</p>\n<ol>\n<li><p>Bean的生命周期</p>\n<blockquote>\n<p>bean对象创建（调用无参数构造）</p>\n<p>给bean对象设置相关属性</p>\n<p>bean后置处理器（初始化之前）</p>\n<p>bean对象初始化（调用指定初始化方法）</p>\n<p>bean后置处理器（初始化之后）</p>\n<p>bean对象创建完成了，可以使用了</p>\n<p>bean对象销毁（配置指定销毁的方法）</p>\n<p>IOC容器关闭</p>\n</blockquote>\n</li>\n<li><p>自动装配</p>\n<blockquote>\n<p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定bean中所依赖的类类型或接口类型属性赋值</p>\n<p>例如：注意autowire属性的配置</p>\n<blockquote>\n<pre><code class=\"java\">&lt;bean \n   id=&quot;userController&quot;\n   class=&quot;com.spring6.iocxml.auto.controller.UserController&quot;\n   autowire=&quot;byType&quot;&gt;&lt;/bean&gt;\n</code></pre>\n</blockquote>\n<p>byName：必须保证属性名称和bean的id名称保持一致</p>\n</blockquote>\n</li>\n<li><p>集合注入</p>\n</li>\n<li><p>声明式事务处理</p>\n</li>\n<li><p>Spring注解</p>\n<p>它是一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理，开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。</p>\n<blockquote>\n<p>Spring 通过注解实现自动装配的步骤如下：</p>\n<ol>\n<li>引入依赖</li>\n<li>开始组件扫描</li>\n<li>使用注解定义Bean</li>\n<li>依赖注入</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Component</td>\n<td>该注解用于描述Spring中的Bean，他是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如Service层、Dao层等。使用时只需将该注解标注在相应类上即可。</td>\n</tr>\n<tr>\n<td>@Repository</td>\n<td>该注解用于将数据访问层（Dao层）的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n<tr>\n<td>@Service</td>\n<td>该注解通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n<tr>\n<td>@Controller</td>\n<td>该注解通常作用在控制层（如SpringMVC的Controller），用于将控制层的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h2><ol>\n<li><p>handlerMapping</p>\n</li>\n<li><p>RequestMapping</p>\n</li>\n<li><p>springMVC参数传递</p>\n</li>\n<li><p>适配器</p>\n</li>\n<li><p>拦截器</p>\n</li>\n<li><p>试图和模型</p>\n</li>\n<li><p>上传文件</p>\n</li>\n<li><p>请求方式</p>\n<blockquote>\n<p>PUT</p>\n</blockquote>\n<blockquote>\n<p>POST</p>\n</blockquote>\n<blockquote>\n<p>GET</p>\n</blockquote>\n<blockquote>\n<p>DELETE</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h2><h4 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h4><ol>\n<li>为什么要用ORM</li>\n<li>为什么使用MyBatis</li>\n<li>Mybatis快速入门</li>\n</ol>\n<h4 id=\"二、进阶\"><a href=\"#二、进阶\" class=\"headerlink\" title=\"二、进阶\"></a>二、进阶</h4><ol>\n<li>MyBatis的配置</li>\n<li>映射器的配置</li>\n<li>动态SQL</li>\n<li>整合Spring</li>\n<li>缓存</li>\n<li>关联查询</li>\n<li>多对多查询</li>\n<li>代码生成器</li>\n</ol>\n<h4 id=\"三、高级\"><a href=\"#三、高级\" class=\"headerlink\" title=\"三、高级\"></a>三、高级</h4><ol>\n<li>源码分析</li>\n<li>插件开发</li>\n<li>分页插件使用与源码分析</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"SSM\"><a href=\"#SSM\" class=\"headerlink\" title=\"SSM\"></a>SSM</h1><h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><ol>\n<li><p><strong>IOC</strong></p>\n<p>Inverse of Control（控制反转）指把创建对象过程交给Spring进行管理</p>\n<p>1.1 依赖注入</p>\n<p>依赖注入实现了控制反转的思想</p>\n<p>依赖注入常见的实现方式包括两种：</p>\n<p>​\t第一种：Set注入</p>\n<p>​\t第二种：构造注入</p>\n<p>1.2 基于XML管理Bean</p>\n<p>​\t1.2.1获取bean</p>\n<ol>\n<li><p>根据id获取</p>\n<p>由于id属性指定了bean的唯一标识，所以根据bean标签的id属性可以精确获取到一个组件对象</p>\n</li>\n<li><p>根据类型获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testHelloWorld</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">ApplicationContext</span> <span class=\"variable\">ac</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean.xml&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">HelloWorld</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> ac.getBean(HelloWorld.class);</span><br><span class=\"line\">\tbean.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>根据id和类型</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testHelloWorld</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">ApplicationContext</span> <span class=\"variable\">ac</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean.xml&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">HelloWorld</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> ac.getBean(<span class=\"string\">&quot;helloworld&quot;</span>,HelloWorld.class);</span><br><span class=\"line\">\tbean.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>bean的作用域</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singleton(默认)</td>\n<td>在IOC容器中，这个bean的对象始终为单实例，容器初始化时创建</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>这个bean在容器中有多个实例，获取bean时创建</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>AOP</strong></p>\n</li>\n</ol>\n<p>​\tAspect Oriented Programming（面向切面编程）AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，Aop还解决一些系统层面上的问题比如日志，事务、权限等</p>\n<ol>\n<li><p>Bean的生命周期</p>\n<blockquote>\n<p>bean对象创建（调用无参数构造）</p>\n<p>给bean对象设置相关属性</p>\n<p>bean后置处理器（初始化之前）</p>\n<p>bean对象初始化（调用指定初始化方法）</p>\n<p>bean后置处理器（初始化之后）</p>\n<p>bean对象创建完成了，可以使用了</p>\n<p>bean对象销毁（配置指定销毁的方法）</p>\n<p>IOC容器关闭</p>\n</blockquote>\n</li>\n<li><p>自动装配</p>\n<blockquote>\n<p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定bean中所依赖的类类型或接口类型属性赋值</p>\n<p>例如：注意autowire属性的配置</p>\n<blockquote>\n<pre><code class=\"java\">&lt;bean \n   id=&quot;userController&quot;\n   class=&quot;com.spring6.iocxml.auto.controller.UserController&quot;\n   autowire=&quot;byType&quot;&gt;&lt;/bean&gt;\n</code></pre>\n</blockquote>\n<p>byName：必须保证属性名称和bean的id名称保持一致</p>\n</blockquote>\n</li>\n<li><p>集合注入</p>\n</li>\n<li><p>声明式事务处理</p>\n</li>\n<li><p>Spring注解</p>\n<p>它是一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理，开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。</p>\n<blockquote>\n<p>Spring 通过注解实现自动装配的步骤如下：</p>\n<ol>\n<li>引入依赖</li>\n<li>开始组件扫描</li>\n<li>使用注解定义Bean</li>\n<li>依赖注入</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Component</td>\n<td>该注解用于描述Spring中的Bean，他是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如Service层、Dao层等。使用时只需将该注解标注在相应类上即可。</td>\n</tr>\n<tr>\n<td>@Repository</td>\n<td>该注解用于将数据访问层（Dao层）的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n<tr>\n<td>@Service</td>\n<td>该注解通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n<tr>\n<td>@Controller</td>\n<td>该注解通常作用在控制层（如SpringMVC的Controller），用于将控制层的类标识为Spring中的Bean，其功能与@Component相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h2><ol>\n<li><p>handlerMapping</p>\n</li>\n<li><p>RequestMapping</p>\n</li>\n<li><p>springMVC参数传递</p>\n</li>\n<li><p>适配器</p>\n</li>\n<li><p>拦截器</p>\n</li>\n<li><p>试图和模型</p>\n</li>\n<li><p>上传文件</p>\n</li>\n<li><p>请求方式</p>\n<blockquote>\n<p>PUT</p>\n</blockquote>\n<blockquote>\n<p>POST</p>\n</blockquote>\n<blockquote>\n<p>GET</p>\n</blockquote>\n<blockquote>\n<p>DELETE</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h2><h4 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h4><ol>\n<li>为什么要用ORM</li>\n<li>为什么使用MyBatis</li>\n<li>Mybatis快速入门</li>\n</ol>\n<h4 id=\"二、进阶\"><a href=\"#二、进阶\" class=\"headerlink\" title=\"二、进阶\"></a>二、进阶</h4><ol>\n<li>MyBatis的配置</li>\n<li>映射器的配置</li>\n<li>动态SQL</li>\n<li>整合Spring</li>\n<li>缓存</li>\n<li>关联查询</li>\n<li>多对多查询</li>\n<li>代码生成器</li>\n</ol>\n<h4 id=\"三、高级\"><a href=\"#三、高级\" class=\"headerlink\" title=\"三、高级\"></a>三、高级</h4><ol>\n<li>源码分析</li>\n<li>插件开发</li>\n<li>分页插件使用与源码分析</li>\n</ol>\n"},{"title":"Typora快捷键大全","date":"2022-08-15T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# Typora快捷键大全\n## 简介\nTypora 是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。\n## 介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在2004由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 `.md `，`.markdown`。\n\n## 常用快捷键\n- 加粗：`Ctrl + B`\n- 标题：`Ctrl + H`\n- 插入链接：`Ctrl + K`\n- 字体倾斜：`Ctrl + I`\n- 下划线：`Ctrl + U`\n- 返回Typora顶部：`Ctrl+Home`\n- 返回Typora底部：`Ctrl+End`\n- 创建表格：`Ctrl+T`\n- 创建超链接：`Ctrl+K`\n- 搜索：`Ctrl+F`\n- 选中某句话：`Ctrl+L`\n- 选中某个单词：`Ctrl+D`\n- 选中相同格式的文字：`Ctrl+E`\n- 搜索并替换：`Ctrl+H`\n- 删除线：`Alt+Shift+5`\n- 插入图片：`Ctrl+Shift+I`\n- 引用：`Ctrl+Shift+Q`\n- 公式块：`Ctrl+Shift+M`\n- h1~h6: `Ctrl+1~Ctrl+6`","source":"_posts/Typora快捷键大全.md","raw":"---\ntitle: Typora快捷键大全\ndate: 2022-08-15 11:18:57\ntags: 计算机学习\ncategories: 计算机学习\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# Typora快捷键大全\n## 简介\nTypora 是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。\n## 介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在2004由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 `.md `，`.markdown`。\n\n## 常用快捷键\n- 加粗：`Ctrl + B`\n- 标题：`Ctrl + H`\n- 插入链接：`Ctrl + K`\n- 字体倾斜：`Ctrl + I`\n- 下划线：`Ctrl + U`\n- 返回Typora顶部：`Ctrl+Home`\n- 返回Typora底部：`Ctrl+End`\n- 创建表格：`Ctrl+T`\n- 创建超链接：`Ctrl+K`\n- 搜索：`Ctrl+F`\n- 选中某句话：`Ctrl+L`\n- 选中某个单词：`Ctrl+D`\n- 选中相同格式的文字：`Ctrl+E`\n- 搜索并替换：`Ctrl+H`\n- 删除线：`Alt+Shift+5`\n- 插入图片：`Ctrl+Shift+I`\n- 引用：`Ctrl+Shift+Q`\n- 公式块：`Ctrl+Shift+M`\n- h1~h6: `Ctrl+1~Ctrl+6`","slug":"Typora快捷键大全","published":1,"updated":"2023-08-10T07:47:38.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9q0014fswo91fudx4y","content":"<h1 id=\"Typora快捷键大全\"><a href=\"#Typora快捷键大全\" class=\"headerlink\" title=\"Typora快捷键大全\"></a>Typora快捷键大全</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Typora 是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在2004由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 <code>.md </code>，<code>.markdown</code>。</p>\n<h2 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h2><ul>\n<li>加粗：<code>Ctrl + B</code></li>\n<li>标题：<code>Ctrl + H</code></li>\n<li>插入链接：<code>Ctrl + K</code></li>\n<li>字体倾斜：<code>Ctrl + I</code></li>\n<li>下划线：<code>Ctrl + U</code></li>\n<li>返回Typora顶部：<code>Ctrl+Home</code></li>\n<li>返回Typora底部：<code>Ctrl+End</code></li>\n<li>创建表格：<code>Ctrl+T</code></li>\n<li>创建超链接：<code>Ctrl+K</code></li>\n<li>搜索：<code>Ctrl+F</code></li>\n<li>选中某句话：<code>Ctrl+L</code></li>\n<li>选中某个单词：<code>Ctrl+D</code></li>\n<li>选中相同格式的文字：<code>Ctrl+E</code></li>\n<li>搜索并替换：<code>Ctrl+H</code></li>\n<li>删除线：<code>Alt+Shift+5</code></li>\n<li>插入图片：<code>Ctrl+Shift+I</code></li>\n<li>引用：<code>Ctrl+Shift+Q</code></li>\n<li>公式块：<code>Ctrl+Shift+M</code></li>\n<li>h1<del>h6: &#96;Ctrl+1</del>Ctrl+6&#96;</li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Typora快捷键大全\"><a href=\"#Typora快捷键大全\" class=\"headerlink\" title=\"Typora快捷键大全\"></a>Typora快捷键大全</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Typora 是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在2004由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 <code>.md </code>，<code>.markdown</code>。</p>\n<h2 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h2><ul>\n<li>加粗：<code>Ctrl + B</code></li>\n<li>标题：<code>Ctrl + H</code></li>\n<li>插入链接：<code>Ctrl + K</code></li>\n<li>字体倾斜：<code>Ctrl + I</code></li>\n<li>下划线：<code>Ctrl + U</code></li>\n<li>返回Typora顶部：<code>Ctrl+Home</code></li>\n<li>返回Typora底部：<code>Ctrl+End</code></li>\n<li>创建表格：<code>Ctrl+T</code></li>\n<li>创建超链接：<code>Ctrl+K</code></li>\n<li>搜索：<code>Ctrl+F</code></li>\n<li>选中某句话：<code>Ctrl+L</code></li>\n<li>选中某个单词：<code>Ctrl+D</code></li>\n<li>选中相同格式的文字：<code>Ctrl+E</code></li>\n<li>搜索并替换：<code>Ctrl+H</code></li>\n<li>删除线：<code>Alt+Shift+5</code></li>\n<li>插入图片：<code>Ctrl+Shift+I</code></li>\n<li>引用：<code>Ctrl+Shift+Q</code></li>\n<li>公式块：<code>Ctrl+Shift+M</code></li>\n<li>h1<del>h6: &#96;Ctrl+1</del>Ctrl+6&#96;</li>\n</ul>\n"},{"title":"Spring框架","date":"2023-03-12T03:18:57.000Z","cover":"/img/images/Spring.jpg","_content":"\n\n## 一、spring框架概述\n\n1. Spring是轻量级的开源的JavaEE框架\n2. Spring可以解决企业应用开发的复杂性\n3. Spring有两个核心部分：IOC和AOP\n   1. IOC：控制反转，把创建对象过程交给Spring进行管理\n   2. AOP：面向切面，不修改源代码进行功能增强\n4. Spring特点\n   1. 方便解耦，简化开发\n   2. AOP编程支持\n   3. 方便程序测试\n   4. 方便和其他框架进行整合\n   5. 方便进行事务操作\n   6. 降低API开发难度\n\n## 二、IOC\n\n### IOC(概念和原理)\n\n##### 一、什么是IOC\n\n1. 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理\n2. 使用IOC的目的：为了降低程序的耦合度\n3. Spring容器在初始化时先读取配置文件，根据配置文件或元数据，创建并组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n\n##### 二、IOC底层原理\n\n1. XML解析、工厂模式、反射\n\n2. 原始方式创建\n\n   ```java\n   class UserService{\n   \texecute(){\n   \t\tUserDao dao = new UserDao();\n   \t\tdao.add();\n   \t}\n   }\n   class UserDao{\n       add(){\n           ......\n       }\n   }\n   ```\n\n3. 工厂模式\n\n   ```java\n   class UserService{\n       execute(){\n           UserDao dao = UserFactory.getDao();\n           dao.add();\n       }\n   }\n   class UserDao{\n       add(){\n           ......\n       }\n   }\n   class UserFactory{\n       public static UserDao getDao(){\n           return new UserDao();\n       }\n   }\n   ```\n\n4. IOC解耦过程\n\n   > 第一步：xml配置文件，配置创建的对象\n   >\n   > <bean id=\"dao\" class=\"com.test.xxx.UserDao\"></bean>\n   >\n   > 第二步：有service类和到dao类，创建工厂类\n   >\n   > ```java\n   > class UserFactory{\n   >     public static UserDao getDao(){\n   >         String classValue = class属性值；//1. xml解析\n   >         Class clazz = Class.forName(classValue);//2.通过反射创建对象\n   >         return （UserDao)clazz.newInstance() \n   >     }\n   > }\n   > ```\n\n##### 三、IOC接口(BeanFactory)\n\n1. IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n\n2. Spring提供IOC容器实现两种方式:\n\n   1. BeanFactory:IOC容器基本实现，是Spring内部的使用接口，不提供开发人员使用\n\n      > 加载配置获取文件的时候不会创建对象，在获取/使用对象的时候才去创建对象\n      >\n      > 什么时候用什么时候创建对象\n\n   2. ApplicationContext：BeanFactory接口的子接口，提供更强大的功能，一般由开发人员进行使用\n\n      > 加载配置文件的时候就会把配置文件中的对象进行创建\n\n   3. ApplicationContext的实现类\n\n      FileSystemXmlApplicationContext:磁盘下配置文件路径\n\n      ClassPathXmlApplicationContext：类路径下的配置文件\n\n##### 四、IOC操作Bean管理\n\n1. **什么是Bean管理**\n   1. Bean管理\n   2. Spring创建对象\n   3. Spring注入属性\n2. **Bean管理操作有两种方式**\n   1. IOC操作Bean管理(基于xml)\n   2. IOC操作Bean管理(基于注解)\n\n##### 五、IOC操作Bean管理(基于xml)\n\n1. **基于xml方式创建对象**\n\n   > 1. 在spring配置文件中使用bean标签，标签里面添加对应的属性，就可以实现对象创建\n   >\n   >    <bean id=\"user\" class=\"com.xxx.xxx.User\"></bean>\n   >\n   > 2. 在bean标签有很多属性，介绍常用的属性：\n   >\n   >    1. id属性：创建对象的唯一标识\n   >    2. class属性：类全路径(包类路径) \n   >\n   > 3. 创建对象时候，默认也是执行无参构造方法完成对象创建\n\n2. **基于xml方式注入属性**\n\n   1. DI：依赖注入，就是注入属性\n\n3. **第一种注入方式：使用set方法进行注入**\n\n   1. 创建类，定义属性和对应的set方法\n\n      ```java\n      class Book{\n          private String bName;\n          public void setBName(String bName){\n              this.bName = bName;\n          }\n      }\n      ```\n\n   2. 在spring配置文件配置对象创建，配置属性注入\n\n      > set方法注入属性\n      >\n      > <bean id=\"book\" class=\"com.xxx.xxx.Book\">\n      >\n      > ​\tname: 类里面的属性名称\n      >\n      > ​\tvalue：向属性注入的值\n      >\n      > ​\t<property name=\"bName\" value=\"红楼梦\"></property>\n      >\n      > </bean>\n\n4. **第二种注入方式：使用有参数构造进行注入**\n\n   1. 创建类，定义属性，创建属性对应有参数的构造方法\n\n      ```java\n      public class Orders {\n          //属性\n          private String oName;\n          private String address;\n          //有参数构造\n          public Orders(String oName, String address) {\n              this.oName = oName;\n              this.address = address;\n          }\n      }\n      ```\n\n   2. 在Spring配置文件中进行配置\n\n      > 有参数构造注入属性\n      >\n      > <bean id=\"orders\" class=\"com.xxx.xxx.Orders\">\n      >\n      >  \t<constructor-arg name=\"oname\" value=\"电脑\"></constructor-arg>\n      >\n      > ​\t <constructor-arg name=\"address\" value=\"China\"></constructor-arg>\n      >\n      > </bean>\n\n5. **p名称空间注入(简化xml配置)**\n\n   底层还是采用set注入，简化xml配置文件多属性注入\n\n   1. **使用p名称空间注入，可以简化基于xml配置方式**\n\n      > 第一步添加p名称空间在配置文件中\n      >\n      > <beans  xmls:p=\"https://www.springframework.org/schema/p\">\n      >\n      > 第二步 进行属性注入，在bean标签里面进行操作\t\n      >\n      > ​\t<bean id=\"book\" class=\"com.xxx.xxx.Book\" p:bname=\"三国演义\" p:bauthor=\"罗贯中\" >\n      >\n      > ​\t</bean>\n      >\n      > </beans>\n\n##### 六、IOC操作Bean管理(xml注入其他类型属性)\n\n1. **字面值**\n\n   1. null值\n\n      <property name=\"address\">\n\n      ​\t<null/>\n\n      </property>\n\n   2. 属性值包含特殊符号\n\n      <property name=\"address\">\n\n      ​\t<value><![CDATA[<<南京>>]]></value>\n\n      </property>\n   \n2. 外部Bean注入\n\n   > 第一步：创建两个类service类和dao类\n   >\n   > ```java\n   > \n   > public interface UserDao {\n   >     public void update();\n   > }\n   > \n   > public class UserDaoImpl implements UserDao{\n   >     @Override\n   >     public void update() {\n   >         System.out.println(\"Dao update.....\");\n   >     }\n   > }\n   > ```\n   >\n   > 第二步：在service调用dao类里面的方法\n   >\n   > ```java\n   > public class UserService {\n   >     //创建UserDao类型属性，生成set方法\n   >     private UserDao userDao;\n   >     public void setUserDao(UserDao userDao) {\n   >         this.userDao = userDao;\n   >     }\n   >     public void add(){\n   >         System.out.println(\"service add......\");\n   > //        原始方式：\n   > //        创建UserDao对象\n   > //        UserDaoImpl userDao = new UserDaoImpl();\n   >         userDao.update();\n   >     }\n   > }\n   > ```\n   >\n   > 第三步：在spting配置文件中进行配置\n   >\n   > ```xml\n   > <!--    service和dao对象创建-->\n   >     <bean id=\"userService\" class=\"com.test.spring5.service.UserService\">\n   > <!--        注入UserDao对象-->\n   > <!--        ref:创建的userDao对象bean标签-->\n   >         <property name=\"userDao\" ref=\"userDao\"></property>\n   >     </bean>\n   >     <bean id=\"userDao\" class=\"com.test.spring5.dao.UserDaoImpl\"></bean>\n   > ```\n\n3. 内部Bean注入和级联赋值\n\n   一对多关系：部门和员工，一个部门有多个员工，一个员工属于某一个部门，部门是一，员工是多\n\n   ```java\n   // 部门类\n   public class Dept {\n       private String dName;\n       public void setdName(String dName) {\n           this.dName = dName;\n       }\n   }\n   ```\n\n   ```java\n   // 员工类\n   public class Emp {\n       private String eName;\n       private String gender;\n       private Dept dept;\n       public void setDept(Dept dept) {\n           this.dept = dept;\n       }\n       public void seteName(String eName) {\n           this.eName = eName;\n       }\n       public void setGender(String gender) {\n           this.gender = gender;\n       }\n   }\n   ```\n\n   对spring配置文件中进行配置\n\n   ```xml\n   <!--    内部bean-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n   <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n   <!--        设置对象类型属性-->\n           <property name=\"dept\">\n               <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n                   <property name=\"dName\" value=\"保安部\"></property>\n               </bean>\n           </property>\n       </bean>\n   ```\n\n4. 级联赋值\n\n   第一种写法：xml配置文件\n\n   ```xml\n      <!--    级联赋值-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n           <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n           <!--        设置对象类型属性-->\n   <!--        级联赋值-->\n           <property name=\"dept\" ref=\"dept\"></property>\n       </bean>\n       <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n           <property name=\"dName\" value=\"财务部\"></property>\n       </bean>\n   ```\n\n   第二种写法：生成get方法并修改配置文件\n\n   ```xml\n   <!--    级联赋值-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n           <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n           <!--        设置对象类型属性-->\n   <!--        级联赋值-->\n           <property name=\"dept\" ref=\"dept\"></property>\n           <property name=\"dept.dName\" value=\"技术部\"></property>\n       </bean>\n       <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n           <property name=\"dName\" value=\"财务部\"></property>\n       </bean>\n   ```\n\n##### 七、IOC操作Bean管理(xml注入集合属性)\n\n1. 注入数组类型属性\n\n2. 注入list集合类型属性\n\n3. 注入Map集合类型属性\n\n   第一步：定义一个类，定义数组、list集合、map集合、set集合属性，生成对应的set方法\n\n   ```java\n   public class Stu {\n       //1.数组类型属性\n       private String[] courses;\n       //2.list集合类型属性\n       private List<String> list;\n       //3.map集合类型属性\n       private Map<String,String> maps;\n       //4.set集合类型属性\n       private Set<String> sets;\n       public void setList(List<String> list) {\n           this.list = list;\n       }\n       public void setMaps(Map<String, String> maps) {\n           this.maps = maps;\n       }\n       public void setCourses(String[] courses) {\n           this.courses = courses;\n       }\n   }\n   ```\n\n   第二步：配置spring配置文件进行配置\n   \n   ```xml\n   <!--    集合类型属性注入-->\n       <bean id=\"stu\" class=\"com.test.spring5.collectiontype.Stu\">\n   <!--      数组属性注入-->\n           <property name=\"courses\">\n               <array>\n                   <value>语文</value>\n                   <value>数学</value>\n                   <value>英语</value>\n               </array>\n           </property>\n   <!--        list集合属性注入-->\n           <property name=\"list\">\n               <list>\n                   <value>张三</value>\n                   <value>李四</value>\n                   <value>王五</value>\n               </list>\n           </property>\n   <!--        map集合属性注入-->\n           <property name=\"maps\">\n                <map>\n                    <entry key=\"Java\" value=\"java基础\"></entry>\n                    <entry key=\"PHP\" value=\"php\"></entry>\n                </map>\n           </property>\n   <!--        set集合属性注入-->\n           <property name=\"sets\">\n               <set>\n                   <value>MySQL</value>\n                   <value>Redis</value>\n               </set>\n           </property>\n       </bean>\n   ```\n   \n4. 在集合里面设置对象类型的值\n\n   ```xml\n   <!--    创建多个course对象-->\n       <bean id=\"course1\" class=\"com.test.spring5.collectiontype.Course\">\n           <property name=\"cname\" value=\"Spring5\"></property>\n       </bean>\n       <bean id=\"course2\" class=\"com.test.spring5.collectiontype.Course\">\n           <property name=\"cname\" value=\"MyBatis\"></property>\n       </bean>\n   ```\n\n   ```xml\n   <!--        注入list集合类型，值是对象-->\n           <property name=\"courseList\">\n               <list>\n                   <ref bean=\"course1\"></ref>\n                   <ref bean=\"course2\"></ref>\n               </list>\n           </property>\n   ```\n\n5. 把集合注入部分提取出来\n\n   第一步：先在Spring配置文件中引入名称空间(util)\n\n   ```xml\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:util=\"http://www.springframework.org/schema/util\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                              http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n   \">\n   ```\n\n   第二步：使用util标签完成list集合注入提取\n\n   ```xml\n   <!--    1.提取list集合类型属性注入-->\n       <util:list id=\"bookList\">\n           <value>红楼梦</value>\n           <value>西游记</value>\n           <value>易筋经</value>\n       </util:list>\n   <!--    2.提取list注入使用-->\n       <bean id=\"book\" class=\"com.test.spring5.collectiontype.Book\">\n           <property name=\"list\" ref=\"bookList\"></property>\n       </bean>\n   ```\n\n##### 八、IOC操作Bean管理(FactoryBean)\n\n1. Spring有两种类型的Bean，一种普通的bean，另外一种是工厂bean(FactoryBean)\n\n   > 普通Bean：在配置文件中定义Bean类型就是返回类型\n   >\n   > 工厂Bean：在配置文件定义Bean类型可以和返回类型不一样\n\n   第一步：创建类，让这个类作为工厂Bean，实现接口FactoryBean\n\n   第二步：实现接口里面的方法，在实现的方法中定义返回的Bean类型\n\n   ```java\n   public class MyBean implements FactoryBean<Course> {\n       //返回对象实例\n       //定义返回Bean\n       @Override\n       public Course getObject() throws Exception {\n           Course course = new Course();\n           course.setCname(\"abc\");\n           return course;\n       }\n       //返回类型\n       @Override\n       public Class<?> getObjectType() {\n           return null;\n       }\n       //它是否是个单例\n       @Override\n       public boolean isSingleton() {\n           return FactoryBean.super.isSingleton();\n       }\n   }\n   ```\n\n   ```java\n    @Test\n   public void testCollection3(){\n   ApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\");\n           Course course = context.getBean(\"myBean\", Course.class);\n           System.out.println(course);\n       }\n   ```\n\n   ```xml\n   <bean id=\"myBean\" class=\"com.test.spring5.factorybean.MyBean\"></bean>\n   ```\n\n九、IOC操作Bean管理(Bean作用域)\n\n1. 在Spring里面，设置创建Bean实例是单实例还是多实例\n\n\n2. 在Spring里面，默认情况下，bean是单实例对象\n\n\n   ```java\n   @Test\n       public void testCollection4(){\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\");\n           Book book1 = context.getBean(\"book\", Book.class);\n           Book book2 = context.getBean(\"book\", Book.class);\n        //单实例输出对象相同\n           System.out.println(book1);\n           System.out.println(book2);\n       }\n   ```\n\n3. 如何设置单实例还是多实例\n\n\n   1. 在Spring配置文件bean标签里面有属性(scope)用于设置单实例还是多实例\n\n   2. scope属性值\n\n      第一个值：默认值，singleton，表示是单实例对象\n\n      第二个值：prototype，表示是多实例对象\n\n      ```xml\n      <bean id=\"book\" class=\"com.test.spring5.collectiontype.Book\" scope=\"prototype\">\n           <property name=\"list\" ref=\"bookList\"></property>\n      </bean>\n      ```\n\n   3. singleton和prototype区别\n\n      > 1. singleton  单实例，prototype  多实例\n      > 2. 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象。设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象。\n\n\n##### 十、IOC操作Bean管理(bean生命周期)\n\n1. 生命周期\n\n   从对象的创建到对象销毁的过程\n\n2. bean的生命周期\n\n   1. 通过构造器创建bean实例(无参构造)\n   2. 为bean里面的属性设置值和对其他bean的引用(调用set方法)\n   3. 调用bean的初始化的方法(需要进行配置)\n   4. bean可以使用了(对象获取到了)\n   5. 当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)\n\n   ```java\n   public class Orders {\n       //无参构造\n       public Orders() {\n           System.out.println(\"第一步：执行无参数构造创建Bean实例\");\n       }\n       private String oname;\n       public void setOname(String oname) {\n           this.oname = oname;\n           System.out.println(\"第二步：调用set方法设置属性值\");\n       }\n       //创建执行的初始化的方法\n       public void initMethod(){\n           System.out.println(\"第三步：执行初始化的方法\");\n       }\n       //创建执行的销毁的方法\n       public void destroyMethod(){\n           System.out.println(\"第五步：执行销毁的方法\");\n       }\n   ```\n\n   ```xml\n   <bean id=\"orders\" class=\"com.test.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n           <property name=\"oname\" value=\"手机\"></property>\n       </bean>\n   ```\n\n   ```java\n    @Test\n       public void testBean(){\n           ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean5.xml\");\n           Orders orders = context.getBean(\"orders\", Orders.class);\n           System.out.println(\"第四步：获取到创建bean实例对象\");\n           System.out.println(orders);\n           //手动让bean实例销毁\n           context.close();\n       }\n   ```\n\n3. bean的后置处理器\n\n   1. 通过构造器创建bean实例(无参构造)\n\n   2. 为bean里面的属性设置值和对其他bean的引用(调用set方法)\n\n   3. 把bean实例传递bean后置处理器的方法      -----postProcessBeforeInitialization\n\n   4. 调用bean的初始化的方法(需要进行配置)\n\n   5. 把bean实例传递bean后置处理器的方法      -----postProcessAfterInitialization\n\n   6. bean可以使用了(对象获取到了)\n\n   7. 当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)\n\n      后置处理器  例：\n\n      1. 创建类，实现接口BeanPostProcessor，创建后置处理器\n\n      ```java\n      public class MyBeanPost implements BeanPostProcessor {\n          @Override\n          public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n              System.out.println(\"在初始化之前执行的方法-------后置处理器\");\n              return bean;\n          }\n          @Override\n          public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n              System.out.println(\"在初始化之后执行的方法------后置处理器\");\n              return bean;\n          }\n      }\n      ```\n\n      ```xml\n      <!--    配置后置处理器-->\n          <bean id=\"myBeanPost\" class=\"com.test.spring5.bean.MyBeanPost\"></bean>\n      ```\n\n\n##### 十一、IOC操作Bean管理(xml自动装配)\n\n​\t根据指定装配规则(属性名称或者属性类型)，spring自动将匹配的属性值进行注入\n\n 1. 根据属性的名称自动注入\n\n    ```xml\n    <!--    实现自动装配-->\n    <!--    bean标签中有个属性autowire，配置自动装配-->\n    <!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入-->\n        <bean id=\"emp\" class=\"com.test.spring5.autowire.Emp\" autowire=\"byName\">\n        </bean>\n        <bean id=\"dept\" class=\"com.test.spring5.autowire.Dept\"></bean>\n    ```\n\n 2. 根据属性的类型自动注入(相同类型的属性不能定义多个)\n\n    ```xml\n    <!--    实现自动装配-->\n    <!--    bean标签中有个属性autowire，配置自动装配-->\n    <!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入-->\n        <bean id=\"emp\" class=\"com.test.spring5.autowire.Emp\" autowire=\"byType\">\n        </bean>\n        <bean id=\"dept\" class=\"com.test.spring5.autowire.Dept\"></bean>\n    ```\n\n##### 十二、IOC操作Bean管理(引入外部属性文件)\n\n1. 直接配置数据库信息\n\n   1. 配置德鲁伊连接池\n   2. 引入德鲁伊连接池依赖jar包\n\n   ```xml\n   <!--    配置连接池-->\n       <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n           <property name=\"url\" value=\"jdbc:mysql://localhost:3306/userDb\"></property>\n           <property name=\"username\" value=\"root\"></property>\n           <property name=\"password\" value=\"root\"></property>\n       </bean>\n   ```\n\n2. 引入外部属性文件配置数据库连接池\n\n   1. 创建外部属性文件，properties格式文件，写数据库信息\n\n      ```properties\n      prop.driverClassName=com.mysql.jdbc.Driver\n      prop.url=jdbc:mysql://localhost:3306/userDb\n      prop.username=root\n      prop.password=root\n      ```\n\n   2. 把外部properties属性文件引入spring配置文件中\n\n      1. 引入context名称空间\n\n         ```xml\n         <beans xmlns=\"http://www.springframework.org/schema/beans\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xmlns:context=\"http://www.springframework.org/schema/context\"\n                xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n         \">\n         ```\n\n      2. 在spring配置引入外部文件\n\n         ```xml\n         <!--    引入外部的属性文件-->\n             <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n             <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n                 <property name=\"driverClassName\" value=\"${prop.driverClassName}\"></property>\n                 <property name=\"url\" value=\"${prop.url}\"></property>\n                 <property name=\"username\" value=\"${prop.username}\"></property>\n                 <property name=\"password\" value=\"${prop.password}\"></property>\n             </bean>\n         ```\n\n##### 十三、IOC操作Bean管理(基于注解方式)\n\n1. 什么是注解\n\n   注解是代码特殊标记，格式：@注解名称(属性名称=属性值，属性名称=属性值...)\n\n   使用注解，注解可以作用在类上面，方法上面，属性上面\n\n   使用注解的目的：简化xml配置\n\n2. Spring针对Bean管理(创建对象)中创建对象提供注解\n\n   1. @Component\n   2. @Service\n   3. @Controller\n   4. @Repository\n\n   上面的四个注解功能是一样的，都是用来创建Bean的实例\n\n3. 基于注解方式实现对象创建\n\n   1. 第一步引入依赖\n   2. 开启组件扫描\n\n   ```xml\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:context=\"http://www.springframework.org/schema/context\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n   \">\n   <!--    开启组件扫描\n       1.扫描多个包，多个包之间使用逗号隔开\n       2.扫描包上层目录\n   -->\n       <context:component-scan base-package=\"com.test.spring5\"></context:component-scan>\n   ```\n   \n   3. 创建类，在类上面添加创建对象得注解\n   \n   ```java\n      //注解里面value属性值可以省略\n      //默认值是类名称，首字母小写\n      @Service(value = \"userService\")//类似 <bean id=\"userService\" class=\"...\"></bean>\n      public class UserService {\n          public void add(){\n              System.out.println(\"service add.....\");\n          }\n      }\n   ```\n   \n   4. 开启组件扫描细节配置\n   \n   ```xml\n      <!--    示例1\n          use-default-filters=\"false\"   表示现在不使用默认的filters，自己配置filter\n          context:include-filter        扫描那些内容\n      -->\n          <context:component-scan base-package=\"com.test.spring5\" \n                                  use-default-filters=\"false\">\n              <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n          </context:component-scan>\n   ```\n   \n   ```xml\n   <!--    示例2\n       context:exclude-filter     设置那些内容不进行扫描\n   -->\n       <context:component-scan base-package=\"com.test.spring5\" >\n           <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n       </context:component-scan>\n   ```\n\n##### 十四、IOC操作Bean管理(基于注解属性注入)\n\n1. **@Autowired**：根据属性类型进行自动装配\n\n   例：\n\n   第一步 吧service和dao对象创建，在service和dao类添加创建对象注解\n\n   第二步 在service注入dao对象，在service类添加dao类属性，在属性上面使用注解\n\n   ```java\n   @Service\n   public class UserService {\n       //定义dao类型属性\n       //不需要添加set方法\n       //添加注入属性的注解\n       @Autowired\n       private UserDao userDao;\n       public void add(){\n           System.out.println(\"service add.....\");\n       }\n   }\n   ```\n\n   \n\n2. **@Qualifier**：根据属性名称进行注入\n\n   @Qualifier需要配合@Autowired注解进行使用\n\n   ```java\n   @Repository(value = \"userDapImpl1\")\n   public class UserDaoImpl implements UserDao{\n       @Override\n       public void add() {\n           System.out.println(\"dao  add......\");\n       }\n   }\n   ```\n\n   ```java\n    @Autowired  //根据类型进行注入\n       @Qualifier(value = \"userDapImpl1\")\n       private UserDao userDao;\n       public void add(){\n           System.out.println(\"service add.....\");\n           userDao.add();\n       }\n   ```\n\n3. **@Resource**：可以根据类型注入，也可以根据名称注入\n\n   ```java\n    import javax.annotation.Resource;\n   \n    @Resource( name = \"userDapImpl1\")  //根据名称进行注入\n    @Resource   //根据类型注入 \n   ```\n\n4. **@Value**：注入普通类型属性\n\n   ```java\n   @Value(value = \"Tom\")  //普通类型属性注入\n       private String name;\n       public void add(){\n           System.out.println(\"service add.....\");\n           System.out.println(\"service-name-\"+name);\n           userDao.add();\n       }\n   ```\n\n5. 纯注解开发\n\n   1. 创建配置类，替代xml配置\n\n      ```java\n      @Configuration   //作为配置类，替代xml配置文件\n      @ComponentScan(basePackages = {\"com.test.spring5\"}) //开启\n      public class SpringConfig {\n      }\n      ```\n\n   2. 编写测试类\n\n      ```java\n      @Test\n          public void testService2(){\n              //加载配置类\n              ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);\n              UserService userService = context.getBean(\"userService\", UserService.class);\n              System.out.println(userService);\n              userService.add();\n          }\n      ```\n\n## 三、AOP\n\n#### 一、什么是AOP(概念)\n\n​\tAOP为Aspect Oriented Programming 面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率\n\n​\t`不通过修改源代码的方式添加新功能`\n\n​\t通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n\n#### 二、AOP底层原理\n\n1. AOP底层使用动态代理\n   1. 第一种有接口的情况(JDK动态代理)\n   2. 第二种没有接口的情况(CGLib动态代理)\n\n##### 2.1、AOP底层原理(JDK动态代理)\n\n1. 使用JDK动态代理，使用Proxy类里面的方法创建代理对象\n\n   java.lang.reflect.Proxy\n\n   主要方法：\n\n   | 修饰符和类型  | 方法与描述                                                   |\n   | ------------- | ------------------------------------------------------------ |\n   | static Object | newProxyInstance（）返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。 |\n\n   里面有三个参数\n   \n   | 参数名                | 说明                                       |\n   | --------------------- | ------------------------------------------ |\n   | ClassLoader loader    | 类加载器                                   |\n   | Class<?>[] interfaces | 增强方法所在类，这个类的接口，支持多个接口 |\n   | InvocationHandler h   | 实现这个接口，创建代理对象，写增强的方法   |\n   \n2. 编写JDK动态代理代码\n\n   1. 创建接口，定义方法\n\n      ```java\n      public interface UserDao {\n          public int add(int a, int b);\n          public String update(String id);\n      }\n      ```\n\n   2. 创建接口实现类，实现方法\n\n      ```java\n      public class UserDaoImpl implements UserDao{\n          @Override\n          public int add(int a, int b) {\n              return a+b;\n          }\n          @Override\n          public String update(String id) {\n              return id;\n          }\n      }\n      ```\n\n   3. 使用Proxy类创建接口代理对象(增强)\n\n      ```java\n      public class JDKProxy {\n          public static void main(String[] args) {\n              //创建接口实现类代理对象\n              Class[] interfaces = {UserDao.class};\n      //        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() {\n      //            @Override\n      //            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      //                return null;\n      //            }\n      //        });\n              UserDaoImpl userDao = new UserDaoImpl();\n              UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n              int result = dao.add(1, 2);\n              System.out.println(\"result:\"+result);\n          }\n      }\n      //创建代理对象代码\n      class UserDaoProxy implements InvocationHandler{\n          //1 把创建的是谁的代理对象，把谁传递过来\n          //有参数的构造传递\n          private Object obj;\n          public UserDaoProxy(Object obj) {\n              this.obj = obj;\n          }\n          //对象被创建就会调用invoke方法\n          @Override\n          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n              //增强的逻辑\n              //方法之前\n              System.out.println(\"方法执行之前......\"+method.getName()+\"  :传递的参数...\"+ Arrays.toString(args));\n              //被增强的方法执行\n              Object res = method.invoke(obj, args);\n              //方法之后\n              System.out.println(\"方法执行之后......\"+ obj);\n              return res;\n          }\n      }\n      ```\n\n#### 三、AOP(术语)\n\n​\t术语就是例如，汽车发动机又叫引擎\n\n1. 连接点\n\n   > 类里面那些方法可以被增强，这些方法称为连接点\n\n2. 切入点\n\n   > 实际被真正增强的方法，称为切入点\n\n3. 通知(增强)\n\n   > 1. 实际增强的逻辑部分称为通知(增强)\n   > 2. 通知有多种类型\n   >    1. 前置通知：被增强的原始方法之前执行的逻辑\n   >    2. 后置通知：被增强的原始方法之后执行的逻辑\n   >    3. 环绕通知：被增强的原始方法之前后执行的逻辑\n   >    4. 异常通知：被增强的原始方法出现异常后执行的逻辑\n   >    5. 最终通知：如同try~catch后面的finally类似\n\n   ```java\n     //前置通知\n       //Before 注解表示作为前置通知\n       @Before(value = \"execution()\")\n       //后置通知(返回值通知)\n       @AfterReturning(value = \"execution()\")\n       //环绕通知\n       @Around(value = \"execution()\")\n       //异常通知\n       @AfterThrowing(value = \"execution()\")\n       //最终通知\n       @After(value = \"execution()\")  \n   ```\n\n4. 切面\n\n   > 把通知应用到切入点过程，是一个动作\n\n#### 四、AOP操作\n\n##### 4.1 准备工作\n\n1. Spring框架中一般都是基于AspectJ实现AOP操作\n\n   1. 什么是AspectJ\n\n      > AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作\n\n2. 基于`AspectJ`实现AOP操作\n\n   1. 基于xml配置文件\n   2. 基于注解方式使用(常用)\n\n3. 在项目工程里面引入AOP相关依赖\n\n   > spring-aspects-5.2.6.RELEASE.jar\n   > spring-aop-5.2.6.RELEASE.jar\n   > com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar\n   > com.springsource.org.aopalliance-1.0.0.jar\n   > com.springsource.net.sf.cglib-2.2.0.jar\n\n4. 切入点表达式\n\n   > 1. 切入点表达式作用：知道对那个类里面的那个方法进行增强\n   >\n   > 2. 语法结构：\n   >\n   >    excution([权限修饰符]\\[返回类型]\\[类的全路径]\\[方法名称]([参数列表]))\n   >    \n   >    举例1：对com.test.dao.BoolDao类里面的add进行增强\n   >    \n   >    `xcution(* com.test.dao.BoolDao.add(..));`\n   >    \n   >    举例2：对com.test.dao.BoolDao类里面的所有方法增强\n   >    \n   >    `excution(* com.test.dao.BoolDao.*(..));`\n   >    \n   >    举例3：对com.test.dao.BoolDao类里面的所有类和所有类中的所有方法增强\n   >    \n   >    `excution(* com.test.dao.\\*.*(..));`\n\n##### 4.2 AOP操作(AspectJ注解)\n\n1. 创建类，在类里面定义方法，被增强类\n\n   ```java\n   //被增强的类\n   public class User {\n       public void add(){\n           System.out.println(\"User add......\");\n       }\n   }\n   ```\n\n2. 创建增强类(编写增加的逻辑)\n\n   在增强的类里面，创建不同的方法，让不同的方法代表不同的通知类型\n\n   ```java\n   //增强的类\n   public class UserProxy {\n       //前置通知\n       public void before(){\n           System.out.println(\"before......   前置通知\");\n       }\n   }\n   ```\n\n3. 进行通知的配置\n\n   1. 在spring配置文件中，开启注解扫描\n\n      ```xml\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <beans xmlns=\"http://www.springframework.org/schema/beans\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xmlns:context=\"http://www.springframework.org/schema/context\"\n             xmlns:aop=\"http://www.springframework.org/schema/aop\"\n             xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                                 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                                 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n      \">\n      <!--    开启注解扫描-->\n          <context:component-scan base-package=\"com.test.spring5.aopanno\"></context:component-scan>\n      </beans>\n      ```\n\n   2. 使用注解创建User和UserProxy对象\n\n      ```java\n      @Component\n      public class User {\n          public void add(){\n              System.out.println(\"User add......\");\n          }\n      }\n      ```\n\n      ```java\n      @Component\n      public class UserProxy {\n          //前置通知\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      }\n      ```\n\n      \n\n   3. 在增强类上面添加注解@Aspect\n\n      ```java\n      @Component\n      @Aspect  //生成代理对象\n      public class UserProxy {\n          //前置通知\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      }\n      ```\n\n   4. 在Spring配置文件中开启生成代理对象\n\n      ```xml\n      <!--    开启Aspect生成代理对象-->\n          <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n      ```\n\n   5. 配置不同类型的通知\n\n      在我增强类的里面，作为通知方法上面添加通知类型注解，使用切入点表达式配置\n\n      ```java\n      //增强的类\n      @Component\n      @Aspect  //生成代理对象\n      public class UserProxy {\n          //前置通知\n          //Before 注解表示作为前置通知\n          @Before(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      \n          //后置通知(返回值通知)\n          @AfterReturning(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void afterReturning(){\n              System.out.println(\"AfterReturning......   后置通知\");\n          }\n      \n          //环绕通知\n          @Around(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n              System.out.println(\"环绕之前......\");\n              //被增强的方法执行\n              proceedingJoinPoint.proceed();\n              System.out.println(\"环绕之后......\");\n          }\n      \n          //异常通知\n          @AfterThrowing(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void afterThrowing(){\n              System.out.println(\"AfterThrowing......   前置通知\");\n          }\n      \n          //最终通知\n          @After(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void after(){\n              System.out.println(\"After......  最终通知\");\n          }\n      }\n      ```\n\n   6. 相同切入点进行抽取\n\n      ```java\n       //相同切入点抽取\n          @Pointcut(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void pointDemo(){\n          }\n          //前置通知\n          //Before 注解表示作为前置通知\n          @Before(value = \"pointDemo()\")\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      ```\n\n   7. 有多个增强类对同一个方法增强，设置增强类优先级\n\n      在增强类上面添加注解@Order(值)，数字类型的值，数值越小优先级越高\n\n      ```java\n      @Component\n      @Aspect\n      @Order(1)  //优先级\n      public class PersonProxy {\n      ```\n      \n   8. 完全使用注解开发\n   \n      ```java\n      //配置类不需要创建xml配置文件\n      @Configuration\n      @ComponentScan(basePackages = {\"com.test.spring5\"})\n      @EnableAspectJAutoProxy(proxyTargetClass = true)\n      public class ConfigAop {\n      }\n      ```\n   \n\n##### 4.3 AOP操作(AspectJ配置文件)\n\n1. 创建两个类，增强类和被增强类，创建方法\n\n   ```java\n   public class Book {\n       public void buy(){\n           System.out.println(\"buy......\");\n       }\n   }\n   ```\n\n   ```java\n   public class BookProxy {\n       public void before(){\n           System.out.println(\"before......\");\n       }\n   }\n   ```\n\n2. 在spring配置文件中创建两个类对象\n\n   ```xml\n   <!--    创建两个类的对象-->\n       <bean id=\"book\" class=\"com.test.spring5.aopxml.Book\"></bean>\n       <bean id=\"bookProxy\" class=\"com.test.spring5.aopxml.BookProxy\"></bean>\n   ```\n\n3. 在spring配置文件中配置切入点\n\n   ```java\n   <!--    创建两个类的对象-->\n       <bean id=\"book\" class=\"com.test.spring5.aopxml.Book\"></bean>\n       <bean id=\"bookProxy\" class=\"com.test.spring5.aopxml.BookProxy\"></bean>\n   <!--    配置AOP增强-->\n       <aop:config>\n   <!--        切入点-->\n           <aop:pointcut id=\"p\" expression=\"execution(* com.test.spring5.aopxml.Book.buy(..))\"/>\n   <!--        配置切面-->\n           <aop:aspect ref=\"bookProxy\">\n   <!--            增强作用在具体的方法上-->\n               <aop:before method=\"before\" pointcut-ref=\"p\"/>\n           </aop:aspect>\n       </aop:config>\n   ```\n\n\n## 四、JDBC Templatek\n\n#### 一、概念和准备\n\n1. 什么是JDBCTemplatek\n\n   Spring框架对JDBC进行封装，使用JDBCTemplatek方便实现对数据库操作\n\n2. 准备工作\n\n   1. 引入相关的依赖\n\n      > spring-tx-5.2.6.RELEASE.jar\n      > spring-orm-5.2.6.RELEASE.jar\n      > spring-jdbc-5.2.6.RELEASE.jar\n      > druid-1.1.9.jar\n      > mysql-connector-java-8.0.28.jar\n\n   2. 在spring配置文件配置数据库连接池\n\n      ```xml\n      <!--    数据库连接池-->\n          <bean id=\"database\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\">\n              <property name=\"url\" value=\"jdbc:mysql:///user_db\"/>\n              <property name=\"username\" value=\"root\"/>\n              <property name=\"password\" value=\"root\"/>\n              <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n          </bean>\n      ```\n\n   3. 配置JDBCTemplate对象,注入DataSource\n\n      ```xml\n      <!--    创建JDBCTemplate对象-->\n          <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n      <!--        注入dataSource-->\n              <property name=\"dataSource\" ref=\"database\"/>\n          </bean>\n      ```\n\n   4. 创建Service类，创建dao类，在dao注入jdbcTemlate对象\n   \n      ```xml\n      <!--    开启组件扫描-->\n          <context:component-scan base-package=\"com.test.spring5\"></context:component-scan>\n      ```\n   \n      ```java\n      @Service\n      public class BookService {\n          //注入dao\n          @Autowired\n          private BookDao bookDao;\n      }\n      ```\n   \n      ```java\n      @Repository\n      public class BookDaoImpl implements BookDao{\n          //注入jdbcTemplate\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n      }\n      ```\n\n#### 二、JDBCTemplate操作数据库\n\n##### 一、添加\n\n1. 对应数据库创建实体类\n\n   ```java\n   public class User {\n       private String userId;\n       private String username;\n       private String ustatus;\n       public String getUserId() {\n           return userId;\n       }\n       public void setUserId(String userId) {\n           this.userId = userId;\n       }\n   ```\n\n2. 编写service和dao\n\n   1. 在dao层进行数据库添加操作\n\n   2. 调用jdbctemplate对象里面的update方法实现添加操作\n\n      | 参数            | 说明                    |\n      | --------------- | ----------------------- |\n      | String  SQL     | sql语句                 |\n      | Object...  args | 可变参数，设置sql语句值 |\n\n      ```java\n      @Repository\n      public class BookDaoImpl implements BookDao{\n          //注入jdbcTemplate\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n          //添加的方法\n          public void add(Book book){\n              //创建sql语句\n              String sql = \"insert into t_book values(?,?,?)\";\n              //调用方法实现\n      //        int rows = jdbcTemplate.update(sql, book.getUserId(), book.getUsername(), book.getUstatus());\n              Object[] args = { book.getUserId(), book.getUsername(), book.getUstatus()};\n              int rows = jdbcTemplate.update(sql,args);\n              System.out.println(rows);\n          }\n      }\n      ```\n\n3. 测试类\n\n   ```java\n   public class TestBook {\n       @Test\n       public void testJDBCTemplate(){\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\");\n           BookService bookService = context.getBean(\"bookService\", BookService.class);\n           Book book = new Book();\n           book.setUserId(\"1\");\n           book.setUsername(\"红露面\");\n           book.setUstatus(\"a\");\n           bookService.addBook(book);\n       }\n   }\n   ```\n\n##### 二、修改\n\n1. BookService添加修改方法\n\n   ```java\n   //修改的方法\n       @Override\n       public void updateBook(Book book) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n           int update = jdbcTemplate.update(sql, args);\n           System.out.println(\"修改了\"+update+\"记录\");\n       }\n   ```\n\n2. 实现修改方法\n\n   ```java\n   //修改的方法\n       @Override\n       public void updateBook(Book book) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n           int update = jdbcTemplate.update(sql, args);\n           System.out.println(\"修改了\"+update+\"记录\");\n       }\n   ```\n\n3. 测试\n\n   ```java\n   Book book = new Book();\n           book.setUserId(\"1\");\n           book.setUsername(\"许仙\");\n           book.setUstatus(\"AAAA\");\n           bookService.updateBook(book);\n   ```\n\n##### 三、删除\n\n```java\n//修改的方法\n    @Override\n    public void updateBook(Book book) {\n        String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n        Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n        int update = jdbcTemplate.update(sql, args);\n        System.out.println(\"修改了\"+update+\"记录\");\n    }\n```\n\n测试\n\n```java\nBook book = new Book();\n        bookService.deleteBook(\"1\");\n```\n\n##### 四、查询\n\n1. **查询返回某个值**\n\n   1. 查询表里面有多少条记录，返回某个值\n\n   2. 使用jdbcTemplate实现返回某个值代码\n\n      queryForObject\n\n      | 参数                  | 说明          |\n      | --------------------- | ------------- |\n      | String  SQL           | sql语句       |\n      | Class<T> requiredType | 返回类型Class |\n\n      ```java\n      @Override\n          public int selectCount() {\n              String sql = \"select count(*) from t_book\";\n              Integer count = jdbcTemplate.queryForObject(sql, Integer.class);\n              return count;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n       //查询\n              int count = bookService.findCount();\n              System.out.println(count);\n      ```\n\n2. **查询返回对象**\n\n   1. 场景：查询图书的详情页面\n\n   2. JDBCTemplate实现查询返回对象\n\n      | 参数                   | 说明                                                         |\n      | ---------------------- | ------------------------------------------------------------ |\n      | String SQL             | sql语句                                                      |\n      | RowMapper<T> rowMapper | rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装 |\n      | object... args         | sql语句值                                                    |\n\n      ```java\n      @Override\n          public Book findBookInfo(String id) {\n              String sql = \"select * from t_book where user_id=?\";\n              //调用方法\n              Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n              return book;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n      //查询返回对象\n              Book one = bookService.findOne(\"1\");\n              System.out.println(one);\n      ```\n\n3. **查询返回集合**\n\n   1. 场景：查询图书列表分页...\n\n   2. 调用jdbcTemplate方法实现查询返回集合\n\n      query()\n\n      | 参数                   | 说明                                                         |\n      | ---------------------- | ------------------------------------------------------------ |\n      | String SQL             | sql语句                                                      |\n      | RowMapper<T> rowMapper | rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装 |\n      | object... args         | sql语句值                                                    |\n\n      ```java\n      //查询返回集合\n          @Override\n          public List<Book> findALlBook() {\n              String sql = \"select * from t_book\";\n              List<Book> bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));\n              return bookList;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n      //查询返回集合\n              List<Book> all = bookService.findAll();\n              System.out.println(all);\n      ```\n\n##### 五、批量操作\n\n1. 批量操作：操作表里面多条记录\n\n2. jdbcTemplate实现批量添加的操作\n\n   batchUpdate(String sql,List<Object[]> barchArgs)\n\n   | 参数                     | 说明                       |\n   | ------------------------ | -------------------------- |\n   | String SQL               | sql语句                    |\n   | List<object[]> barchArgs | list集合添加的多条记录数据 |\n   \n   ```java\n    //批量添加\n       @Override\n       public void batchAddBook(List<Object[]> bachArgs) {\n           String sql = \"insert into t_book values(?,?,?)\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(Arrays.toString(ints));\n       }\n   ```\n   \n3. 测试\n\n   ```java\n   //批量添加\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"4\",\"张三\",\"qwe\"};\n           Object[] o2 = {\"5\",\"李四\",\"qwerty\"};\n           Object[] o3 = {\"6\",\"王五\",\"ewq\"};\n           list.add(o1);\n           list.add(o2);\n           list.add(o3);\n           bookService.batchAdd(list);\n   ```\n\n4. jdbcTemplate实现批量修改的操作\n\n   ```java\n    @Override\n       public void batchUpdateBook(List<Object[]> bachArgs) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(Arrays.toString(ints));\n       }\n   ```\n\n5. 测试\n\n   ```java\n   //批量修改\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"红楼梦\",\"aaa\",\"1\"};\n           Object[] o2 = {\"西游记\",\"bbb\",\"2\"};\n           Object[] o3 = {\"水浒传\",\"ccc\",\"3\"};\n           list.add(o1);\n           list.add(o2);\n           list.add(o3);\n           bookService.batchUpdate(list);\n   ```\n\n6. 批量删除\n\n   ```Java\n    //批量删除\n       @Override\n       public void batchDeleteBook(List<Object[]> bachArgs) {\n           String sql = \"delete from t_book where user_id=?\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(ints);\n       }\n   ```\n\n7. 测试\n\n   ```java\n   //批量删除\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"4\"};\n           Object[] o2 = {\"5\"};\n           list.add(o1);\n           list.add(o2);\n           bookService.batchUpdate(list);\n   ```\n\n## 五、事务管理\n\n#### 一、概念\n\n1. 事务是数据库操作的最基本单元，逻辑上一组操作，要么都成功，要么失败一个其他所有操作都是失败\n2. 典型场景：银行转账\n3. 事务四个特性(ACID)\n   1. 原子性\n   2. 一致性\n   3. 隔离性\n   4. 持久性\n\n#### 二、事务操作\n\n##### 1.搭建事务操作环境\n\n   1. 创建数据库表，添加记录\n\n   2. 创建service，创建dao，完成对象创建和注入关系\n\n      service注入dao，在dao注入jdbcTemplate，在jdbcTemplate注入DataSource\n\n      ```java\n      @Service\n      public class UserService {\n          //注入dao\n          @Autowired\n          private UserDao userDao;\n      }\n      ```\n\n      ```java\n      @Repository\n      public class UserDaoImpl implements UserDao {\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n      }\n      ```\n\n   3. 在dao创建两个方法：多钱和少钱方法，在service创建方法(转账的方法)\n\n      ```java\n      @Override\n          public void addMoney() {\n              String sql = \"update t_account set money=money+? where username=?\";\n              jdbcTemplate.update(sql, 100, \"李四\");\n          }\n          @Override\n          public void reduceMoney() {\n              String sql = \"update t_account set money=money-? where username=?\";\n              jdbcTemplate.update(sql, 100, \"张三\");\n          }\n      ```\n\n      ```java\n      //转账方法\n          public void accountMoney() {\n              userDao.reduceMoney();\n              userDao.addMoney();\n          }\n      ```\n\n   4. 上面代码，正常执行没有问题，但是代码如果产生异常，会有问题\n\n      问题：张三扣除100块，而李四并没有收到100块\n\n      以上问题问题解决方案，使用事务进行解决，要么一起成功要么一起失败\n\n      > 事务的操作过程：\n      >\n      > 1. 开启事务\n      > 2. 进行业务操作(try~catch捕获并处理异常)\n      > 3. 没有异常，提交事务\n      > 4. 出现了异常，事务回滚\n\n##### 2.事务操作(spring事务管理介绍)\n\n   1. 事务添加到JavaEE三层结构里面Service层(业务逻辑层)\n\n   2. 在Spring进行事务管理操作\n\n      > 有两种方式：编程式事务管理和声明式事务管理(使用)\n\n   3. 声明式事务管理\n\n      1. 基于注解方式\n      2. 基于xml配置文件方式\n\n   4. 在Spring进行声明式事务管理，底层使用AOP原理\n\n   5. Spring事务管理API\n\n      1. 提供了一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类\n\n         `PlatformTransactionManager`\n\n##### 3.事务操作(注解声明式事务管理)\n\n   1. 在Spring配置文件配置事务管理器\n\n      ```xml\n      <!--    创建事务管理器-->\n          <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <!--        注入数据源-->\n              <property name=\"dataSource\" ref=\"database\"></property>\n          </bean>\n      ```\n\n   2. 在Spring配置文件,开启事务注解\n\n      在spring配置文件引入名称空间tx\n\n      ```xml\n      <!--    开启事务注解-->\n          <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n      ```\n\n   3. 在service类上面添加事务注解\n\n      @Transactional,这个注解添加到类上面,也可以添加到方法上面\n\n      添加在类上,表示这个类中所有方法都添加了事务\n\n      添加到方法上,只为该方法提供事务\n\n      ```java\n      @Service\n      @Transactional\n      public class UserService {\n      ```\n\n##### 4.事务操作(声明式事务管理参数)\n\n   | 参数名                    | 说明           |\n   | ------------------------- | -------------- |\n   | Propagation propagation() | 事务的传播行为 |\n   | Isolation isolation()     | 事务的隔离级别 |\n   | int timeout()             | 事务的超时时间 |\n   | boolearn readOnly         | 是否只读       |\n   | rollbackFor               | 回滚           |\n   | noRollbackFor             | 不回滚         |\n\n   **`propagation()`**:事务的传播行为\n\n   | 参数          | 说明                                                         |\n   | ------------- | ------------------------------------------------------------ |\n   | MANDATORY     | 支持当前事务，如果不存在则引发异常。                         |\n   | NESTED        | 如果当前事务存在，则在嵌套事务内执行，否则行为类似于 `REQUIRED` |\n   | NEVER         | 以非事务方式执行，如果存在事务则引发异常。                   |\n   | NOT_SUPPORTED | 以非事务方式执行，如果存在当前事务，则挂起当前事务。         |\n   | REQUIRED      | 支持当前事务，如果不存在则创建新事务。                       |\n   | REQUIRES_NEW  | 创建一个新事务，如果当前事务存在，则挂起当前事务。           |\n   | SUPPORTS      | 支持当前事务，如果不存在，则以非事务方式执行。               |\n\n   **`isolation`**:事务的隔离级别\n\n   | 参数             | 说明                                                      |\n   | ---------------- | --------------------------------------------------------- |\n   | DEFAULT          | 使用基础数据存储区的默认隔离级别。                        |\n   | READ_COMMITTED   | 一个常量，指示阻止脏读;可能发生不可重复的读取和幻像读取。 |\n   | READ_UNCOMMITTED | 一个常量，指示可能发生脏读、不可重复读和幻像读。          |\n   | REPEATABLF_READ  | 一个常量，指示阻止脏读取和不可重复读取;可能发生幻象读取   |\n   | SERIALZABLE      | 一个常量，指示阻止脏读、不可重复读和幻像读。              |\n\n##### 5.事务操作(xml声明式事务管理)\n\n   1. 在spring配置文件中进行配置\n\n      第一步：配置事务管理器\n\n      第二步：配置通知\n\n      第三步：配置切入点和切面\n\n      ```xml\n       <!--    创建事务管理器-->\n          <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <!--        注入数据源-->\n              <property name=\"dataSource\" ref=\"database\"></property>\n          </bean>\n          <!--    配置通知-->\n          <tx:advice id=\"txadvice\">\n              <!--        配置事务参数-->\n              <tx:attributes>\n                  <!--            指定那种规则的方法上面添加事务-->\n                  <tx:method name=\"accountMoney\" propagation=\"REQUIRED\"/>\n                  <!--            <tx:method name=\"account*\"/>-->\n              </tx:attributes>\n          </tx:advice>\n          <!--    配置切入点和切面-->\n          <aop:config>\n              <!--        配置切入点-->\n              <aop:pointcut id=\"pt\" expression=\"execution(* com.test.spring5.service.UserService.*(..))\"/>\n              <!--        配置切面-->\n              <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pt\"/>\n          </aop:config>\n      ```\n\n\n\n\n\n\n\n","source":"_posts/Spring.md","raw":"---\ntitle: Spring框架\ndate: 2023-03-12 11:18:57\ntags: 框架\ncategories: 框架\ncover: /img/images/Spring.jpg\n---\n\n\n## 一、spring框架概述\n\n1. Spring是轻量级的开源的JavaEE框架\n2. Spring可以解决企业应用开发的复杂性\n3. Spring有两个核心部分：IOC和AOP\n   1. IOC：控制反转，把创建对象过程交给Spring进行管理\n   2. AOP：面向切面，不修改源代码进行功能增强\n4. Spring特点\n   1. 方便解耦，简化开发\n   2. AOP编程支持\n   3. 方便程序测试\n   4. 方便和其他框架进行整合\n   5. 方便进行事务操作\n   6. 降低API开发难度\n\n## 二、IOC\n\n### IOC(概念和原理)\n\n##### 一、什么是IOC\n\n1. 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理\n2. 使用IOC的目的：为了降低程序的耦合度\n3. Spring容器在初始化时先读取配置文件，根据配置文件或元数据，创建并组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n\n##### 二、IOC底层原理\n\n1. XML解析、工厂模式、反射\n\n2. 原始方式创建\n\n   ```java\n   class UserService{\n   \texecute(){\n   \t\tUserDao dao = new UserDao();\n   \t\tdao.add();\n   \t}\n   }\n   class UserDao{\n       add(){\n           ......\n       }\n   }\n   ```\n\n3. 工厂模式\n\n   ```java\n   class UserService{\n       execute(){\n           UserDao dao = UserFactory.getDao();\n           dao.add();\n       }\n   }\n   class UserDao{\n       add(){\n           ......\n       }\n   }\n   class UserFactory{\n       public static UserDao getDao(){\n           return new UserDao();\n       }\n   }\n   ```\n\n4. IOC解耦过程\n\n   > 第一步：xml配置文件，配置创建的对象\n   >\n   > <bean id=\"dao\" class=\"com.test.xxx.UserDao\"></bean>\n   >\n   > 第二步：有service类和到dao类，创建工厂类\n   >\n   > ```java\n   > class UserFactory{\n   >     public static UserDao getDao(){\n   >         String classValue = class属性值；//1. xml解析\n   >         Class clazz = Class.forName(classValue);//2.通过反射创建对象\n   >         return （UserDao)clazz.newInstance() \n   >     }\n   > }\n   > ```\n\n##### 三、IOC接口(BeanFactory)\n\n1. IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n\n2. Spring提供IOC容器实现两种方式:\n\n   1. BeanFactory:IOC容器基本实现，是Spring内部的使用接口，不提供开发人员使用\n\n      > 加载配置获取文件的时候不会创建对象，在获取/使用对象的时候才去创建对象\n      >\n      > 什么时候用什么时候创建对象\n\n   2. ApplicationContext：BeanFactory接口的子接口，提供更强大的功能，一般由开发人员进行使用\n\n      > 加载配置文件的时候就会把配置文件中的对象进行创建\n\n   3. ApplicationContext的实现类\n\n      FileSystemXmlApplicationContext:磁盘下配置文件路径\n\n      ClassPathXmlApplicationContext：类路径下的配置文件\n\n##### 四、IOC操作Bean管理\n\n1. **什么是Bean管理**\n   1. Bean管理\n   2. Spring创建对象\n   3. Spring注入属性\n2. **Bean管理操作有两种方式**\n   1. IOC操作Bean管理(基于xml)\n   2. IOC操作Bean管理(基于注解)\n\n##### 五、IOC操作Bean管理(基于xml)\n\n1. **基于xml方式创建对象**\n\n   > 1. 在spring配置文件中使用bean标签，标签里面添加对应的属性，就可以实现对象创建\n   >\n   >    <bean id=\"user\" class=\"com.xxx.xxx.User\"></bean>\n   >\n   > 2. 在bean标签有很多属性，介绍常用的属性：\n   >\n   >    1. id属性：创建对象的唯一标识\n   >    2. class属性：类全路径(包类路径) \n   >\n   > 3. 创建对象时候，默认也是执行无参构造方法完成对象创建\n\n2. **基于xml方式注入属性**\n\n   1. DI：依赖注入，就是注入属性\n\n3. **第一种注入方式：使用set方法进行注入**\n\n   1. 创建类，定义属性和对应的set方法\n\n      ```java\n      class Book{\n          private String bName;\n          public void setBName(String bName){\n              this.bName = bName;\n          }\n      }\n      ```\n\n   2. 在spring配置文件配置对象创建，配置属性注入\n\n      > set方法注入属性\n      >\n      > <bean id=\"book\" class=\"com.xxx.xxx.Book\">\n      >\n      > ​\tname: 类里面的属性名称\n      >\n      > ​\tvalue：向属性注入的值\n      >\n      > ​\t<property name=\"bName\" value=\"红楼梦\"></property>\n      >\n      > </bean>\n\n4. **第二种注入方式：使用有参数构造进行注入**\n\n   1. 创建类，定义属性，创建属性对应有参数的构造方法\n\n      ```java\n      public class Orders {\n          //属性\n          private String oName;\n          private String address;\n          //有参数构造\n          public Orders(String oName, String address) {\n              this.oName = oName;\n              this.address = address;\n          }\n      }\n      ```\n\n   2. 在Spring配置文件中进行配置\n\n      > 有参数构造注入属性\n      >\n      > <bean id=\"orders\" class=\"com.xxx.xxx.Orders\">\n      >\n      >  \t<constructor-arg name=\"oname\" value=\"电脑\"></constructor-arg>\n      >\n      > ​\t <constructor-arg name=\"address\" value=\"China\"></constructor-arg>\n      >\n      > </bean>\n\n5. **p名称空间注入(简化xml配置)**\n\n   底层还是采用set注入，简化xml配置文件多属性注入\n\n   1. **使用p名称空间注入，可以简化基于xml配置方式**\n\n      > 第一步添加p名称空间在配置文件中\n      >\n      > <beans  xmls:p=\"https://www.springframework.org/schema/p\">\n      >\n      > 第二步 进行属性注入，在bean标签里面进行操作\t\n      >\n      > ​\t<bean id=\"book\" class=\"com.xxx.xxx.Book\" p:bname=\"三国演义\" p:bauthor=\"罗贯中\" >\n      >\n      > ​\t</bean>\n      >\n      > </beans>\n\n##### 六、IOC操作Bean管理(xml注入其他类型属性)\n\n1. **字面值**\n\n   1. null值\n\n      <property name=\"address\">\n\n      ​\t<null/>\n\n      </property>\n\n   2. 属性值包含特殊符号\n\n      <property name=\"address\">\n\n      ​\t<value><![CDATA[<<南京>>]]></value>\n\n      </property>\n   \n2. 外部Bean注入\n\n   > 第一步：创建两个类service类和dao类\n   >\n   > ```java\n   > \n   > public interface UserDao {\n   >     public void update();\n   > }\n   > \n   > public class UserDaoImpl implements UserDao{\n   >     @Override\n   >     public void update() {\n   >         System.out.println(\"Dao update.....\");\n   >     }\n   > }\n   > ```\n   >\n   > 第二步：在service调用dao类里面的方法\n   >\n   > ```java\n   > public class UserService {\n   >     //创建UserDao类型属性，生成set方法\n   >     private UserDao userDao;\n   >     public void setUserDao(UserDao userDao) {\n   >         this.userDao = userDao;\n   >     }\n   >     public void add(){\n   >         System.out.println(\"service add......\");\n   > //        原始方式：\n   > //        创建UserDao对象\n   > //        UserDaoImpl userDao = new UserDaoImpl();\n   >         userDao.update();\n   >     }\n   > }\n   > ```\n   >\n   > 第三步：在spting配置文件中进行配置\n   >\n   > ```xml\n   > <!--    service和dao对象创建-->\n   >     <bean id=\"userService\" class=\"com.test.spring5.service.UserService\">\n   > <!--        注入UserDao对象-->\n   > <!--        ref:创建的userDao对象bean标签-->\n   >         <property name=\"userDao\" ref=\"userDao\"></property>\n   >     </bean>\n   >     <bean id=\"userDao\" class=\"com.test.spring5.dao.UserDaoImpl\"></bean>\n   > ```\n\n3. 内部Bean注入和级联赋值\n\n   一对多关系：部门和员工，一个部门有多个员工，一个员工属于某一个部门，部门是一，员工是多\n\n   ```java\n   // 部门类\n   public class Dept {\n       private String dName;\n       public void setdName(String dName) {\n           this.dName = dName;\n       }\n   }\n   ```\n\n   ```java\n   // 员工类\n   public class Emp {\n       private String eName;\n       private String gender;\n       private Dept dept;\n       public void setDept(Dept dept) {\n           this.dept = dept;\n       }\n       public void seteName(String eName) {\n           this.eName = eName;\n       }\n       public void setGender(String gender) {\n           this.gender = gender;\n       }\n   }\n   ```\n\n   对spring配置文件中进行配置\n\n   ```xml\n   <!--    内部bean-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n   <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n   <!--        设置对象类型属性-->\n           <property name=\"dept\">\n               <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n                   <property name=\"dName\" value=\"保安部\"></property>\n               </bean>\n           </property>\n       </bean>\n   ```\n\n4. 级联赋值\n\n   第一种写法：xml配置文件\n\n   ```xml\n      <!--    级联赋值-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n           <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n           <!--        设置对象类型属性-->\n   <!--        级联赋值-->\n           <property name=\"dept\" ref=\"dept\"></property>\n       </bean>\n       <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n           <property name=\"dName\" value=\"财务部\"></property>\n       </bean>\n   ```\n\n   第二种写法：生成get方法并修改配置文件\n\n   ```xml\n   <!--    级联赋值-->\n       <bean id=\"emp\" class=\"com.test.spring5.bean.Emp\">\n           <!--        设置两个普通属性-->\n           <property name=\"eName\" value=\"lucy\"></property>\n           <property name=\"gender\" value=\"女\"></property>\n           <!--        设置对象类型属性-->\n   <!--        级联赋值-->\n           <property name=\"dept\" ref=\"dept\"></property>\n           <property name=\"dept.dName\" value=\"技术部\"></property>\n       </bean>\n       <bean id=\"dept\" class=\"com.test.spring5.bean.Dept\">\n           <property name=\"dName\" value=\"财务部\"></property>\n       </bean>\n   ```\n\n##### 七、IOC操作Bean管理(xml注入集合属性)\n\n1. 注入数组类型属性\n\n2. 注入list集合类型属性\n\n3. 注入Map集合类型属性\n\n   第一步：定义一个类，定义数组、list集合、map集合、set集合属性，生成对应的set方法\n\n   ```java\n   public class Stu {\n       //1.数组类型属性\n       private String[] courses;\n       //2.list集合类型属性\n       private List<String> list;\n       //3.map集合类型属性\n       private Map<String,String> maps;\n       //4.set集合类型属性\n       private Set<String> sets;\n       public void setList(List<String> list) {\n           this.list = list;\n       }\n       public void setMaps(Map<String, String> maps) {\n           this.maps = maps;\n       }\n       public void setCourses(String[] courses) {\n           this.courses = courses;\n       }\n   }\n   ```\n\n   第二步：配置spring配置文件进行配置\n   \n   ```xml\n   <!--    集合类型属性注入-->\n       <bean id=\"stu\" class=\"com.test.spring5.collectiontype.Stu\">\n   <!--      数组属性注入-->\n           <property name=\"courses\">\n               <array>\n                   <value>语文</value>\n                   <value>数学</value>\n                   <value>英语</value>\n               </array>\n           </property>\n   <!--        list集合属性注入-->\n           <property name=\"list\">\n               <list>\n                   <value>张三</value>\n                   <value>李四</value>\n                   <value>王五</value>\n               </list>\n           </property>\n   <!--        map集合属性注入-->\n           <property name=\"maps\">\n                <map>\n                    <entry key=\"Java\" value=\"java基础\"></entry>\n                    <entry key=\"PHP\" value=\"php\"></entry>\n                </map>\n           </property>\n   <!--        set集合属性注入-->\n           <property name=\"sets\">\n               <set>\n                   <value>MySQL</value>\n                   <value>Redis</value>\n               </set>\n           </property>\n       </bean>\n   ```\n   \n4. 在集合里面设置对象类型的值\n\n   ```xml\n   <!--    创建多个course对象-->\n       <bean id=\"course1\" class=\"com.test.spring5.collectiontype.Course\">\n           <property name=\"cname\" value=\"Spring5\"></property>\n       </bean>\n       <bean id=\"course2\" class=\"com.test.spring5.collectiontype.Course\">\n           <property name=\"cname\" value=\"MyBatis\"></property>\n       </bean>\n   ```\n\n   ```xml\n   <!--        注入list集合类型，值是对象-->\n           <property name=\"courseList\">\n               <list>\n                   <ref bean=\"course1\"></ref>\n                   <ref bean=\"course2\"></ref>\n               </list>\n           </property>\n   ```\n\n5. 把集合注入部分提取出来\n\n   第一步：先在Spring配置文件中引入名称空间(util)\n\n   ```xml\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:util=\"http://www.springframework.org/schema/util\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                              http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n   \">\n   ```\n\n   第二步：使用util标签完成list集合注入提取\n\n   ```xml\n   <!--    1.提取list集合类型属性注入-->\n       <util:list id=\"bookList\">\n           <value>红楼梦</value>\n           <value>西游记</value>\n           <value>易筋经</value>\n       </util:list>\n   <!--    2.提取list注入使用-->\n       <bean id=\"book\" class=\"com.test.spring5.collectiontype.Book\">\n           <property name=\"list\" ref=\"bookList\"></property>\n       </bean>\n   ```\n\n##### 八、IOC操作Bean管理(FactoryBean)\n\n1. Spring有两种类型的Bean，一种普通的bean，另外一种是工厂bean(FactoryBean)\n\n   > 普通Bean：在配置文件中定义Bean类型就是返回类型\n   >\n   > 工厂Bean：在配置文件定义Bean类型可以和返回类型不一样\n\n   第一步：创建类，让这个类作为工厂Bean，实现接口FactoryBean\n\n   第二步：实现接口里面的方法，在实现的方法中定义返回的Bean类型\n\n   ```java\n   public class MyBean implements FactoryBean<Course> {\n       //返回对象实例\n       //定义返回Bean\n       @Override\n       public Course getObject() throws Exception {\n           Course course = new Course();\n           course.setCname(\"abc\");\n           return course;\n       }\n       //返回类型\n       @Override\n       public Class<?> getObjectType() {\n           return null;\n       }\n       //它是否是个单例\n       @Override\n       public boolean isSingleton() {\n           return FactoryBean.super.isSingleton();\n       }\n   }\n   ```\n\n   ```java\n    @Test\n   public void testCollection3(){\n   ApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\");\n           Course course = context.getBean(\"myBean\", Course.class);\n           System.out.println(course);\n       }\n   ```\n\n   ```xml\n   <bean id=\"myBean\" class=\"com.test.spring5.factorybean.MyBean\"></bean>\n   ```\n\n九、IOC操作Bean管理(Bean作用域)\n\n1. 在Spring里面，设置创建Bean实例是单实例还是多实例\n\n\n2. 在Spring里面，默认情况下，bean是单实例对象\n\n\n   ```java\n   @Test\n       public void testCollection4(){\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\");\n           Book book1 = context.getBean(\"book\", Book.class);\n           Book book2 = context.getBean(\"book\", Book.class);\n        //单实例输出对象相同\n           System.out.println(book1);\n           System.out.println(book2);\n       }\n   ```\n\n3. 如何设置单实例还是多实例\n\n\n   1. 在Spring配置文件bean标签里面有属性(scope)用于设置单实例还是多实例\n\n   2. scope属性值\n\n      第一个值：默认值，singleton，表示是单实例对象\n\n      第二个值：prototype，表示是多实例对象\n\n      ```xml\n      <bean id=\"book\" class=\"com.test.spring5.collectiontype.Book\" scope=\"prototype\">\n           <property name=\"list\" ref=\"bookList\"></property>\n      </bean>\n      ```\n\n   3. singleton和prototype区别\n\n      > 1. singleton  单实例，prototype  多实例\n      > 2. 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象。设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象。\n\n\n##### 十、IOC操作Bean管理(bean生命周期)\n\n1. 生命周期\n\n   从对象的创建到对象销毁的过程\n\n2. bean的生命周期\n\n   1. 通过构造器创建bean实例(无参构造)\n   2. 为bean里面的属性设置值和对其他bean的引用(调用set方法)\n   3. 调用bean的初始化的方法(需要进行配置)\n   4. bean可以使用了(对象获取到了)\n   5. 当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)\n\n   ```java\n   public class Orders {\n       //无参构造\n       public Orders() {\n           System.out.println(\"第一步：执行无参数构造创建Bean实例\");\n       }\n       private String oname;\n       public void setOname(String oname) {\n           this.oname = oname;\n           System.out.println(\"第二步：调用set方法设置属性值\");\n       }\n       //创建执行的初始化的方法\n       public void initMethod(){\n           System.out.println(\"第三步：执行初始化的方法\");\n       }\n       //创建执行的销毁的方法\n       public void destroyMethod(){\n           System.out.println(\"第五步：执行销毁的方法\");\n       }\n   ```\n\n   ```xml\n   <bean id=\"orders\" class=\"com.test.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n           <property name=\"oname\" value=\"手机\"></property>\n       </bean>\n   ```\n\n   ```java\n    @Test\n       public void testBean(){\n           ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean5.xml\");\n           Orders orders = context.getBean(\"orders\", Orders.class);\n           System.out.println(\"第四步：获取到创建bean实例对象\");\n           System.out.println(orders);\n           //手动让bean实例销毁\n           context.close();\n       }\n   ```\n\n3. bean的后置处理器\n\n   1. 通过构造器创建bean实例(无参构造)\n\n   2. 为bean里面的属性设置值和对其他bean的引用(调用set方法)\n\n   3. 把bean实例传递bean后置处理器的方法      -----postProcessBeforeInitialization\n\n   4. 调用bean的初始化的方法(需要进行配置)\n\n   5. 把bean实例传递bean后置处理器的方法      -----postProcessAfterInitialization\n\n   6. bean可以使用了(对象获取到了)\n\n   7. 当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)\n\n      后置处理器  例：\n\n      1. 创建类，实现接口BeanPostProcessor，创建后置处理器\n\n      ```java\n      public class MyBeanPost implements BeanPostProcessor {\n          @Override\n          public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n              System.out.println(\"在初始化之前执行的方法-------后置处理器\");\n              return bean;\n          }\n          @Override\n          public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n              System.out.println(\"在初始化之后执行的方法------后置处理器\");\n              return bean;\n          }\n      }\n      ```\n\n      ```xml\n      <!--    配置后置处理器-->\n          <bean id=\"myBeanPost\" class=\"com.test.spring5.bean.MyBeanPost\"></bean>\n      ```\n\n\n##### 十一、IOC操作Bean管理(xml自动装配)\n\n​\t根据指定装配规则(属性名称或者属性类型)，spring自动将匹配的属性值进行注入\n\n 1. 根据属性的名称自动注入\n\n    ```xml\n    <!--    实现自动装配-->\n    <!--    bean标签中有个属性autowire，配置自动装配-->\n    <!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入-->\n        <bean id=\"emp\" class=\"com.test.spring5.autowire.Emp\" autowire=\"byName\">\n        </bean>\n        <bean id=\"dept\" class=\"com.test.spring5.autowire.Dept\"></bean>\n    ```\n\n 2. 根据属性的类型自动注入(相同类型的属性不能定义多个)\n\n    ```xml\n    <!--    实现自动装配-->\n    <!--    bean标签中有个属性autowire，配置自动装配-->\n    <!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入-->\n        <bean id=\"emp\" class=\"com.test.spring5.autowire.Emp\" autowire=\"byType\">\n        </bean>\n        <bean id=\"dept\" class=\"com.test.spring5.autowire.Dept\"></bean>\n    ```\n\n##### 十二、IOC操作Bean管理(引入外部属性文件)\n\n1. 直接配置数据库信息\n\n   1. 配置德鲁伊连接池\n   2. 引入德鲁伊连接池依赖jar包\n\n   ```xml\n   <!--    配置连接池-->\n       <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n           <property name=\"url\" value=\"jdbc:mysql://localhost:3306/userDb\"></property>\n           <property name=\"username\" value=\"root\"></property>\n           <property name=\"password\" value=\"root\"></property>\n       </bean>\n   ```\n\n2. 引入外部属性文件配置数据库连接池\n\n   1. 创建外部属性文件，properties格式文件，写数据库信息\n\n      ```properties\n      prop.driverClassName=com.mysql.jdbc.Driver\n      prop.url=jdbc:mysql://localhost:3306/userDb\n      prop.username=root\n      prop.password=root\n      ```\n\n   2. 把外部properties属性文件引入spring配置文件中\n\n      1. 引入context名称空间\n\n         ```xml\n         <beans xmlns=\"http://www.springframework.org/schema/beans\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xmlns:context=\"http://www.springframework.org/schema/context\"\n                xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n         \">\n         ```\n\n      2. 在spring配置引入外部文件\n\n         ```xml\n         <!--    引入外部的属性文件-->\n             <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n             <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n                 <property name=\"driverClassName\" value=\"${prop.driverClassName}\"></property>\n                 <property name=\"url\" value=\"${prop.url}\"></property>\n                 <property name=\"username\" value=\"${prop.username}\"></property>\n                 <property name=\"password\" value=\"${prop.password}\"></property>\n             </bean>\n         ```\n\n##### 十三、IOC操作Bean管理(基于注解方式)\n\n1. 什么是注解\n\n   注解是代码特殊标记，格式：@注解名称(属性名称=属性值，属性名称=属性值...)\n\n   使用注解，注解可以作用在类上面，方法上面，属性上面\n\n   使用注解的目的：简化xml配置\n\n2. Spring针对Bean管理(创建对象)中创建对象提供注解\n\n   1. @Component\n   2. @Service\n   3. @Controller\n   4. @Repository\n\n   上面的四个注解功能是一样的，都是用来创建Bean的实例\n\n3. 基于注解方式实现对象创建\n\n   1. 第一步引入依赖\n   2. 开启组件扫描\n\n   ```xml\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:context=\"http://www.springframework.org/schema/context\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n   \">\n   <!--    开启组件扫描\n       1.扫描多个包，多个包之间使用逗号隔开\n       2.扫描包上层目录\n   -->\n       <context:component-scan base-package=\"com.test.spring5\"></context:component-scan>\n   ```\n   \n   3. 创建类，在类上面添加创建对象得注解\n   \n   ```java\n      //注解里面value属性值可以省略\n      //默认值是类名称，首字母小写\n      @Service(value = \"userService\")//类似 <bean id=\"userService\" class=\"...\"></bean>\n      public class UserService {\n          public void add(){\n              System.out.println(\"service add.....\");\n          }\n      }\n   ```\n   \n   4. 开启组件扫描细节配置\n   \n   ```xml\n      <!--    示例1\n          use-default-filters=\"false\"   表示现在不使用默认的filters，自己配置filter\n          context:include-filter        扫描那些内容\n      -->\n          <context:component-scan base-package=\"com.test.spring5\" \n                                  use-default-filters=\"false\">\n              <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n          </context:component-scan>\n   ```\n   \n   ```xml\n   <!--    示例2\n       context:exclude-filter     设置那些内容不进行扫描\n   -->\n       <context:component-scan base-package=\"com.test.spring5\" >\n           <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n       </context:component-scan>\n   ```\n\n##### 十四、IOC操作Bean管理(基于注解属性注入)\n\n1. **@Autowired**：根据属性类型进行自动装配\n\n   例：\n\n   第一步 吧service和dao对象创建，在service和dao类添加创建对象注解\n\n   第二步 在service注入dao对象，在service类添加dao类属性，在属性上面使用注解\n\n   ```java\n   @Service\n   public class UserService {\n       //定义dao类型属性\n       //不需要添加set方法\n       //添加注入属性的注解\n       @Autowired\n       private UserDao userDao;\n       public void add(){\n           System.out.println(\"service add.....\");\n       }\n   }\n   ```\n\n   \n\n2. **@Qualifier**：根据属性名称进行注入\n\n   @Qualifier需要配合@Autowired注解进行使用\n\n   ```java\n   @Repository(value = \"userDapImpl1\")\n   public class UserDaoImpl implements UserDao{\n       @Override\n       public void add() {\n           System.out.println(\"dao  add......\");\n       }\n   }\n   ```\n\n   ```java\n    @Autowired  //根据类型进行注入\n       @Qualifier(value = \"userDapImpl1\")\n       private UserDao userDao;\n       public void add(){\n           System.out.println(\"service add.....\");\n           userDao.add();\n       }\n   ```\n\n3. **@Resource**：可以根据类型注入，也可以根据名称注入\n\n   ```java\n    import javax.annotation.Resource;\n   \n    @Resource( name = \"userDapImpl1\")  //根据名称进行注入\n    @Resource   //根据类型注入 \n   ```\n\n4. **@Value**：注入普通类型属性\n\n   ```java\n   @Value(value = \"Tom\")  //普通类型属性注入\n       private String name;\n       public void add(){\n           System.out.println(\"service add.....\");\n           System.out.println(\"service-name-\"+name);\n           userDao.add();\n       }\n   ```\n\n5. 纯注解开发\n\n   1. 创建配置类，替代xml配置\n\n      ```java\n      @Configuration   //作为配置类，替代xml配置文件\n      @ComponentScan(basePackages = {\"com.test.spring5\"}) //开启\n      public class SpringConfig {\n      }\n      ```\n\n   2. 编写测试类\n\n      ```java\n      @Test\n          public void testService2(){\n              //加载配置类\n              ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);\n              UserService userService = context.getBean(\"userService\", UserService.class);\n              System.out.println(userService);\n              userService.add();\n          }\n      ```\n\n## 三、AOP\n\n#### 一、什么是AOP(概念)\n\n​\tAOP为Aspect Oriented Programming 面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率\n\n​\t`不通过修改源代码的方式添加新功能`\n\n​\t通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n\n#### 二、AOP底层原理\n\n1. AOP底层使用动态代理\n   1. 第一种有接口的情况(JDK动态代理)\n   2. 第二种没有接口的情况(CGLib动态代理)\n\n##### 2.1、AOP底层原理(JDK动态代理)\n\n1. 使用JDK动态代理，使用Proxy类里面的方法创建代理对象\n\n   java.lang.reflect.Proxy\n\n   主要方法：\n\n   | 修饰符和类型  | 方法与描述                                                   |\n   | ------------- | ------------------------------------------------------------ |\n   | static Object | newProxyInstance（）返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。 |\n\n   里面有三个参数\n   \n   | 参数名                | 说明                                       |\n   | --------------------- | ------------------------------------------ |\n   | ClassLoader loader    | 类加载器                                   |\n   | Class<?>[] interfaces | 增强方法所在类，这个类的接口，支持多个接口 |\n   | InvocationHandler h   | 实现这个接口，创建代理对象，写增强的方法   |\n   \n2. 编写JDK动态代理代码\n\n   1. 创建接口，定义方法\n\n      ```java\n      public interface UserDao {\n          public int add(int a, int b);\n          public String update(String id);\n      }\n      ```\n\n   2. 创建接口实现类，实现方法\n\n      ```java\n      public class UserDaoImpl implements UserDao{\n          @Override\n          public int add(int a, int b) {\n              return a+b;\n          }\n          @Override\n          public String update(String id) {\n              return id;\n          }\n      }\n      ```\n\n   3. 使用Proxy类创建接口代理对象(增强)\n\n      ```java\n      public class JDKProxy {\n          public static void main(String[] args) {\n              //创建接口实现类代理对象\n              Class[] interfaces = {UserDao.class};\n      //        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() {\n      //            @Override\n      //            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      //                return null;\n      //            }\n      //        });\n              UserDaoImpl userDao = new UserDaoImpl();\n              UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n              int result = dao.add(1, 2);\n              System.out.println(\"result:\"+result);\n          }\n      }\n      //创建代理对象代码\n      class UserDaoProxy implements InvocationHandler{\n          //1 把创建的是谁的代理对象，把谁传递过来\n          //有参数的构造传递\n          private Object obj;\n          public UserDaoProxy(Object obj) {\n              this.obj = obj;\n          }\n          //对象被创建就会调用invoke方法\n          @Override\n          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n              //增强的逻辑\n              //方法之前\n              System.out.println(\"方法执行之前......\"+method.getName()+\"  :传递的参数...\"+ Arrays.toString(args));\n              //被增强的方法执行\n              Object res = method.invoke(obj, args);\n              //方法之后\n              System.out.println(\"方法执行之后......\"+ obj);\n              return res;\n          }\n      }\n      ```\n\n#### 三、AOP(术语)\n\n​\t术语就是例如，汽车发动机又叫引擎\n\n1. 连接点\n\n   > 类里面那些方法可以被增强，这些方法称为连接点\n\n2. 切入点\n\n   > 实际被真正增强的方法，称为切入点\n\n3. 通知(增强)\n\n   > 1. 实际增强的逻辑部分称为通知(增强)\n   > 2. 通知有多种类型\n   >    1. 前置通知：被增强的原始方法之前执行的逻辑\n   >    2. 后置通知：被增强的原始方法之后执行的逻辑\n   >    3. 环绕通知：被增强的原始方法之前后执行的逻辑\n   >    4. 异常通知：被增强的原始方法出现异常后执行的逻辑\n   >    5. 最终通知：如同try~catch后面的finally类似\n\n   ```java\n     //前置通知\n       //Before 注解表示作为前置通知\n       @Before(value = \"execution()\")\n       //后置通知(返回值通知)\n       @AfterReturning(value = \"execution()\")\n       //环绕通知\n       @Around(value = \"execution()\")\n       //异常通知\n       @AfterThrowing(value = \"execution()\")\n       //最终通知\n       @After(value = \"execution()\")  \n   ```\n\n4. 切面\n\n   > 把通知应用到切入点过程，是一个动作\n\n#### 四、AOP操作\n\n##### 4.1 准备工作\n\n1. Spring框架中一般都是基于AspectJ实现AOP操作\n\n   1. 什么是AspectJ\n\n      > AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作\n\n2. 基于`AspectJ`实现AOP操作\n\n   1. 基于xml配置文件\n   2. 基于注解方式使用(常用)\n\n3. 在项目工程里面引入AOP相关依赖\n\n   > spring-aspects-5.2.6.RELEASE.jar\n   > spring-aop-5.2.6.RELEASE.jar\n   > com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar\n   > com.springsource.org.aopalliance-1.0.0.jar\n   > com.springsource.net.sf.cglib-2.2.0.jar\n\n4. 切入点表达式\n\n   > 1. 切入点表达式作用：知道对那个类里面的那个方法进行增强\n   >\n   > 2. 语法结构：\n   >\n   >    excution([权限修饰符]\\[返回类型]\\[类的全路径]\\[方法名称]([参数列表]))\n   >    \n   >    举例1：对com.test.dao.BoolDao类里面的add进行增强\n   >    \n   >    `xcution(* com.test.dao.BoolDao.add(..));`\n   >    \n   >    举例2：对com.test.dao.BoolDao类里面的所有方法增强\n   >    \n   >    `excution(* com.test.dao.BoolDao.*(..));`\n   >    \n   >    举例3：对com.test.dao.BoolDao类里面的所有类和所有类中的所有方法增强\n   >    \n   >    `excution(* com.test.dao.\\*.*(..));`\n\n##### 4.2 AOP操作(AspectJ注解)\n\n1. 创建类，在类里面定义方法，被增强类\n\n   ```java\n   //被增强的类\n   public class User {\n       public void add(){\n           System.out.println(\"User add......\");\n       }\n   }\n   ```\n\n2. 创建增强类(编写增加的逻辑)\n\n   在增强的类里面，创建不同的方法，让不同的方法代表不同的通知类型\n\n   ```java\n   //增强的类\n   public class UserProxy {\n       //前置通知\n       public void before(){\n           System.out.println(\"before......   前置通知\");\n       }\n   }\n   ```\n\n3. 进行通知的配置\n\n   1. 在spring配置文件中，开启注解扫描\n\n      ```xml\n      <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <beans xmlns=\"http://www.springframework.org/schema/beans\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xmlns:context=\"http://www.springframework.org/schema/context\"\n             xmlns:aop=\"http://www.springframework.org/schema/aop\"\n             xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                                 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                                 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n      \">\n      <!--    开启注解扫描-->\n          <context:component-scan base-package=\"com.test.spring5.aopanno\"></context:component-scan>\n      </beans>\n      ```\n\n   2. 使用注解创建User和UserProxy对象\n\n      ```java\n      @Component\n      public class User {\n          public void add(){\n              System.out.println(\"User add......\");\n          }\n      }\n      ```\n\n      ```java\n      @Component\n      public class UserProxy {\n          //前置通知\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      }\n      ```\n\n      \n\n   3. 在增强类上面添加注解@Aspect\n\n      ```java\n      @Component\n      @Aspect  //生成代理对象\n      public class UserProxy {\n          //前置通知\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      }\n      ```\n\n   4. 在Spring配置文件中开启生成代理对象\n\n      ```xml\n      <!--    开启Aspect生成代理对象-->\n          <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n      ```\n\n   5. 配置不同类型的通知\n\n      在我增强类的里面，作为通知方法上面添加通知类型注解，使用切入点表达式配置\n\n      ```java\n      //增强的类\n      @Component\n      @Aspect  //生成代理对象\n      public class UserProxy {\n          //前置通知\n          //Before 注解表示作为前置通知\n          @Before(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      \n          //后置通知(返回值通知)\n          @AfterReturning(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void afterReturning(){\n              System.out.println(\"AfterReturning......   后置通知\");\n          }\n      \n          //环绕通知\n          @Around(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n              System.out.println(\"环绕之前......\");\n              //被增强的方法执行\n              proceedingJoinPoint.proceed();\n              System.out.println(\"环绕之后......\");\n          }\n      \n          //异常通知\n          @AfterThrowing(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void afterThrowing(){\n              System.out.println(\"AfterThrowing......   前置通知\");\n          }\n      \n          //最终通知\n          @After(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void after(){\n              System.out.println(\"After......  最终通知\");\n          }\n      }\n      ```\n\n   6. 相同切入点进行抽取\n\n      ```java\n       //相同切入点抽取\n          @Pointcut(value = \"execution(* com.test.spring5.aopanno.User.add(..))\")\n          public void pointDemo(){\n          }\n          //前置通知\n          //Before 注解表示作为前置通知\n          @Before(value = \"pointDemo()\")\n          public void before(){\n              System.out.println(\"before......   前置通知\");\n          }\n      ```\n\n   7. 有多个增强类对同一个方法增强，设置增强类优先级\n\n      在增强类上面添加注解@Order(值)，数字类型的值，数值越小优先级越高\n\n      ```java\n      @Component\n      @Aspect\n      @Order(1)  //优先级\n      public class PersonProxy {\n      ```\n      \n   8. 完全使用注解开发\n   \n      ```java\n      //配置类不需要创建xml配置文件\n      @Configuration\n      @ComponentScan(basePackages = {\"com.test.spring5\"})\n      @EnableAspectJAutoProxy(proxyTargetClass = true)\n      public class ConfigAop {\n      }\n      ```\n   \n\n##### 4.3 AOP操作(AspectJ配置文件)\n\n1. 创建两个类，增强类和被增强类，创建方法\n\n   ```java\n   public class Book {\n       public void buy(){\n           System.out.println(\"buy......\");\n       }\n   }\n   ```\n\n   ```java\n   public class BookProxy {\n       public void before(){\n           System.out.println(\"before......\");\n       }\n   }\n   ```\n\n2. 在spring配置文件中创建两个类对象\n\n   ```xml\n   <!--    创建两个类的对象-->\n       <bean id=\"book\" class=\"com.test.spring5.aopxml.Book\"></bean>\n       <bean id=\"bookProxy\" class=\"com.test.spring5.aopxml.BookProxy\"></bean>\n   ```\n\n3. 在spring配置文件中配置切入点\n\n   ```java\n   <!--    创建两个类的对象-->\n       <bean id=\"book\" class=\"com.test.spring5.aopxml.Book\"></bean>\n       <bean id=\"bookProxy\" class=\"com.test.spring5.aopxml.BookProxy\"></bean>\n   <!--    配置AOP增强-->\n       <aop:config>\n   <!--        切入点-->\n           <aop:pointcut id=\"p\" expression=\"execution(* com.test.spring5.aopxml.Book.buy(..))\"/>\n   <!--        配置切面-->\n           <aop:aspect ref=\"bookProxy\">\n   <!--            增强作用在具体的方法上-->\n               <aop:before method=\"before\" pointcut-ref=\"p\"/>\n           </aop:aspect>\n       </aop:config>\n   ```\n\n\n## 四、JDBC Templatek\n\n#### 一、概念和准备\n\n1. 什么是JDBCTemplatek\n\n   Spring框架对JDBC进行封装，使用JDBCTemplatek方便实现对数据库操作\n\n2. 准备工作\n\n   1. 引入相关的依赖\n\n      > spring-tx-5.2.6.RELEASE.jar\n      > spring-orm-5.2.6.RELEASE.jar\n      > spring-jdbc-5.2.6.RELEASE.jar\n      > druid-1.1.9.jar\n      > mysql-connector-java-8.0.28.jar\n\n   2. 在spring配置文件配置数据库连接池\n\n      ```xml\n      <!--    数据库连接池-->\n          <bean id=\"database\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\">\n              <property name=\"url\" value=\"jdbc:mysql:///user_db\"/>\n              <property name=\"username\" value=\"root\"/>\n              <property name=\"password\" value=\"root\"/>\n              <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n          </bean>\n      ```\n\n   3. 配置JDBCTemplate对象,注入DataSource\n\n      ```xml\n      <!--    创建JDBCTemplate对象-->\n          <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n      <!--        注入dataSource-->\n              <property name=\"dataSource\" ref=\"database\"/>\n          </bean>\n      ```\n\n   4. 创建Service类，创建dao类，在dao注入jdbcTemlate对象\n   \n      ```xml\n      <!--    开启组件扫描-->\n          <context:component-scan base-package=\"com.test.spring5\"></context:component-scan>\n      ```\n   \n      ```java\n      @Service\n      public class BookService {\n          //注入dao\n          @Autowired\n          private BookDao bookDao;\n      }\n      ```\n   \n      ```java\n      @Repository\n      public class BookDaoImpl implements BookDao{\n          //注入jdbcTemplate\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n      }\n      ```\n\n#### 二、JDBCTemplate操作数据库\n\n##### 一、添加\n\n1. 对应数据库创建实体类\n\n   ```java\n   public class User {\n       private String userId;\n       private String username;\n       private String ustatus;\n       public String getUserId() {\n           return userId;\n       }\n       public void setUserId(String userId) {\n           this.userId = userId;\n       }\n   ```\n\n2. 编写service和dao\n\n   1. 在dao层进行数据库添加操作\n\n   2. 调用jdbctemplate对象里面的update方法实现添加操作\n\n      | 参数            | 说明                    |\n      | --------------- | ----------------------- |\n      | String  SQL     | sql语句                 |\n      | Object...  args | 可变参数，设置sql语句值 |\n\n      ```java\n      @Repository\n      public class BookDaoImpl implements BookDao{\n          //注入jdbcTemplate\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n          //添加的方法\n          public void add(Book book){\n              //创建sql语句\n              String sql = \"insert into t_book values(?,?,?)\";\n              //调用方法实现\n      //        int rows = jdbcTemplate.update(sql, book.getUserId(), book.getUsername(), book.getUstatus());\n              Object[] args = { book.getUserId(), book.getUsername(), book.getUstatus()};\n              int rows = jdbcTemplate.update(sql,args);\n              System.out.println(rows);\n          }\n      }\n      ```\n\n3. 测试类\n\n   ```java\n   public class TestBook {\n       @Test\n       public void testJDBCTemplate(){\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\");\n           BookService bookService = context.getBean(\"bookService\", BookService.class);\n           Book book = new Book();\n           book.setUserId(\"1\");\n           book.setUsername(\"红露面\");\n           book.setUstatus(\"a\");\n           bookService.addBook(book);\n       }\n   }\n   ```\n\n##### 二、修改\n\n1. BookService添加修改方法\n\n   ```java\n   //修改的方法\n       @Override\n       public void updateBook(Book book) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n           int update = jdbcTemplate.update(sql, args);\n           System.out.println(\"修改了\"+update+\"记录\");\n       }\n   ```\n\n2. 实现修改方法\n\n   ```java\n   //修改的方法\n       @Override\n       public void updateBook(Book book) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n           int update = jdbcTemplate.update(sql, args);\n           System.out.println(\"修改了\"+update+\"记录\");\n       }\n   ```\n\n3. 测试\n\n   ```java\n   Book book = new Book();\n           book.setUserId(\"1\");\n           book.setUsername(\"许仙\");\n           book.setUstatus(\"AAAA\");\n           bookService.updateBook(book);\n   ```\n\n##### 三、删除\n\n```java\n//修改的方法\n    @Override\n    public void updateBook(Book book) {\n        String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n        Object[] args = { book.getUsername(), book.getUstatus(),book.getUserId()};\n        int update = jdbcTemplate.update(sql, args);\n        System.out.println(\"修改了\"+update+\"记录\");\n    }\n```\n\n测试\n\n```java\nBook book = new Book();\n        bookService.deleteBook(\"1\");\n```\n\n##### 四、查询\n\n1. **查询返回某个值**\n\n   1. 查询表里面有多少条记录，返回某个值\n\n   2. 使用jdbcTemplate实现返回某个值代码\n\n      queryForObject\n\n      | 参数                  | 说明          |\n      | --------------------- | ------------- |\n      | String  SQL           | sql语句       |\n      | Class<T> requiredType | 返回类型Class |\n\n      ```java\n      @Override\n          public int selectCount() {\n              String sql = \"select count(*) from t_book\";\n              Integer count = jdbcTemplate.queryForObject(sql, Integer.class);\n              return count;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n       //查询\n              int count = bookService.findCount();\n              System.out.println(count);\n      ```\n\n2. **查询返回对象**\n\n   1. 场景：查询图书的详情页面\n\n   2. JDBCTemplate实现查询返回对象\n\n      | 参数                   | 说明                                                         |\n      | ---------------------- | ------------------------------------------------------------ |\n      | String SQL             | sql语句                                                      |\n      | RowMapper<T> rowMapper | rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装 |\n      | object... args         | sql语句值                                                    |\n\n      ```java\n      @Override\n          public Book findBookInfo(String id) {\n              String sql = \"select * from t_book where user_id=?\";\n              //调用方法\n              Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n              return book;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n      //查询返回对象\n              Book one = bookService.findOne(\"1\");\n              System.out.println(one);\n      ```\n\n3. **查询返回集合**\n\n   1. 场景：查询图书列表分页...\n\n   2. 调用jdbcTemplate方法实现查询返回集合\n\n      query()\n\n      | 参数                   | 说明                                                         |\n      | ---------------------- | ------------------------------------------------------------ |\n      | String SQL             | sql语句                                                      |\n      | RowMapper<T> rowMapper | rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装 |\n      | object... args         | sql语句值                                                    |\n\n      ```java\n      //查询返回集合\n          @Override\n          public List<Book> findALlBook() {\n              String sql = \"select * from t_book\";\n              List<Book> bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));\n              return bookList;\n          }\n      ```\n\n   3. 测试\n\n      ```java\n      //查询返回集合\n              List<Book> all = bookService.findAll();\n              System.out.println(all);\n      ```\n\n##### 五、批量操作\n\n1. 批量操作：操作表里面多条记录\n\n2. jdbcTemplate实现批量添加的操作\n\n   batchUpdate(String sql,List<Object[]> barchArgs)\n\n   | 参数                     | 说明                       |\n   | ------------------------ | -------------------------- |\n   | String SQL               | sql语句                    |\n   | List<object[]> barchArgs | list集合添加的多条记录数据 |\n   \n   ```java\n    //批量添加\n       @Override\n       public void batchAddBook(List<Object[]> bachArgs) {\n           String sql = \"insert into t_book values(?,?,?)\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(Arrays.toString(ints));\n       }\n   ```\n   \n3. 测试\n\n   ```java\n   //批量添加\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"4\",\"张三\",\"qwe\"};\n           Object[] o2 = {\"5\",\"李四\",\"qwerty\"};\n           Object[] o3 = {\"6\",\"王五\",\"ewq\"};\n           list.add(o1);\n           list.add(o2);\n           list.add(o3);\n           bookService.batchAdd(list);\n   ```\n\n4. jdbcTemplate实现批量修改的操作\n\n   ```java\n    @Override\n       public void batchUpdateBook(List<Object[]> bachArgs) {\n           String sql = \"update t_book set username=?,ustatus=? where user_id=?\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(Arrays.toString(ints));\n       }\n   ```\n\n5. 测试\n\n   ```java\n   //批量修改\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"红楼梦\",\"aaa\",\"1\"};\n           Object[] o2 = {\"西游记\",\"bbb\",\"2\"};\n           Object[] o3 = {\"水浒传\",\"ccc\",\"3\"};\n           list.add(o1);\n           list.add(o2);\n           list.add(o3);\n           bookService.batchUpdate(list);\n   ```\n\n6. 批量删除\n\n   ```Java\n    //批量删除\n       @Override\n       public void batchDeleteBook(List<Object[]> bachArgs) {\n           String sql = \"delete from t_book where user_id=?\";\n           int[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);\n           System.out.println(ints);\n       }\n   ```\n\n7. 测试\n\n   ```java\n   //批量删除\n           List<Object[]> list = new ArrayList<>();\n           Object[] o1 = {\"4\"};\n           Object[] o2 = {\"5\"};\n           list.add(o1);\n           list.add(o2);\n           bookService.batchUpdate(list);\n   ```\n\n## 五、事务管理\n\n#### 一、概念\n\n1. 事务是数据库操作的最基本单元，逻辑上一组操作，要么都成功，要么失败一个其他所有操作都是失败\n2. 典型场景：银行转账\n3. 事务四个特性(ACID)\n   1. 原子性\n   2. 一致性\n   3. 隔离性\n   4. 持久性\n\n#### 二、事务操作\n\n##### 1.搭建事务操作环境\n\n   1. 创建数据库表，添加记录\n\n   2. 创建service，创建dao，完成对象创建和注入关系\n\n      service注入dao，在dao注入jdbcTemplate，在jdbcTemplate注入DataSource\n\n      ```java\n      @Service\n      public class UserService {\n          //注入dao\n          @Autowired\n          private UserDao userDao;\n      }\n      ```\n\n      ```java\n      @Repository\n      public class UserDaoImpl implements UserDao {\n          @Autowired\n          private JdbcTemplate jdbcTemplate;\n      }\n      ```\n\n   3. 在dao创建两个方法：多钱和少钱方法，在service创建方法(转账的方法)\n\n      ```java\n      @Override\n          public void addMoney() {\n              String sql = \"update t_account set money=money+? where username=?\";\n              jdbcTemplate.update(sql, 100, \"李四\");\n          }\n          @Override\n          public void reduceMoney() {\n              String sql = \"update t_account set money=money-? where username=?\";\n              jdbcTemplate.update(sql, 100, \"张三\");\n          }\n      ```\n\n      ```java\n      //转账方法\n          public void accountMoney() {\n              userDao.reduceMoney();\n              userDao.addMoney();\n          }\n      ```\n\n   4. 上面代码，正常执行没有问题，但是代码如果产生异常，会有问题\n\n      问题：张三扣除100块，而李四并没有收到100块\n\n      以上问题问题解决方案，使用事务进行解决，要么一起成功要么一起失败\n\n      > 事务的操作过程：\n      >\n      > 1. 开启事务\n      > 2. 进行业务操作(try~catch捕获并处理异常)\n      > 3. 没有异常，提交事务\n      > 4. 出现了异常，事务回滚\n\n##### 2.事务操作(spring事务管理介绍)\n\n   1. 事务添加到JavaEE三层结构里面Service层(业务逻辑层)\n\n   2. 在Spring进行事务管理操作\n\n      > 有两种方式：编程式事务管理和声明式事务管理(使用)\n\n   3. 声明式事务管理\n\n      1. 基于注解方式\n      2. 基于xml配置文件方式\n\n   4. 在Spring进行声明式事务管理，底层使用AOP原理\n\n   5. Spring事务管理API\n\n      1. 提供了一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类\n\n         `PlatformTransactionManager`\n\n##### 3.事务操作(注解声明式事务管理)\n\n   1. 在Spring配置文件配置事务管理器\n\n      ```xml\n      <!--    创建事务管理器-->\n          <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <!--        注入数据源-->\n              <property name=\"dataSource\" ref=\"database\"></property>\n          </bean>\n      ```\n\n   2. 在Spring配置文件,开启事务注解\n\n      在spring配置文件引入名称空间tx\n\n      ```xml\n      <!--    开启事务注解-->\n          <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n      ```\n\n   3. 在service类上面添加事务注解\n\n      @Transactional,这个注解添加到类上面,也可以添加到方法上面\n\n      添加在类上,表示这个类中所有方法都添加了事务\n\n      添加到方法上,只为该方法提供事务\n\n      ```java\n      @Service\n      @Transactional\n      public class UserService {\n      ```\n\n##### 4.事务操作(声明式事务管理参数)\n\n   | 参数名                    | 说明           |\n   | ------------------------- | -------------- |\n   | Propagation propagation() | 事务的传播行为 |\n   | Isolation isolation()     | 事务的隔离级别 |\n   | int timeout()             | 事务的超时时间 |\n   | boolearn readOnly         | 是否只读       |\n   | rollbackFor               | 回滚           |\n   | noRollbackFor             | 不回滚         |\n\n   **`propagation()`**:事务的传播行为\n\n   | 参数          | 说明                                                         |\n   | ------------- | ------------------------------------------------------------ |\n   | MANDATORY     | 支持当前事务，如果不存在则引发异常。                         |\n   | NESTED        | 如果当前事务存在，则在嵌套事务内执行，否则行为类似于 `REQUIRED` |\n   | NEVER         | 以非事务方式执行，如果存在事务则引发异常。                   |\n   | NOT_SUPPORTED | 以非事务方式执行，如果存在当前事务，则挂起当前事务。         |\n   | REQUIRED      | 支持当前事务，如果不存在则创建新事务。                       |\n   | REQUIRES_NEW  | 创建一个新事务，如果当前事务存在，则挂起当前事务。           |\n   | SUPPORTS      | 支持当前事务，如果不存在，则以非事务方式执行。               |\n\n   **`isolation`**:事务的隔离级别\n\n   | 参数             | 说明                                                      |\n   | ---------------- | --------------------------------------------------------- |\n   | DEFAULT          | 使用基础数据存储区的默认隔离级别。                        |\n   | READ_COMMITTED   | 一个常量，指示阻止脏读;可能发生不可重复的读取和幻像读取。 |\n   | READ_UNCOMMITTED | 一个常量，指示可能发生脏读、不可重复读和幻像读。          |\n   | REPEATABLF_READ  | 一个常量，指示阻止脏读取和不可重复读取;可能发生幻象读取   |\n   | SERIALZABLE      | 一个常量，指示阻止脏读、不可重复读和幻像读。              |\n\n##### 5.事务操作(xml声明式事务管理)\n\n   1. 在spring配置文件中进行配置\n\n      第一步：配置事务管理器\n\n      第二步：配置通知\n\n      第三步：配置切入点和切面\n\n      ```xml\n       <!--    创建事务管理器-->\n          <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <!--        注入数据源-->\n              <property name=\"dataSource\" ref=\"database\"></property>\n          </bean>\n          <!--    配置通知-->\n          <tx:advice id=\"txadvice\">\n              <!--        配置事务参数-->\n              <tx:attributes>\n                  <!--            指定那种规则的方法上面添加事务-->\n                  <tx:method name=\"accountMoney\" propagation=\"REQUIRED\"/>\n                  <!--            <tx:method name=\"account*\"/>-->\n              </tx:attributes>\n          </tx:advice>\n          <!--    配置切入点和切面-->\n          <aop:config>\n              <!--        配置切入点-->\n              <aop:pointcut id=\"pt\" expression=\"execution(* com.test.spring5.service.UserService.*(..))\"/>\n              <!--        配置切面-->\n              <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pt\"/>\n          </aop:config>\n      ```\n\n\n\n\n\n\n\n","slug":"Spring","published":1,"updated":"2023-08-10T09:20:25.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9r0017fswo67m80h16","content":"<h2 id=\"一、spring框架概述\"><a href=\"#一、spring框架概述\" class=\"headerlink\" title=\"一、spring框架概述\"></a>一、spring框架概述</h2><ol>\n<li>Spring是轻量级的开源的JavaEE框架</li>\n<li>Spring可以解决企业应用开发的复杂性</li>\n<li>Spring有两个核心部分：IOC和AOP<ol>\n<li>IOC：控制反转，把创建对象过程交给Spring进行管理</li>\n<li>AOP：面向切面，不修改源代码进行功能增强</li>\n</ol>\n</li>\n<li>Spring特点<ol>\n<li>方便解耦，简化开发</li>\n<li>AOP编程支持</li>\n<li>方便程序测试</li>\n<li>方便和其他框架进行整合</li>\n<li>方便进行事务操作</li>\n<li>降低API开发难度</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"二、IOC\"><a href=\"#二、IOC\" class=\"headerlink\" title=\"二、IOC\"></a>二、IOC</h2><h3 id=\"IOC-概念和原理\"><a href=\"#IOC-概念和原理\" class=\"headerlink\" title=\"IOC(概念和原理)\"></a>IOC(概念和原理)</h3><h5 id=\"一、什么是IOC\"><a href=\"#一、什么是IOC\" class=\"headerlink\" title=\"一、什么是IOC\"></a>一、什么是IOC</h5><ol>\n<li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</li>\n<li>使用IOC的目的：为了降低程序的耦合度</li>\n<li>Spring容器在初始化时先读取配置文件，根据配置文件或元数据，创建并组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</li>\n</ol>\n<h5 id=\"二、IOC底层原理\"><a href=\"#二、IOC底层原理\" class=\"headerlink\" title=\"二、IOC底层原理\"></a>二、IOC底层原理</h5><ol>\n<li><p>XML解析、工厂模式、反射</p>\n</li>\n<li><p>原始方式创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">\texecute()&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDao</span>();</span><br><span class=\"line\">\t\tdao.add();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工厂模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    execute()&#123;</span><br><span class=\"line\">        <span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> UserFactory.getDao();</span><br><span class=\"line\">        dao.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UserDao <span class=\"title function_\">getDao</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDao</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IOC解耦过程</p>\n<blockquote>\n<p>第一步：xml配置文件，配置创建的对象</p>\n<p><bean id=\"dao\" class=\"com.test.xxx.UserDao\"></bean></p>\n<p>第二步：有service类和到dao类，创建工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UserDao <span class=\"title function_\">getDao</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">classValue</span> <span class=\"operator\">=</span> class属性值；<span class=\"comment\">//1. xml解析</span></span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(classValue);<span class=\"comment\">//2.通过反射创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> （UserDao)clazz.newInstance() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n</li>\n</ol>\n<h5 id=\"三、IOC接口-BeanFactory\"><a href=\"#三、IOC接口-BeanFactory\" class=\"headerlink\" title=\"三、IOC接口(BeanFactory)\"></a>三、IOC接口(BeanFactory)</h5><ol>\n<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>\n</li>\n<li><p>Spring提供IOC容器实现两种方式:</p>\n<ol>\n<li><p>BeanFactory:IOC容器基本实现，是Spring内部的使用接口，不提供开发人员使用</p>\n<blockquote>\n<p>加载配置获取文件的时候不会创建对象，在获取&#x2F;使用对象的时候才去创建对象</p>\n<p>什么时候用什么时候创建对象</p>\n</blockquote>\n</li>\n<li><p>ApplicationContext：BeanFactory接口的子接口，提供更强大的功能，一般由开发人员进行使用</p>\n<blockquote>\n<p>加载配置文件的时候就会把配置文件中的对象进行创建</p>\n</blockquote>\n</li>\n<li><p>ApplicationContext的实现类</p>\n<p>FileSystemXmlApplicationContext:磁盘下配置文件路径</p>\n<p>ClassPathXmlApplicationContext：类路径下的配置文件</p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"四、IOC操作Bean管理\"><a href=\"#四、IOC操作Bean管理\" class=\"headerlink\" title=\"四、IOC操作Bean管理\"></a>四、IOC操作Bean管理</h5><ol>\n<li><strong>什么是Bean管理</strong><ol>\n<li>Bean管理</li>\n<li>Spring创建对象</li>\n<li>Spring注入属性</li>\n</ol>\n</li>\n<li><strong>Bean管理操作有两种方式</strong><ol>\n<li>IOC操作Bean管理(基于xml)</li>\n<li>IOC操作Bean管理(基于注解)</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"五、IOC操作Bean管理-基于xml\"><a href=\"#五、IOC操作Bean管理-基于xml\" class=\"headerlink\" title=\"五、IOC操作Bean管理(基于xml)\"></a>五、IOC操作Bean管理(基于xml)</h5><ol>\n<li><p><strong>基于xml方式创建对象</strong></p>\n<blockquote>\n<ol>\n<li><p>在spring配置文件中使用bean标签，标签里面添加对应的属性，就可以实现对象创建</p>\n<p><bean id=\"user\" class=\"com.xxx.xxx.User\"></bean></p>\n</li>\n<li><p>在bean标签有很多属性，介绍常用的属性：</p>\n<ol>\n<li>id属性：创建对象的唯一标识</li>\n<li>class属性：类全路径(包类路径)</li>\n</ol>\n</li>\n<li><p>创建对象时候，默认也是执行无参构造方法完成对象创建</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p><strong>基于xml方式注入属性</strong></p>\n<ol>\n<li>DI：依赖注入，就是注入属性</li>\n</ol>\n</li>\n<li><p><strong>第一种注入方式：使用set方法进行注入</strong></p>\n<ol>\n<li><p>创建类，定义属性和对应的set方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bName;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBName</span><span class=\"params\">(String bName)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bName = bName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件配置对象创建，配置属性注入</p>\n<blockquote>\n<p>set方法注入属性</p>\n<bean id=\"book\" class=\"com.xxx.xxx.Book\">\n\n<p>​\tname: 类里面的属性名称</p>\n<p>​\tvalue：向属性注入的值</p>\n<p>​\t<property name=\"bName\" value=\"红楼梦\"></property></p>\n</bean></blockquote>\n</li>\n</ol>\n</li>\n<li><p><strong>第二种注入方式：使用有参数构造进行注入</strong></p>\n<ol>\n<li><p>创建类，定义属性，创建属性对应有参数的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Orders</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String oName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">//有参数构造</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Orders</span><span class=\"params\">(String oName, String address)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oName = oName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件中进行配置</p>\n<blockquote>\n<p>有参数构造注入属性</p>\n<bean id=\"orders\" class=\"com.xxx.xxx.Orders\">\n\n<pre><code> &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt;\n</code></pre>\n<p>​\t <constructor-arg name=\"address\" value=\"China\"></constructor-arg></p>\n</bean></blockquote>\n</li>\n</ol>\n</li>\n<li><p><strong>p名称空间注入(简化xml配置)</strong></p>\n<p>底层还是采用set注入，简化xml配置文件多属性注入</p>\n<ol>\n<li><p><strong>使用p名称空间注入，可以简化基于xml配置方式</strong></p>\n<blockquote>\n<p>第一步添加p名称空间在配置文件中</p>\n<beans  xmls:p=\"https://www.springframework.org/schema/p\">\n\n<p>第二步 进行属性注入，在bean标签里面进行操作\t</p>\n<p>​\t<bean id=\"book\" class=\"com.xxx.xxx.Book\" p:bname=\"三国演义\" p:bauthor=\"罗贯中\" ></p>\n<p>​\t</bean></p>\n</beans></blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"六、IOC操作Bean管理-xml注入其他类型属性\"><a href=\"#六、IOC操作Bean管理-xml注入其他类型属性\" class=\"headerlink\" title=\"六、IOC操作Bean管理(xml注入其他类型属性)\"></a>六、IOC操作Bean管理(xml注入其他类型属性)</h5><ol>\n<li><p><strong>字面值</strong></p>\n<ol>\n<li><p>null值</p>\n<property name=\"address\">\n\n<p>​\t<null/></p>\n</property>\n</li>\n<li><p>属性值包含特殊符号</p>\n<property name=\"address\">\n\n<p>​\t<value><![CDATA[<<南京>>]]></value></p>\n</property></li>\n</ol>\n</li>\n<li><p>外部Bean注入</p>\n<blockquote>\n<p>第一步：创建两个类service类和dao类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dao update.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：在service调用dao类里面的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建UserDao类型属性，生成set方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add......&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        原始方式：</span></span><br><span class=\"line\"><span class=\"comment\">//        创建UserDao对象</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDaoImpl userDao = new UserDaoImpl();</span></span><br><span class=\"line\">        userDao.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第三步：在spting配置文件中进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    service和dao对象创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        注入UserDao对象--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        ref:创建的userDao对象bean标签--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDao&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDao&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userDao&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>内部Bean注入和级联赋值</p>\n<p>一对多关系：部门和员工，一个部门有多个员工，一个员工属于某一个部门，部门是一，员工是多</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 部门类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dept</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String dName;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setdName</span><span class=\"params\">(String dName)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dName = dName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 员工类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Emp</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String eName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dept dept;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDept</span><span class=\"params\">(Dept dept)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dept = dept;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">seteName</span><span class=\"params\">(String eName)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.eName = eName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGender</span><span class=\"params\">(String gender)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对spring配置文件中进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    内部bean--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;保安部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>级联赋值</p>\n<p>第一种写法：xml配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">&lt;!--    级联赋值--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        级联赋值--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;财务部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二种写法：生成get方法并修改配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    级联赋值--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        级联赋值--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept.dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;技术部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;财务部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"七、IOC操作Bean管理-xml注入集合属性\"><a href=\"#七、IOC操作Bean管理-xml注入集合属性\" class=\"headerlink\" title=\"七、IOC操作Bean管理(xml注入集合属性)\"></a>七、IOC操作Bean管理(xml注入集合属性)</h5><ol>\n<li><p>注入数组类型属性</p>\n</li>\n<li><p>注入list集合类型属性</p>\n</li>\n<li><p>注入Map集合类型属性</p>\n<p>第一步：定义一个类，定义数组、list集合、map集合、set集合属性，生成对应的set方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stu</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.数组类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] courses;</span><br><span class=\"line\">    <span class=\"comment\">//2.list集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">//3.map集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,String&gt; maps;</span><br><span class=\"line\">    <span class=\"comment\">//4.set集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; sets;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setList</span><span class=\"params\">(List&lt;String&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.list = list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaps</span><span class=\"params\">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maps = maps;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCourses</span><span class=\"params\">(String[] courses)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.courses = courses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：配置spring配置文件进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    集合类型属性注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;stu&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--      数组属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;courses&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>语文<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>数学<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>英语<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        list集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>李四<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>王五<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        map集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maps&quot;</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;Java&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;java基础&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;PHP&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;php&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        set集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sets&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>MySQL<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>Redis<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在集合里面设置对象类型的值</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建多个course对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;course1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;course2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;MyBatis&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--        注入list集合类型，值是对象--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;courseList&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;course1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;course2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把集合注入部分提取出来</p>\n<p>第一步：先在Spring配置文件中引入名称空间(util)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:util</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步：使用util标签完成list集合注入提取</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    1.提取list集合类型属性注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">util:list</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>红楼梦<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>西游记<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>易筋经<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">util:list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    2.提取list注入使用--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"八、IOC操作Bean管理-FactoryBean\"><a href=\"#八、IOC操作Bean管理-FactoryBean\" class=\"headerlink\" title=\"八、IOC操作Bean管理(FactoryBean)\"></a>八、IOC操作Bean管理(FactoryBean)</h5><ol>\n<li><p>Spring有两种类型的Bean，一种普通的bean，另外一种是工厂bean(FactoryBean)</p>\n<blockquote>\n<p>普通Bean：在配置文件中定义Bean类型就是返回类型</p>\n<p>工厂Bean：在配置文件定义Bean类型可以和返回类型不一样</p>\n</blockquote>\n<p>第一步：创建类，让这个类作为工厂Bean，实现接口FactoryBean</p>\n<p>第二步：实现接口里面的方法，在实现的方法中定义返回的Bean类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBean</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//返回对象实例</span></span><br><span class=\"line\">    <span class=\"comment\">//定义返回Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Course <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Course</span> <span class=\"variable\">course</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Course</span>();</span><br><span class=\"line\">        course.setCname(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> course;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//它是否是个单例</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FactoryBean.<span class=\"built_in\">super</span>.isSingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCollection3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean3.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Course</span> <span class=\"variable\">course</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;myBean&quot;</span>, Course.class);</span><br><span class=\"line\">        System.out.println(course);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.factorybean.MyBean&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>九、IOC操作Bean管理(Bean作用域)</p>\n<ol>\n<li><p>在Spring里面，设置创建Bean实例是单实例还是多实例</p>\n</li>\n<li><p>在Spring里面，默认情况下，bean是单实例对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCollection4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean4.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book1</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;book&quot;</span>, Book.class);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book2</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;book&quot;</span>, Book.class);</span><br><span class=\"line\">     <span class=\"comment\">//单实例输出对象相同</span></span><br><span class=\"line\">        System.out.println(book1);</span><br><span class=\"line\">        System.out.println(book2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何设置单实例还是多实例</p>\n<ol>\n<li><p>在Spring配置文件bean标签里面有属性(scope)用于设置单实例还是多实例</p>\n</li>\n<li><p>scope属性值</p>\n<p>第一个值：默认值，singleton，表示是单实例对象</p>\n<p>第二个值：prototype，表示是多实例对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Book&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>singleton和prototype区别</p>\n<blockquote>\n<ol>\n<li>singleton  单实例，prototype  多实例</li>\n<li>设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象。设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十、IOC操作Bean管理-bean生命周期\"><a href=\"#十、IOC操作Bean管理-bean生命周期\" class=\"headerlink\" title=\"十、IOC操作Bean管理(bean生命周期)\"></a>十、IOC操作Bean管理(bean生命周期)</h5><ol>\n<li><p>生命周期</p>\n<p>从对象的创建到对象销毁的过程</p>\n</li>\n<li><p>bean的生命周期</p>\n<ol>\n<li>通过构造器创建bean实例(无参构造)</li>\n<li>为bean里面的属性设置值和对其他bean的引用(调用set方法)</li>\n<li>调用bean的初始化的方法(需要进行配置)</li>\n<li>bean可以使用了(对象获取到了)</li>\n<li>当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Orders</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//无参构造</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Orders</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第一步：执行无参数构造创建Bean实例&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String oname;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setOname</span><span class=\"params\">(String oname)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oname = oname;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第二步：调用set方法设置属性值&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建执行的初始化的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第三步：执行初始化的方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建执行的销毁的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroyMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第五步：执行销毁的方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;orders&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Orders&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;initMethod&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;oname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;手机&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean5.xml&quot;</span>);</span><br><span class=\"line\">       <span class=\"type\">Orders</span> <span class=\"variable\">orders</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;orders&quot;</span>, Orders.class);</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;第四步：获取到创建bean实例对象&quot;</span>);</span><br><span class=\"line\">       System.out.println(orders);</span><br><span class=\"line\">       <span class=\"comment\">//手动让bean实例销毁</span></span><br><span class=\"line\">       context.close();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>bean的后置处理器</p>\n<ol>\n<li><p>通过构造器创建bean实例(无参构造)</p>\n</li>\n<li><p>为bean里面的属性设置值和对其他bean的引用(调用set方法)</p>\n</li>\n<li><p>把bean实例传递bean后置处理器的方法      —–postProcessBeforeInitialization</p>\n</li>\n<li><p>调用bean的初始化的方法(需要进行配置)</p>\n</li>\n<li><p>把bean实例传递bean后置处理器的方法      —–postProcessAfterInitialization</p>\n</li>\n<li><p>bean可以使用了(对象获取到了)</p>\n</li>\n<li><p>当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)</p>\n<p>后置处理器  例：</p>\n<ol>\n<li>创建类，实现接口BeanPostProcessor，创建后置处理器</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBeanPost</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanPostProcessor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在初始化之前执行的方法-------后置处理器&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在初始化之后执行的方法------后置处理器&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    配置后置处理器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBeanPost&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十一、IOC操作Bean管理-xml自动装配\"><a href=\"#十一、IOC操作Bean管理-xml自动装配\" class=\"headerlink\" title=\"十一、IOC操作Bean管理(xml自动装配)\"></a>十一、IOC操作Bean管理(xml自动装配)</h5><p>​\t根据指定装配规则(属性名称或者属性类型)，spring自动将匹配的属性值进行注入</p>\n<ol>\n<li><p>根据属性的名称自动注入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    实现自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    bean标签中有个属性autowire，配置自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Emp&quot;</span> <span class=\"attr\">autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据属性的类型自动注入(相同类型的属性不能定义多个)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    实现自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    bean标签中有个属性autowire，配置自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Emp&quot;</span> <span class=\"attr\">autowire</span>=<span class=\"string\">&quot;byType&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"十二、IOC操作Bean管理-引入外部属性文件\"><a href=\"#十二、IOC操作Bean管理-引入外部属性文件\" class=\"headerlink\" title=\"十二、IOC操作Bean管理(引入外部属性文件)\"></a>十二、IOC操作Bean管理(引入外部属性文件)</h5><ol>\n<li><p>直接配置数据库信息</p>\n<ol>\n<li>配置德鲁伊连接池</li>\n<li>引入德鲁伊连接池依赖jar包</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    配置连接池--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入外部属性文件配置数据库连接池</p>\n<ol>\n<li><p>创建外部属性文件，properties格式文件，写数据库信息</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">prop.driverClassName</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">prop.url</span>=<span class=\"string\">jdbc:mysql://localhost:3306/userDb</span></span><br><span class=\"line\"><span class=\"attr\">prop.username</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">prop.password</span>=<span class=\"string\">root</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把外部properties属性文件引入spring配置文件中</p>\n<ol>\n<li><p>引入context名称空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置引入外部文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    引入外部的属性文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.driverClassName&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.username&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十三、IOC操作Bean管理-基于注解方式\"><a href=\"#十三、IOC操作Bean管理-基于注解方式\" class=\"headerlink\" title=\"十三、IOC操作Bean管理(基于注解方式)\"></a>十三、IOC操作Bean管理(基于注解方式)</h5><ol>\n<li><p>什么是注解</p>\n<p>注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值…)</p>\n<p>使用注解，注解可以作用在类上面，方法上面，属性上面</p>\n<p>使用注解的目的：简化xml配置</p>\n</li>\n<li><p>Spring针对Bean管理(创建对象)中创建对象提供注解</p>\n<ol>\n<li>@Component</li>\n<li>@Service</li>\n<li>@Controller</li>\n<li>@Repository</li>\n</ol>\n<p>上面的四个注解功能是一样的，都是用来创建Bean的实例</p>\n</li>\n<li><p>基于注解方式实现对象创建</p>\n<ol>\n<li>第一步引入依赖</li>\n<li>开启组件扫描</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    开启组件扫描</span></span><br><span class=\"line\"><span class=\"comment\">    1.扫描多个包，多个包之间使用逗号隔开</span></span><br><span class=\"line\"><span class=\"comment\">    2.扫描包上层目录</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建类，在类上面添加创建对象得注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解里面value属性值可以省略</span></span><br><span class=\"line\"><span class=\"comment\">//默认值是类名称，首字母小写</span></span><br><span class=\"line\"><span class=\"meta\">@Service(value = &quot;userService&quot;)</span><span class=\"comment\">//类似 &lt;bean id=&quot;userService&quot; class=&quot;...&quot;&gt;&lt;/bean&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>开启组件扫描细节配置</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    示例1</span></span><br><span class=\"line\"><span class=\"comment\">    use-default-filters=&quot;false&quot;   表示现在不使用默认的filters，自己配置filter</span></span><br><span class=\"line\"><span class=\"comment\">    context:include-filter        扫描那些内容</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">use-default-filters</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    示例2</span></span><br><span class=\"line\"><span class=\"comment\">    context:exclude-filter     设置那些内容不进行扫描</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"十四、IOC操作Bean管理-基于注解属性注入\"><a href=\"#十四、IOC操作Bean管理-基于注解属性注入\" class=\"headerlink\" title=\"十四、IOC操作Bean管理(基于注解属性注入)\"></a>十四、IOC操作Bean管理(基于注解属性注入)</h5><ol>\n<li><p><strong>@Autowired</strong>：根据属性类型进行自动装配</p>\n<p>例：</p>\n<p>第一步 吧service和dao对象创建，在service和dao类添加创建对象注解</p>\n<p>第二步 在service注入dao对象，在service类添加dao类属性，在属性上面使用注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义dao类型属性</span></span><br><span class=\"line\">    <span class=\"comment\">//不需要添加set方法</span></span><br><span class=\"line\">    <span class=\"comment\">//添加注入属性的注解</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p><strong>@Qualifier</strong>：根据属性名称进行注入</p>\n<p>@Qualifier需要配合@Autowired注解进行使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository(value = &quot;userDapImpl1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;dao  add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>  <span class=\"comment\">//根据类型进行注入</span></span><br><span class=\"line\">   <span class=\"meta\">@Qualifier(value = &quot;userDapImpl1&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">       userDao.add();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>@Resource</strong>：可以根据类型注入，也可以根据名称注入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@Resource( name = &quot;userDapImpl1&quot;)</span>  <span class=\"comment\">//根据名称进行注入</span></span><br><span class=\"line\"><span class=\"meta\">@Resource</span>   <span class=\"comment\">//根据类型注入 </span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>@Value</strong>：注入普通类型属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value(value = &quot;Tom&quot;)</span>  <span class=\"comment\">//普通类型属性注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service-name-&quot;</span>+name);</span><br><span class=\"line\">        userDao.add();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>纯注解开发</p>\n<ol>\n<li><p>创建配置类，替代xml配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>   <span class=\"comment\">//作为配置类，替代xml配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.test.spring5&quot;&#125;)</span> <span class=\"comment\">//开启</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringConfig</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testService2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//加载配置类</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;userService&quot;</span>, UserService.class);</span><br><span class=\"line\">        System.out.println(userService);</span><br><span class=\"line\">        userService.add();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"三、AOP\"><a href=\"#三、AOP\" class=\"headerlink\" title=\"三、AOP\"></a>三、AOP</h2><h4 id=\"一、什么是AOP-概念\"><a href=\"#一、什么是AOP-概念\" class=\"headerlink\" title=\"一、什么是AOP(概念)\"></a>一、什么是AOP(概念)</h4><p>​\tAOP为Aspect Oriented Programming 面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率</p>\n<p>​\t<code>不通过修改源代码的方式添加新功能</code></p>\n<p>​\t通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p>\n<h4 id=\"二、AOP底层原理\"><a href=\"#二、AOP底层原理\" class=\"headerlink\" title=\"二、AOP底层原理\"></a>二、AOP底层原理</h4><ol>\n<li>AOP底层使用动态代理<ol>\n<li>第一种有接口的情况(JDK动态代理)</li>\n<li>第二种没有接口的情况(CGLib动态代理)</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-1、AOP底层原理-JDK动态代理\"><a href=\"#2-1、AOP底层原理-JDK动态代理\" class=\"headerlink\" title=\"2.1、AOP底层原理(JDK动态代理)\"></a>2.1、AOP底层原理(JDK动态代理)</h5><ol>\n<li><p>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p>\n<p>java.lang.reflect.Proxy</p>\n<p>主要方法：</p>\n<table>\n<thead>\n<tr>\n<th>修饰符和类型</th>\n<th>方法与描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static Object</td>\n<td>newProxyInstance（）返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</td>\n</tr>\n</tbody></table>\n<p>里面有三个参数</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ClassLoader loader</td>\n<td>类加载器</td>\n</tr>\n<tr>\n<td>Class&lt;?&gt;[] interfaces</td>\n<td>增强方法所在类，这个类的接口，支持多个接口</td>\n</tr>\n<tr>\n<td>InvocationHandler h</td>\n<td>实现这个接口，创建代理对象，写增强的方法</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>编写JDK动态代理代码</p>\n<ol>\n<li><p>创建接口，定义方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">update</span><span class=\"params\">(String id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建接口实现类，实现方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">update</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Proxy类创建接口代理对象(增强)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建接口实现类代理对象</span></span><br><span class=\"line\">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class=\"line\"><span class=\"comment\">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            @Override</span></span><br><span class=\"line\"><span class=\"comment\">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                return null;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;);</span></span><br><span class=\"line\">        <span class=\"type\">UserDaoImpl</span> <span class=\"variable\">userDao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDaoImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class=\"keyword\">new</span> <span class=\"title class_\">UserDaoProxy</span>(userDao));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dao.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;result:&quot;</span>+result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建代理对象代码</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class=\"line\">    <span class=\"comment\">//有参数的构造传递</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserDaoProxy</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对象被创建就会调用invoke方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//增强的逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">//方法之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行之前......&quot;</span>+method.getName()+<span class=\"string\">&quot;  :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class=\"line\">        <span class=\"comment\">//被增强的方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> method.invoke(obj, args);</span><br><span class=\"line\">        <span class=\"comment\">//方法之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行之后......&quot;</span>+ obj);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"三、AOP-术语\"><a href=\"#三、AOP-术语\" class=\"headerlink\" title=\"三、AOP(术语)\"></a>三、AOP(术语)</h4><p>​\t术语就是例如，汽车发动机又叫引擎</p>\n<ol>\n<li><p>连接点</p>\n<blockquote>\n<p>类里面那些方法可以被增强，这些方法称为连接点</p>\n</blockquote>\n</li>\n<li><p>切入点</p>\n<blockquote>\n<p>实际被真正增强的方法，称为切入点</p>\n</blockquote>\n</li>\n<li><p>通知(增强)</p>\n<blockquote>\n<ol>\n<li>实际增强的逻辑部分称为通知(增强)</li>\n<li>通知有多种类型<ol>\n<li>前置通知：被增强的原始方法之前执行的逻辑</li>\n<li>后置通知：被增强的原始方法之后执行的逻辑</li>\n<li>环绕通知：被增强的原始方法之前后执行的逻辑</li>\n<li>异常通知：被增强的原始方法出现异常后执行的逻辑</li>\n<li>最终通知：如同try~catch后面的finally类似</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前置通知</span></span><br><span class=\"line\">  <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">  <span class=\"meta\">@Before(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//后置通知(返回值通知)</span></span><br><span class=\"line\">  <span class=\"meta\">@AfterReturning(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//环绕通知</span></span><br><span class=\"line\">  <span class=\"meta\">@Around(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//异常通知</span></span><br><span class=\"line\">  <span class=\"meta\">@AfterThrowing(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//最终通知</span></span><br><span class=\"line\">  <span class=\"meta\">@After(value = &quot;execution()&quot;)</span>  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切面</p>\n<blockquote>\n<p>把通知应用到切入点过程，是一个动作</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"四、AOP操作\"><a href=\"#四、AOP操作\" class=\"headerlink\" title=\"四、AOP操作\"></a>四、AOP操作</h4><h5 id=\"4-1-准备工作\"><a href=\"#4-1-准备工作\" class=\"headerlink\" title=\"4.1 准备工作\"></a>4.1 准备工作</h5><ol>\n<li><p>Spring框架中一般都是基于AspectJ实现AOP操作</p>\n<ol>\n<li><p>什么是AspectJ</p>\n<blockquote>\n<p>AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>基于<code>AspectJ</code>实现AOP操作</p>\n<ol>\n<li>基于xml配置文件</li>\n<li>基于注解方式使用(常用)</li>\n</ol>\n</li>\n<li><p>在项目工程里面引入AOP相关依赖</p>\n<blockquote>\n<p>spring-aspects-5.2.6.RELEASE.jar<br>spring-aop-5.2.6.RELEASE.jar<br>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar<br>com.springsource.org.aopalliance-1.0.0.jar<br>com.springsource.net.sf.cglib-2.2.0.jar</p>\n</blockquote>\n</li>\n<li><p>切入点表达式</p>\n<blockquote>\n<ol>\n<li><p>切入点表达式作用：知道对那个类里面的那个方法进行增强</p>\n</li>\n<li><p>语法结构：</p>\n<p>excution([权限修饰符][返回类型][类的全路径][方法名称]([参数列表]))</p>\n<p>举例1：对com.test.dao.BoolDao类里面的add进行增强</p>\n<p><code>xcution(* com.test.dao.BoolDao.add(..));</code></p>\n<p>举例2：对com.test.dao.BoolDao类里面的所有方法增强</p>\n<p><code>excution(* com.test.dao.BoolDao.*(..));</code></p>\n<p>举例3：对com.test.dao.BoolDao类里面的所有类和所有类中的所有方法增强</p>\n<p><code>excution(* com.test.dao.\\*.*(..));</code></p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"4-2-AOP操作-AspectJ注解\"><a href=\"#4-2-AOP操作-AspectJ注解\" class=\"headerlink\" title=\"4.2 AOP操作(AspectJ注解)\"></a>4.2 AOP操作(AspectJ注解)</h5><ol>\n<li><p>创建类，在类里面定义方法，被增强类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被增强的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;User add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建增强类(编写增加的逻辑)</p>\n<p>在增强的类里面，创建不同的方法，让不同的方法代表不同的通知类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//增强的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行通知的配置</p>\n<ol>\n<li><p>在spring配置文件中，开启注解扫描</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    开启注解扫描--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5.aopanno&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解创建User和UserProxy对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;User add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在增强类上面添加注解@Aspect</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>  <span class=\"comment\">//生成代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件中开启生成代理对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启Aspect生成代理对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置不同类型的通知</p>\n<p>在我增强类的里面，作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//增强的类</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>  <span class=\"comment\">//生成代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//后置通知(返回值通知)</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterReturning</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AfterReturning......   后置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//环绕通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;环绕之前......&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//被增强的方法执行</span></span><br><span class=\"line\">        proceedingJoinPoint.proceed();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;环绕之后......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异常通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterThrowing</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AfterThrowing......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最终通知</span></span><br><span class=\"line\">    <span class=\"meta\">@After(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">after</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After......  最终通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同切入点进行抽取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相同切入点抽取</span></span><br><span class=\"line\">   <span class=\"meta\">@Pointcut(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pointDemo</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">   <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">   <span class=\"meta\">@Before(value = &quot;pointDemo()&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有多个增强类对同一个方法增强，设置增强类优先级</p>\n<p>在增强类上面添加注解@Order(值)，数字类型的值，数值越小优先级越高</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span>  <span class=\"comment\">//优先级</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PersonProxy</span> &#123;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完全使用注解开发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置类不需要创建xml配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.test.spring5&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigAop</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"4-3-AOP操作-AspectJ配置文件\"><a href=\"#4-3-AOP操作-AspectJ配置文件\" class=\"headerlink\" title=\"4.3 AOP操作(AspectJ配置文件)\"></a>4.3 AOP操作(AspectJ配置文件)</h5><ol>\n<li><p>创建两个类，增强类和被增强类，创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buy</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;buy......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中创建两个类对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建两个类的对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.aopxml.Book&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bookProxy&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中配置切入点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--    创建两个类的对象--&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">&quot;book&quot;</span> class=<span class=\"string\">&quot;com.test.spring5.aopxml.Book&quot;</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">&quot;bookProxy&quot;</span> class=<span class=\"string\">&quot;com.test.spring5.aopxml.BookProxy&quot;</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;!--    配置AOP增强--&gt;</span><br><span class=\"line\">    &lt;aop:config&gt;</span><br><span class=\"line\">&lt;!--        切入点--&gt;</span><br><span class=\"line\">        &lt;aop:pointcut id=<span class=\"string\">&quot;p&quot;</span> expression=<span class=\"string\">&quot;execution(* com.test.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;!--        配置切面--&gt;</span><br><span class=\"line\">        &lt;aop:aspect ref=<span class=\"string\">&quot;bookProxy&quot;</span>&gt;</span><br><span class=\"line\">&lt;!--            增强作用在具体的方法上--&gt;</span><br><span class=\"line\">            &lt;aop:before method=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;p&quot;</span>/&gt;</span><br><span class=\"line\">        &lt;/aop:aspect&gt;</span><br><span class=\"line\">    &lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、JDBC-Templatek\"><a href=\"#四、JDBC-Templatek\" class=\"headerlink\" title=\"四、JDBC Templatek\"></a>四、JDBC Templatek</h2><h4 id=\"一、概念和准备\"><a href=\"#一、概念和准备\" class=\"headerlink\" title=\"一、概念和准备\"></a>一、概念和准备</h4><ol>\n<li><p>什么是JDBCTemplatek</p>\n<p>Spring框架对JDBC进行封装，使用JDBCTemplatek方便实现对数据库操作</p>\n</li>\n<li><p>准备工作</p>\n<ol>\n<li><p>引入相关的依赖</p>\n<blockquote>\n<p>spring-tx-5.2.6.RELEASE.jar<br>spring-orm-5.2.6.RELEASE.jar<br>spring-jdbc-5.2.6.RELEASE.jar<br>druid-1.1.9.jar<br>mysql-connector-java-8.0.28.jar</p>\n</blockquote>\n</li>\n<li><p>在spring配置文件配置数据库连接池</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    数据库连接池--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;database&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;close&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql:///user_db&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置JDBCTemplate对象,注入DataSource</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建JDBCTemplate对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;jdbcTemplate&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        注入dataSource--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Service类，创建dao类，在dao注入jdbcTemlate对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启组件扫描--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入dao</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookDao bookDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BookDao</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入jdbcTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"二、JDBCTemplate操作数据库\"><a href=\"#二、JDBCTemplate操作数据库\" class=\"headerlink\" title=\"二、JDBCTemplate操作数据库\"></a>二、JDBCTemplate操作数据库</h4><h5 id=\"一、添加\"><a href=\"#一、添加\" class=\"headerlink\" title=\"一、添加\"></a>一、添加</h5><ol>\n<li><p>对应数据库创建实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String ustatus;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserId</span><span class=\"params\">(String userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写service和dao</p>\n<ol>\n<li><p>在dao层进行数据库添加操作</p>\n</li>\n<li><p>调用jdbctemplate对象里面的update方法实现添加操作</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String  SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>Object…  args</td>\n<td>可变参数，设置sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BookDao</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入jdbcTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"comment\">//添加的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(Book book)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法实现</span></span><br><span class=\"line\"><span class=\"comment\">//        int rows = jdbcTemplate.update(sql, book.getUserId(), book.getUsername(), book.getUstatus());</span></span><br><span class=\"line\">        Object[] args = &#123; book.getUserId(), book.getUsername(), book.getUstatus()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql,args);</span><br><span class=\"line\">        System.out.println(rows);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBook</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testJDBCTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean1.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BookService</span> <span class=\"variable\">bookService</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;bookService&quot;</span>, BookService.class);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        book.setUserId(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        book.setUsername(<span class=\"string\">&quot;红露面&quot;</span>);</span><br><span class=\"line\">        book.setUstatus(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        bookService.addBook(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"二、修改\"><a href=\"#二、修改\" class=\"headerlink\" title=\"二、修改\"></a>二、修改</h5><ol>\n<li><p>BookService添加修改方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现修改方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        book.setUserId(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        book.setUsername(<span class=\"string\">&quot;许仙&quot;</span>);</span><br><span class=\"line\">        book.setUstatus(<span class=\"string\">&quot;AAAA&quot;</span>);</span><br><span class=\"line\">        bookService.updateBook(book);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"三、删除\"><a href=\"#三、删除\" class=\"headerlink\" title=\"三、删除\"></a>三、删除</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        bookService.deleteBook(<span class=\"string\">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"四、查询\"><a href=\"#四、查询\" class=\"headerlink\" title=\"四、查询\"></a>四、查询</h5><ol>\n<li><p><strong>查询返回某个值</strong></p>\n<ol>\n<li><p>查询表里面有多少条记录，返回某个值</p>\n</li>\n<li><p>使用jdbcTemplate实现返回某个值代码</p>\n<p>queryForObject</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String  SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>Class<T> requiredType</td>\n<td>返回类型Class</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">selectCount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select count(*) from t_book&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> bookService.findCount();</span><br><span class=\"line\">       System.out.println(count);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>查询返回对象</strong></p>\n<ol>\n<li><p>场景：查询图书的详情页面</p>\n</li>\n<li><p>JDBCTemplate实现查询返回对象</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>RowMapper<T> rowMapper</td>\n<td>rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装</td>\n</tr>\n<tr>\n<td>object… args</td>\n<td>sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Book <span class=\"title function_\">findBookInfo</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> jdbcTemplate.queryForObject(sql, <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class), id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> book;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回对象</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">one</span> <span class=\"operator\">=</span> bookService.findOne(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        System.out.println(one);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>查询返回集合</strong></p>\n<ol>\n<li><p>场景：查询图书列表分页…</p>\n</li>\n<li><p>调用jdbcTemplate方法实现查询返回集合</p>\n<p>query()</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>RowMapper<T> rowMapper</td>\n<td>rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装</td>\n</tr>\n<tr>\n<td>object… args</td>\n<td>sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title function_\">findALlBook</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from t_book&quot;</span>;</span><br><span class=\"line\">        List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bookList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回集合</span></span><br><span class=\"line\">        List&lt;Book&gt; all = bookService.findAll();</span><br><span class=\"line\">        System.out.println(all);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"五、批量操作\"><a href=\"#五、批量操作\" class=\"headerlink\" title=\"五、批量操作\"></a>五、批量操作</h5><ol>\n<li><p>批量操作：操作表里面多条记录</p>\n</li>\n<li><p>jdbcTemplate实现批量添加的操作</p>\n<p>batchUpdate(String sql,List&lt;Object[]&gt; barchArgs)</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>List&lt;object[]&gt; barchArgs</td>\n<td>list集合添加的多条记录数据</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量添加</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchAddBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(Arrays.toString(ints));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量添加</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;张三&quot;</span>,<span class=\"string\">&quot;qwe&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;李四&quot;</span>,<span class=\"string\">&quot;qwerty&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o3 = &#123;<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;王五&quot;</span>,<span class=\"string\">&quot;ewq&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        list.add(o3);</span><br><span class=\"line\">        bookService.batchAdd(list);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jdbcTemplate实现批量修改的操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchUpdateBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(Arrays.toString(ints));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量修改</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;红楼梦&quot;</span>,<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;1&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;西游记&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>,<span class=\"string\">&quot;2&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o3 = &#123;<span class=\"string\">&quot;水浒传&quot;</span>,<span class=\"string\">&quot;ccc&quot;</span>,<span class=\"string\">&quot;3&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        list.add(o3);</span><br><span class=\"line\">        bookService.batchUpdate(list);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>批量删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量删除</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchDeleteBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(ints);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量删除</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;4&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;5&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        bookService.batchUpdate(list);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"五、事务管理\"><a href=\"#五、事务管理\" class=\"headerlink\" title=\"五、事务管理\"></a>五、事务管理</h2><h4 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h4><ol>\n<li>事务是数据库操作的最基本单元，逻辑上一组操作，要么都成功，要么失败一个其他所有操作都是失败</li>\n<li>典型场景：银行转账</li>\n<li>事务四个特性(ACID)<ol>\n<li>原子性</li>\n<li>一致性</li>\n<li>隔离性</li>\n<li>持久性</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"二、事务操作\"><a href=\"#二、事务操作\" class=\"headerlink\" title=\"二、事务操作\"></a>二、事务操作</h4><h5 id=\"1-搭建事务操作环境\"><a href=\"#1-搭建事务操作环境\" class=\"headerlink\" title=\"1.搭建事务操作环境\"></a>1.搭建事务操作环境</h5><ol>\n<li><p>创建数据库表，添加记录</p>\n</li>\n<li><p>创建service，创建dao，完成对象创建和注入关系</p>\n<p>service注入dao，在dao注入jdbcTemplate，在jdbcTemplate注入DataSource</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入dao</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在dao创建两个方法：多钱和少钱方法，在service创建方法(转账的方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class=\"line\">        jdbcTemplate.update(sql, <span class=\"number\">100</span>, <span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reduceMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class=\"line\">        jdbcTemplate.update(sql, <span class=\"number\">100</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//转账方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accountMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        userDao.reduceMoney();</span><br><span class=\"line\">        userDao.addMoney();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面代码，正常执行没有问题，但是代码如果产生异常，会有问题</p>\n<p>问题：张三扣除100块，而李四并没有收到100块</p>\n<p>以上问题问题解决方案，使用事务进行解决，要么一起成功要么一起失败</p>\n<blockquote>\n<p>事务的操作过程：</p>\n<ol>\n<li>开启事务</li>\n<li>进行业务操作(try~catch捕获并处理异常)</li>\n<li>没有异常，提交事务</li>\n<li>出现了异常，事务回滚</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"2-事务操作-spring事务管理介绍\"><a href=\"#2-事务操作-spring事务管理介绍\" class=\"headerlink\" title=\"2.事务操作(spring事务管理介绍)\"></a>2.事务操作(spring事务管理介绍)</h5><ol>\n<li><p>事务添加到JavaEE三层结构里面Service层(业务逻辑层)</p>\n</li>\n<li><p>在Spring进行事务管理操作</p>\n<blockquote>\n<p>有两种方式：编程式事务管理和声明式事务管理(使用)</p>\n</blockquote>\n</li>\n<li><p>声明式事务管理</p>\n<ol>\n<li>基于注解方式</li>\n<li>基于xml配置文件方式</li>\n</ol>\n</li>\n<li><p>在Spring进行声明式事务管理，底层使用AOP原理</p>\n</li>\n<li><p>Spring事务管理API</p>\n<ol>\n<li><p>提供了一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类</p>\n<p><code>PlatformTransactionManager</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-事务操作-注解声明式事务管理\"><a href=\"#3-事务操作-注解声明式事务管理\" class=\"headerlink\" title=\"3.事务操作(注解声明式事务管理)\"></a>3.事务操作(注解声明式事务管理)</h5><ol>\n<li><p>在Spring配置文件配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建事务管理器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        注入数据源--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件,开启事务注解</p>\n<p>在spring配置文件引入名称空间tx</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启事务注解--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在service类上面添加事务注解</p>\n<p>@Transactional,这个注解添加到类上面,也可以添加到方法上面</p>\n<p>添加在类上,表示这个类中所有方法都添加了事务</p>\n<p>添加到方法上,只为该方法提供事务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"4-事务操作-声明式事务管理参数\"><a href=\"#4-事务操作-声明式事务管理参数\" class=\"headerlink\" title=\"4.事务操作(声明式事务管理参数)\"></a>4.事务操作(声明式事务管理参数)</h5><table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Propagation propagation()</td>\n<td>事务的传播行为</td>\n</tr>\n<tr>\n<td>Isolation isolation()</td>\n<td>事务的隔离级别</td>\n</tr>\n<tr>\n<td>int timeout()</td>\n<td>事务的超时时间</td>\n</tr>\n<tr>\n<td>boolearn readOnly</td>\n<td>是否只读</td>\n</tr>\n<tr>\n<td>rollbackFor</td>\n<td>回滚</td>\n</tr>\n<tr>\n<td>noRollbackFor</td>\n<td>不回滚</td>\n</tr>\n</tbody></table>\n<p>   <strong><code>propagation()</code></strong>:事务的传播行为</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MANDATORY</td>\n<td>支持当前事务，如果不存在则引发异常。</td>\n</tr>\n<tr>\n<td>NESTED</td>\n<td>如果当前事务存在，则在嵌套事务内执行，否则行为类似于 <code>REQUIRED</code></td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>以非事务方式执行，如果存在事务则引发异常。</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>以非事务方式执行，如果存在当前事务，则挂起当前事务。</td>\n</tr>\n<tr>\n<td>REQUIRED</td>\n<td>支持当前事务，如果不存在则创建新事务。</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>创建一个新事务，如果当前事务存在，则挂起当前事务。</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>支持当前事务，如果不存在，则以非事务方式执行。</td>\n</tr>\n</tbody></table>\n<p>   <strong><code>isolation</code></strong>:事务的隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFAULT</td>\n<td>使用基础数据存储区的默认隔离级别。</td>\n</tr>\n<tr>\n<td>READ_COMMITTED</td>\n<td>一个常量，指示阻止脏读;可能发生不可重复的读取和幻像读取。</td>\n</tr>\n<tr>\n<td>READ_UNCOMMITTED</td>\n<td>一个常量，指示可能发生脏读、不可重复读和幻像读。</td>\n</tr>\n<tr>\n<td>REPEATABLF_READ</td>\n<td>一个常量，指示阻止脏读取和不可重复读取;可能发生幻象读取</td>\n</tr>\n<tr>\n<td>SERIALZABLE</td>\n<td>一个常量，指示阻止脏读、不可重复读和幻像读。</td>\n</tr>\n</tbody></table>\n<h5 id=\"5-事务操作-xml声明式事务管理\"><a href=\"#5-事务操作-xml声明式事务管理\" class=\"headerlink\" title=\"5.事务操作(xml声明式事务管理)\"></a>5.事务操作(xml声明式事务管理)</h5><ol>\n<li><p>在spring配置文件中进行配置</p>\n<p>第一步：配置事务管理器</p>\n<p>第二步：配置通知</p>\n<p>第三步：配置切入点和切面</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建事务管理器--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        注入数据源--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!--    配置通知--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txadvice&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置事务参数--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">           <span class=\"comment\">&lt;!--            指定那种规则的方法上面添加事务--&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;accountMoney&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">           <span class=\"comment\">&lt;!--            &lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!--    配置切入点和切面--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置切入点--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pt&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;execution(* com.test.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置切面--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">&quot;txadvice&quot;</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">&quot;pt&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"一、spring框架概述\"><a href=\"#一、spring框架概述\" class=\"headerlink\" title=\"一、spring框架概述\"></a>一、spring框架概述</h2><ol>\n<li>Spring是轻量级的开源的JavaEE框架</li>\n<li>Spring可以解决企业应用开发的复杂性</li>\n<li>Spring有两个核心部分：IOC和AOP<ol>\n<li>IOC：控制反转，把创建对象过程交给Spring进行管理</li>\n<li>AOP：面向切面，不修改源代码进行功能增强</li>\n</ol>\n</li>\n<li>Spring特点<ol>\n<li>方便解耦，简化开发</li>\n<li>AOP编程支持</li>\n<li>方便程序测试</li>\n<li>方便和其他框架进行整合</li>\n<li>方便进行事务操作</li>\n<li>降低API开发难度</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"二、IOC\"><a href=\"#二、IOC\" class=\"headerlink\" title=\"二、IOC\"></a>二、IOC</h2><h3 id=\"IOC-概念和原理\"><a href=\"#IOC-概念和原理\" class=\"headerlink\" title=\"IOC(概念和原理)\"></a>IOC(概念和原理)</h3><h5 id=\"一、什么是IOC\"><a href=\"#一、什么是IOC\" class=\"headerlink\" title=\"一、什么是IOC\"></a>一、什么是IOC</h5><ol>\n<li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</li>\n<li>使用IOC的目的：为了降低程序的耦合度</li>\n<li>Spring容器在初始化时先读取配置文件，根据配置文件或元数据，创建并组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</li>\n</ol>\n<h5 id=\"二、IOC底层原理\"><a href=\"#二、IOC底层原理\" class=\"headerlink\" title=\"二、IOC底层原理\"></a>二、IOC底层原理</h5><ol>\n<li><p>XML解析、工厂模式、反射</p>\n</li>\n<li><p>原始方式创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">\texecute()&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDao</span>();</span><br><span class=\"line\">\t\tdao.add();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>工厂模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    execute()&#123;</span><br><span class=\"line\">        <span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> UserFactory.getDao();</span><br><span class=\"line\">        dao.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UserDao <span class=\"title function_\">getDao</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDao</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IOC解耦过程</p>\n<blockquote>\n<p>第一步：xml配置文件，配置创建的对象</p>\n<p><bean id=\"dao\" class=\"com.test.xxx.UserDao\"></bean></p>\n<p>第二步：有service类和到dao类，创建工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UserDao <span class=\"title function_\">getDao</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">classValue</span> <span class=\"operator\">=</span> class属性值；<span class=\"comment\">//1. xml解析</span></span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(classValue);<span class=\"comment\">//2.通过反射创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> （UserDao)clazz.newInstance() </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n</li>\n</ol>\n<h5 id=\"三、IOC接口-BeanFactory\"><a href=\"#三、IOC接口-BeanFactory\" class=\"headerlink\" title=\"三、IOC接口(BeanFactory)\"></a>三、IOC接口(BeanFactory)</h5><ol>\n<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>\n</li>\n<li><p>Spring提供IOC容器实现两种方式:</p>\n<ol>\n<li><p>BeanFactory:IOC容器基本实现，是Spring内部的使用接口，不提供开发人员使用</p>\n<blockquote>\n<p>加载配置获取文件的时候不会创建对象，在获取&#x2F;使用对象的时候才去创建对象</p>\n<p>什么时候用什么时候创建对象</p>\n</blockquote>\n</li>\n<li><p>ApplicationContext：BeanFactory接口的子接口，提供更强大的功能，一般由开发人员进行使用</p>\n<blockquote>\n<p>加载配置文件的时候就会把配置文件中的对象进行创建</p>\n</blockquote>\n</li>\n<li><p>ApplicationContext的实现类</p>\n<p>FileSystemXmlApplicationContext:磁盘下配置文件路径</p>\n<p>ClassPathXmlApplicationContext：类路径下的配置文件</p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"四、IOC操作Bean管理\"><a href=\"#四、IOC操作Bean管理\" class=\"headerlink\" title=\"四、IOC操作Bean管理\"></a>四、IOC操作Bean管理</h5><ol>\n<li><strong>什么是Bean管理</strong><ol>\n<li>Bean管理</li>\n<li>Spring创建对象</li>\n<li>Spring注入属性</li>\n</ol>\n</li>\n<li><strong>Bean管理操作有两种方式</strong><ol>\n<li>IOC操作Bean管理(基于xml)</li>\n<li>IOC操作Bean管理(基于注解)</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"五、IOC操作Bean管理-基于xml\"><a href=\"#五、IOC操作Bean管理-基于xml\" class=\"headerlink\" title=\"五、IOC操作Bean管理(基于xml)\"></a>五、IOC操作Bean管理(基于xml)</h5><ol>\n<li><p><strong>基于xml方式创建对象</strong></p>\n<blockquote>\n<ol>\n<li><p>在spring配置文件中使用bean标签，标签里面添加对应的属性，就可以实现对象创建</p>\n<p><bean id=\"user\" class=\"com.xxx.xxx.User\"></bean></p>\n</li>\n<li><p>在bean标签有很多属性，介绍常用的属性：</p>\n<ol>\n<li>id属性：创建对象的唯一标识</li>\n<li>class属性：类全路径(包类路径)</li>\n</ol>\n</li>\n<li><p>创建对象时候，默认也是执行无参构造方法完成对象创建</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p><strong>基于xml方式注入属性</strong></p>\n<ol>\n<li>DI：依赖注入，就是注入属性</li>\n</ol>\n</li>\n<li><p><strong>第一种注入方式：使用set方法进行注入</strong></p>\n<ol>\n<li><p>创建类，定义属性和对应的set方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String bName;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBName</span><span class=\"params\">(String bName)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bName = bName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件配置对象创建，配置属性注入</p>\n<blockquote>\n<p>set方法注入属性</p>\n<bean id=\"book\" class=\"com.xxx.xxx.Book\">\n\n<p>​\tname: 类里面的属性名称</p>\n<p>​\tvalue：向属性注入的值</p>\n<p>​\t<property name=\"bName\" value=\"红楼梦\"></property></p>\n</bean></blockquote>\n</li>\n</ol>\n</li>\n<li><p><strong>第二种注入方式：使用有参数构造进行注入</strong></p>\n<ol>\n<li><p>创建类，定义属性，创建属性对应有参数的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Orders</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String oName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">//有参数构造</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Orders</span><span class=\"params\">(String oName, String address)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oName = oName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件中进行配置</p>\n<blockquote>\n<p>有参数构造注入属性</p>\n<bean id=\"orders\" class=\"com.xxx.xxx.Orders\">\n\n<pre><code> &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt;\n</code></pre>\n<p>​\t <constructor-arg name=\"address\" value=\"China\"></constructor-arg></p>\n</bean></blockquote>\n</li>\n</ol>\n</li>\n<li><p><strong>p名称空间注入(简化xml配置)</strong></p>\n<p>底层还是采用set注入，简化xml配置文件多属性注入</p>\n<ol>\n<li><p><strong>使用p名称空间注入，可以简化基于xml配置方式</strong></p>\n<blockquote>\n<p>第一步添加p名称空间在配置文件中</p>\n<beans  xmls:p=\"https://www.springframework.org/schema/p\">\n\n<p>第二步 进行属性注入，在bean标签里面进行操作\t</p>\n<p>​\t<bean id=\"book\" class=\"com.xxx.xxx.Book\" p:bname=\"三国演义\" p:bauthor=\"罗贯中\" ></p>\n<p>​\t</bean></p>\n</beans></blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"六、IOC操作Bean管理-xml注入其他类型属性\"><a href=\"#六、IOC操作Bean管理-xml注入其他类型属性\" class=\"headerlink\" title=\"六、IOC操作Bean管理(xml注入其他类型属性)\"></a>六、IOC操作Bean管理(xml注入其他类型属性)</h5><ol>\n<li><p><strong>字面值</strong></p>\n<ol>\n<li><p>null值</p>\n<property name=\"address\">\n\n<p>​\t<null/></p>\n</property>\n</li>\n<li><p>属性值包含特殊符号</p>\n<property name=\"address\">\n\n<p>​\t<value><![CDATA[<<南京>>]]></value></p>\n</property></li>\n</ol>\n</li>\n<li><p>外部Bean注入</p>\n<blockquote>\n<p>第一步：创建两个类service类和dao类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dao update.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：在service调用dao类里面的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建UserDao类型属性，生成set方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add......&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        原始方式：</span></span><br><span class=\"line\"><span class=\"comment\">//        创建UserDao对象</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDaoImpl userDao = new UserDaoImpl();</span></span><br><span class=\"line\">        userDao.update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第三步：在spting配置文件中进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    service和dao对象创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        注入UserDao对象--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        ref:创建的userDao对象bean标签--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDao&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDao&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userDao&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>内部Bean注入和级联赋值</p>\n<p>一对多关系：部门和员工，一个部门有多个员工，一个员工属于某一个部门，部门是一，员工是多</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 部门类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dept</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String dName;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setdName</span><span class=\"params\">(String dName)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dName = dName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 员工类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Emp</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String eName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dept dept;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setDept</span><span class=\"params\">(Dept dept)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dept = dept;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">seteName</span><span class=\"params\">(String eName)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.eName = eName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setGender</span><span class=\"params\">(String gender)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对spring配置文件中进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    内部bean--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;保安部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>级联赋值</p>\n<p>第一种写法：xml配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">&lt;!--    级联赋值--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        级联赋值--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;财务部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二种写法：生成get方法并修改配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    级联赋值--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置两个普通属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;eName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lucy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;gender&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;女&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        设置对象类型属性--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        级联赋值--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dept.dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;技术部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;财务部&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"七、IOC操作Bean管理-xml注入集合属性\"><a href=\"#七、IOC操作Bean管理-xml注入集合属性\" class=\"headerlink\" title=\"七、IOC操作Bean管理(xml注入集合属性)\"></a>七、IOC操作Bean管理(xml注入集合属性)</h5><ol>\n<li><p>注入数组类型属性</p>\n</li>\n<li><p>注入list集合类型属性</p>\n</li>\n<li><p>注入Map集合类型属性</p>\n<p>第一步：定义一个类，定义数组、list集合、map集合、set集合属性，生成对应的set方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stu</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.数组类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] courses;</span><br><span class=\"line\">    <span class=\"comment\">//2.list集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">//3.map集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String,String&gt; maps;</span><br><span class=\"line\">    <span class=\"comment\">//4.set集合类型属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;String&gt; sets;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setList</span><span class=\"params\">(List&lt;String&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.list = list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMaps</span><span class=\"params\">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maps = maps;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setCourses</span><span class=\"params\">(String[] courses)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.courses = courses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：配置spring配置文件进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    集合类型属性注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;stu&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--      数组属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;courses&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>语文<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>数学<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>英语<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        list集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>李四<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>王五<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        map集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maps&quot;</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;Java&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;java基础&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;PHP&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;php&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        set集合属性注入--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sets&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>MySQL<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>Redis<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在集合里面设置对象类型的值</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建多个course对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;course1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;course2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;MyBatis&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--        注入list集合类型，值是对象--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;courseList&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;course1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;course2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ref</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把集合注入部分提取出来</p>\n<p>第一步：先在Spring配置文件中引入名称空间(util)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:util</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步：使用util标签完成list集合注入提取</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    1.提取list集合类型属性注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">util:list</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>红楼梦<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>西游记<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>易筋经<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">util:list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    2.提取list注入使用--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"八、IOC操作Bean管理-FactoryBean\"><a href=\"#八、IOC操作Bean管理-FactoryBean\" class=\"headerlink\" title=\"八、IOC操作Bean管理(FactoryBean)\"></a>八、IOC操作Bean管理(FactoryBean)</h5><ol>\n<li><p>Spring有两种类型的Bean，一种普通的bean，另外一种是工厂bean(FactoryBean)</p>\n<blockquote>\n<p>普通Bean：在配置文件中定义Bean类型就是返回类型</p>\n<p>工厂Bean：在配置文件定义Bean类型可以和返回类型不一样</p>\n</blockquote>\n<p>第一步：创建类，让这个类作为工厂Bean，实现接口FactoryBean</p>\n<p>第二步：实现接口里面的方法，在实现的方法中定义返回的Bean类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBean</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//返回对象实例</span></span><br><span class=\"line\">    <span class=\"comment\">//定义返回Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Course <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Course</span> <span class=\"variable\">course</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Course</span>();</span><br><span class=\"line\">        course.setCname(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> course;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回类型</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//它是否是个单例</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FactoryBean.<span class=\"built_in\">super</span>.isSingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCollection3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean3.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Course</span> <span class=\"variable\">course</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;myBean&quot;</span>, Course.class);</span><br><span class=\"line\">        System.out.println(course);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.factorybean.MyBean&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>九、IOC操作Bean管理(Bean作用域)</p>\n<ol>\n<li><p>在Spring里面，设置创建Bean实例是单实例还是多实例</p>\n</li>\n<li><p>在Spring里面，默认情况下，bean是单实例对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCollection4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean4.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book1</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;book&quot;</span>, Book.class);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book2</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;book&quot;</span>, Book.class);</span><br><span class=\"line\">     <span class=\"comment\">//单实例输出对象相同</span></span><br><span class=\"line\">        System.out.println(book1);</span><br><span class=\"line\">        System.out.println(book2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何设置单实例还是多实例</p>\n<ol>\n<li><p>在Spring配置文件bean标签里面有属性(scope)用于设置单实例还是多实例</p>\n</li>\n<li><p>scope属性值</p>\n<p>第一个值：默认值，singleton，表示是单实例对象</p>\n<p>第二个值：prototype，表示是多实例对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.collectiontype.Book&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;list&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bookList&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>singleton和prototype区别</p>\n<blockquote>\n<ol>\n<li>singleton  单实例，prototype  多实例</li>\n<li>设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象。设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean方法时候创建多实例对象。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十、IOC操作Bean管理-bean生命周期\"><a href=\"#十、IOC操作Bean管理-bean生命周期\" class=\"headerlink\" title=\"十、IOC操作Bean管理(bean生命周期)\"></a>十、IOC操作Bean管理(bean生命周期)</h5><ol>\n<li><p>生命周期</p>\n<p>从对象的创建到对象销毁的过程</p>\n</li>\n<li><p>bean的生命周期</p>\n<ol>\n<li>通过构造器创建bean实例(无参构造)</li>\n<li>为bean里面的属性设置值和对其他bean的引用(调用set方法)</li>\n<li>调用bean的初始化的方法(需要进行配置)</li>\n<li>bean可以使用了(对象获取到了)</li>\n<li>当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Orders</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//无参构造</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Orders</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第一步：执行无参数构造创建Bean实例&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String oname;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setOname</span><span class=\"params\">(String oname)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oname = oname;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第二步：调用set方法设置属性值&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建执行的初始化的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第三步：执行初始化的方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建执行的销毁的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroyMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;第五步：执行销毁的方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;orders&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.Orders&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;initMethod&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;oname&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;手机&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testBean</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean5.xml&quot;</span>);</span><br><span class=\"line\">       <span class=\"type\">Orders</span> <span class=\"variable\">orders</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;orders&quot;</span>, Orders.class);</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;第四步：获取到创建bean实例对象&quot;</span>);</span><br><span class=\"line\">       System.out.println(orders);</span><br><span class=\"line\">       <span class=\"comment\">//手动让bean实例销毁</span></span><br><span class=\"line\">       context.close();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>bean的后置处理器</p>\n<ol>\n<li><p>通过构造器创建bean实例(无参构造)</p>\n</li>\n<li><p>为bean里面的属性设置值和对其他bean的引用(调用set方法)</p>\n</li>\n<li><p>把bean实例传递bean后置处理器的方法      —–postProcessBeforeInitialization</p>\n</li>\n<li><p>调用bean的初始化的方法(需要进行配置)</p>\n</li>\n<li><p>把bean实例传递bean后置处理器的方法      —–postProcessAfterInitialization</p>\n</li>\n<li><p>bean可以使用了(对象获取到了)</p>\n</li>\n<li><p>当容器关闭的时候，调用bean的销毁的方法(需要进行配置销毁的方法)</p>\n<p>后置处理器  例：</p>\n<ol>\n<li>创建类，实现接口BeanPostProcessor，创建后置处理器</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBeanPost</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanPostProcessor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在初始化之前执行的方法-------后置处理器&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;在初始化之后执行的方法------后置处理器&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    配置后置处理器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBeanPost&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十一、IOC操作Bean管理-xml自动装配\"><a href=\"#十一、IOC操作Bean管理-xml自动装配\" class=\"headerlink\" title=\"十一、IOC操作Bean管理(xml自动装配)\"></a>十一、IOC操作Bean管理(xml自动装配)</h5><p>​\t根据指定装配规则(属性名称或者属性类型)，spring自动将匹配的属性值进行注入</p>\n<ol>\n<li><p>根据属性的名称自动注入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    实现自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    bean标签中有个属性autowire，配置自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Emp&quot;</span> <span class=\"attr\">autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据属性的类型自动注入(相同类型的属性不能定义多个)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    实现自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    bean标签中有个属性autowire，配置自动装配--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    autowire两个值：byName根据属性名称注入    byType根据属性类型注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;emp&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Emp&quot;</span> <span class=\"attr\">autowire</span>=<span class=\"string\">&quot;byType&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dept&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.autowire.Dept&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"十二、IOC操作Bean管理-引入外部属性文件\"><a href=\"#十二、IOC操作Bean管理-引入外部属性文件\" class=\"headerlink\" title=\"十二、IOC操作Bean管理(引入外部属性文件)\"></a>十二、IOC操作Bean管理(引入外部属性文件)</h5><ol>\n<li><p>直接配置数据库信息</p>\n<ol>\n<li>配置德鲁伊连接池</li>\n<li>引入德鲁伊连接池依赖jar包</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    配置连接池--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入外部属性文件配置数据库连接池</p>\n<ol>\n<li><p>创建外部属性文件，properties格式文件，写数据库信息</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">prop.driverClassName</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">prop.url</span>=<span class=\"string\">jdbc:mysql://localhost:3306/userDb</span></span><br><span class=\"line\"><span class=\"attr\">prop.username</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">prop.password</span>=<span class=\"string\">root</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把外部properties属性文件引入spring配置文件中</p>\n<ol>\n<li><p>引入context名称空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置引入外部文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    引入外部的属性文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.driverClassName&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.username&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"十三、IOC操作Bean管理-基于注解方式\"><a href=\"#十三、IOC操作Bean管理-基于注解方式\" class=\"headerlink\" title=\"十三、IOC操作Bean管理(基于注解方式)\"></a>十三、IOC操作Bean管理(基于注解方式)</h5><ol>\n<li><p>什么是注解</p>\n<p>注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值…)</p>\n<p>使用注解，注解可以作用在类上面，方法上面，属性上面</p>\n<p>使用注解的目的：简化xml配置</p>\n</li>\n<li><p>Spring针对Bean管理(创建对象)中创建对象提供注解</p>\n<ol>\n<li>@Component</li>\n<li>@Service</li>\n<li>@Controller</li>\n<li>@Repository</li>\n</ol>\n<p>上面的四个注解功能是一样的，都是用来创建Bean的实例</p>\n</li>\n<li><p>基于注解方式实现对象创建</p>\n<ol>\n<li>第一步引入依赖</li>\n<li>开启组件扫描</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    开启组件扫描</span></span><br><span class=\"line\"><span class=\"comment\">    1.扫描多个包，多个包之间使用逗号隔开</span></span><br><span class=\"line\"><span class=\"comment\">    2.扫描包上层目录</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建类，在类上面添加创建对象得注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解里面value属性值可以省略</span></span><br><span class=\"line\"><span class=\"comment\">//默认值是类名称，首字母小写</span></span><br><span class=\"line\"><span class=\"meta\">@Service(value = &quot;userService&quot;)</span><span class=\"comment\">//类似 &lt;bean id=&quot;userService&quot; class=&quot;...&quot;&gt;&lt;/bean&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>开启组件扫描细节配置</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    示例1</span></span><br><span class=\"line\"><span class=\"comment\">    use-default-filters=&quot;false&quot;   表示现在不使用默认的filters，自己配置filter</span></span><br><span class=\"line\"><span class=\"comment\">    context:include-filter        扫描那些内容</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">use-default-filters</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    示例2</span></span><br><span class=\"line\"><span class=\"comment\">    context:exclude-filter     设置那些内容不进行扫描</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:exclude-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;annotation&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"十四、IOC操作Bean管理-基于注解属性注入\"><a href=\"#十四、IOC操作Bean管理-基于注解属性注入\" class=\"headerlink\" title=\"十四、IOC操作Bean管理(基于注解属性注入)\"></a>十四、IOC操作Bean管理(基于注解属性注入)</h5><ol>\n<li><p><strong>@Autowired</strong>：根据属性类型进行自动装配</p>\n<p>例：</p>\n<p>第一步 吧service和dao对象创建，在service和dao类添加创建对象注解</p>\n<p>第二步 在service注入dao对象，在service类添加dao类属性，在属性上面使用注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义dao类型属性</span></span><br><span class=\"line\">    <span class=\"comment\">//不需要添加set方法</span></span><br><span class=\"line\">    <span class=\"comment\">//添加注入属性的注解</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p><strong>@Qualifier</strong>：根据属性名称进行注入</p>\n<p>@Qualifier需要配合@Autowired注解进行使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository(value = &quot;userDapImpl1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;dao  add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>  <span class=\"comment\">//根据类型进行注入</span></span><br><span class=\"line\">   <span class=\"meta\">@Qualifier(value = &quot;userDapImpl1&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">       userDao.add();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>@Resource</strong>：可以根据类型注入，也可以根据名称注入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@Resource( name = &quot;userDapImpl1&quot;)</span>  <span class=\"comment\">//根据名称进行注入</span></span><br><span class=\"line\"><span class=\"meta\">@Resource</span>   <span class=\"comment\">//根据类型注入 </span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>@Value</strong>：注入普通类型属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value(value = &quot;Tom&quot;)</span>  <span class=\"comment\">//普通类型属性注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service add.....&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;service-name-&quot;</span>+name);</span><br><span class=\"line\">        userDao.add();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>纯注解开发</p>\n<ol>\n<li><p>创建配置类，替代xml配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>   <span class=\"comment\">//作为配置类，替代xml配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.test.spring5&quot;&#125;)</span> <span class=\"comment\">//开启</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringConfig</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testService2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//加载配置类</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;userService&quot;</span>, UserService.class);</span><br><span class=\"line\">        System.out.println(userService);</span><br><span class=\"line\">        userService.add();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"三、AOP\"><a href=\"#三、AOP\" class=\"headerlink\" title=\"三、AOP\"></a>三、AOP</h2><h4 id=\"一、什么是AOP-概念\"><a href=\"#一、什么是AOP-概念\" class=\"headerlink\" title=\"一、什么是AOP(概念)\"></a>一、什么是AOP(概念)</h4><p>​\tAOP为Aspect Oriented Programming 面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率</p>\n<p>​\t<code>不通过修改源代码的方式添加新功能</code></p>\n<p>​\t通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p>\n<h4 id=\"二、AOP底层原理\"><a href=\"#二、AOP底层原理\" class=\"headerlink\" title=\"二、AOP底层原理\"></a>二、AOP底层原理</h4><ol>\n<li>AOP底层使用动态代理<ol>\n<li>第一种有接口的情况(JDK动态代理)</li>\n<li>第二种没有接口的情况(CGLib动态代理)</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-1、AOP底层原理-JDK动态代理\"><a href=\"#2-1、AOP底层原理-JDK动态代理\" class=\"headerlink\" title=\"2.1、AOP底层原理(JDK动态代理)\"></a>2.1、AOP底层原理(JDK动态代理)</h5><ol>\n<li><p>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p>\n<p>java.lang.reflect.Proxy</p>\n<p>主要方法：</p>\n<table>\n<thead>\n<tr>\n<th>修饰符和类型</th>\n<th>方法与描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static Object</td>\n<td>newProxyInstance（）返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</td>\n</tr>\n</tbody></table>\n<p>里面有三个参数</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ClassLoader loader</td>\n<td>类加载器</td>\n</tr>\n<tr>\n<td>Class&lt;?&gt;[] interfaces</td>\n<td>增强方法所在类，这个类的接口，支持多个接口</td>\n</tr>\n<tr>\n<td>InvocationHandler h</td>\n<td>实现这个接口，创建代理对象，写增强的方法</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>编写JDK动态代理代码</p>\n<ol>\n<li><p>创建接口，定义方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">update</span><span class=\"params\">(String id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建接口实现类，实现方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">update</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Proxy类创建接口代理对象(增强)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建接口实现类代理对象</span></span><br><span class=\"line\">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class=\"line\"><span class=\"comment\">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            @Override</span></span><br><span class=\"line\"><span class=\"comment\">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                return null;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;);</span></span><br><span class=\"line\">        <span class=\"type\">UserDaoImpl</span> <span class=\"variable\">userDao</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserDaoImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">UserDao</span> <span class=\"variable\">dao</span> <span class=\"operator\">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class=\"keyword\">new</span> <span class=\"title class_\">UserDaoProxy</span>(userDao));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dao.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;result:&quot;</span>+result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建代理对象代码</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class=\"line\">    <span class=\"comment\">//有参数的构造传递</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserDaoProxy</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对象被创建就会调用invoke方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//增强的逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">//方法之前</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行之前......&quot;</span>+method.getName()+<span class=\"string\">&quot;  :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class=\"line\">        <span class=\"comment\">//被增强的方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> method.invoke(obj, args);</span><br><span class=\"line\">        <span class=\"comment\">//方法之后</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法执行之后......&quot;</span>+ obj);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"三、AOP-术语\"><a href=\"#三、AOP-术语\" class=\"headerlink\" title=\"三、AOP(术语)\"></a>三、AOP(术语)</h4><p>​\t术语就是例如，汽车发动机又叫引擎</p>\n<ol>\n<li><p>连接点</p>\n<blockquote>\n<p>类里面那些方法可以被增强，这些方法称为连接点</p>\n</blockquote>\n</li>\n<li><p>切入点</p>\n<blockquote>\n<p>实际被真正增强的方法，称为切入点</p>\n</blockquote>\n</li>\n<li><p>通知(增强)</p>\n<blockquote>\n<ol>\n<li>实际增强的逻辑部分称为通知(增强)</li>\n<li>通知有多种类型<ol>\n<li>前置通知：被增强的原始方法之前执行的逻辑</li>\n<li>后置通知：被增强的原始方法之后执行的逻辑</li>\n<li>环绕通知：被增强的原始方法之前后执行的逻辑</li>\n<li>异常通知：被增强的原始方法出现异常后执行的逻辑</li>\n<li>最终通知：如同try~catch后面的finally类似</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前置通知</span></span><br><span class=\"line\">  <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">  <span class=\"meta\">@Before(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//后置通知(返回值通知)</span></span><br><span class=\"line\">  <span class=\"meta\">@AfterReturning(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//环绕通知</span></span><br><span class=\"line\">  <span class=\"meta\">@Around(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//异常通知</span></span><br><span class=\"line\">  <span class=\"meta\">@AfterThrowing(value = &quot;execution()&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">//最终通知</span></span><br><span class=\"line\">  <span class=\"meta\">@After(value = &quot;execution()&quot;)</span>  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切面</p>\n<blockquote>\n<p>把通知应用到切入点过程，是一个动作</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"四、AOP操作\"><a href=\"#四、AOP操作\" class=\"headerlink\" title=\"四、AOP操作\"></a>四、AOP操作</h4><h5 id=\"4-1-准备工作\"><a href=\"#4-1-准备工作\" class=\"headerlink\" title=\"4.1 准备工作\"></a>4.1 准备工作</h5><ol>\n<li><p>Spring框架中一般都是基于AspectJ实现AOP操作</p>\n<ol>\n<li><p>什么是AspectJ</p>\n<blockquote>\n<p>AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>基于<code>AspectJ</code>实现AOP操作</p>\n<ol>\n<li>基于xml配置文件</li>\n<li>基于注解方式使用(常用)</li>\n</ol>\n</li>\n<li><p>在项目工程里面引入AOP相关依赖</p>\n<blockquote>\n<p>spring-aspects-5.2.6.RELEASE.jar<br>spring-aop-5.2.6.RELEASE.jar<br>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar<br>com.springsource.org.aopalliance-1.0.0.jar<br>com.springsource.net.sf.cglib-2.2.0.jar</p>\n</blockquote>\n</li>\n<li><p>切入点表达式</p>\n<blockquote>\n<ol>\n<li><p>切入点表达式作用：知道对那个类里面的那个方法进行增强</p>\n</li>\n<li><p>语法结构：</p>\n<p>excution([权限修饰符][返回类型][类的全路径][方法名称]([参数列表]))</p>\n<p>举例1：对com.test.dao.BoolDao类里面的add进行增强</p>\n<p><code>xcution(* com.test.dao.BoolDao.add(..));</code></p>\n<p>举例2：对com.test.dao.BoolDao类里面的所有方法增强</p>\n<p><code>excution(* com.test.dao.BoolDao.*(..));</code></p>\n<p>举例3：对com.test.dao.BoolDao类里面的所有类和所有类中的所有方法增强</p>\n<p><code>excution(* com.test.dao.\\*.*(..));</code></p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"4-2-AOP操作-AspectJ注解\"><a href=\"#4-2-AOP操作-AspectJ注解\" class=\"headerlink\" title=\"4.2 AOP操作(AspectJ注解)\"></a>4.2 AOP操作(AspectJ注解)</h5><ol>\n<li><p>创建类，在类里面定义方法，被增强类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被增强的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;User add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建增强类(编写增加的逻辑)</p>\n<p>在增强的类里面，创建不同的方法，让不同的方法代表不同的通知类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//增强的类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行通知的配置</p>\n<ol>\n<li><p>在spring配置文件中，开启注解扫描</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    开启注解扫描--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5.aopanno&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解创建User和UserProxy对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;User add......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在增强类上面添加注解@Aspect</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>  <span class=\"comment\">//生成代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件中开启生成代理对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启Aspect生成代理对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置不同类型的通知</p>\n<p>在我增强类的里面，作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//增强的类</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>  <span class=\"comment\">//生成代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">    <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//后置通知(返回值通知)</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterReturning</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AfterReturning......   后置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//环绕通知</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;环绕之前......&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//被增强的方法执行</span></span><br><span class=\"line\">        proceedingJoinPoint.proceed();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;环绕之后......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//异常通知</span></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterThrowing</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AfterThrowing......   前置通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最终通知</span></span><br><span class=\"line\">    <span class=\"meta\">@After(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">after</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After......  最终通知&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同切入点进行抽取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相同切入点抽取</span></span><br><span class=\"line\">   <span class=\"meta\">@Pointcut(value = &quot;execution(* com.test.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pointDemo</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//前置通知</span></span><br><span class=\"line\">   <span class=\"comment\">//Before 注解表示作为前置通知</span></span><br><span class=\"line\">   <span class=\"meta\">@Before(value = &quot;pointDemo()&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;before......   前置通知&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有多个增强类对同一个方法增强，设置增强类优先级</p>\n<p>在增强类上面添加注解@Order(值)，数字类型的值，数值越小优先级越高</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span>  <span class=\"comment\">//优先级</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PersonProxy</span> &#123;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完全使用注解开发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置类不需要创建xml配置文件</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.test.spring5&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConfigAop</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"4-3-AOP操作-AspectJ配置文件\"><a href=\"#4-3-AOP操作-AspectJ配置文件\" class=\"headerlink\" title=\"4.3 AOP操作(AspectJ配置文件)\"></a>4.3 AOP操作(AspectJ配置文件)</h5><ol>\n<li><p>创建两个类，增强类和被增强类，创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buy</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;buy......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before......&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中创建两个类对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建两个类的对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;book&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.aopxml.Book&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bookProxy&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.test.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中配置切入点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--    创建两个类的对象--&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">&quot;book&quot;</span> class=<span class=\"string\">&quot;com.test.spring5.aopxml.Book&quot;</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">&quot;bookProxy&quot;</span> class=<span class=\"string\">&quot;com.test.spring5.aopxml.BookProxy&quot;</span>&gt;&lt;/bean&gt;</span><br><span class=\"line\">&lt;!--    配置AOP增强--&gt;</span><br><span class=\"line\">    &lt;aop:config&gt;</span><br><span class=\"line\">&lt;!--        切入点--&gt;</span><br><span class=\"line\">        &lt;aop:pointcut id=<span class=\"string\">&quot;p&quot;</span> expression=<span class=\"string\">&quot;execution(* com.test.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;!--        配置切面--&gt;</span><br><span class=\"line\">        &lt;aop:aspect ref=<span class=\"string\">&quot;bookProxy&quot;</span>&gt;</span><br><span class=\"line\">&lt;!--            增强作用在具体的方法上--&gt;</span><br><span class=\"line\">            &lt;aop:before method=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;p&quot;</span>/&gt;</span><br><span class=\"line\">        &lt;/aop:aspect&gt;</span><br><span class=\"line\">    &lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、JDBC-Templatek\"><a href=\"#四、JDBC-Templatek\" class=\"headerlink\" title=\"四、JDBC Templatek\"></a>四、JDBC Templatek</h2><h4 id=\"一、概念和准备\"><a href=\"#一、概念和准备\" class=\"headerlink\" title=\"一、概念和准备\"></a>一、概念和准备</h4><ol>\n<li><p>什么是JDBCTemplatek</p>\n<p>Spring框架对JDBC进行封装，使用JDBCTemplatek方便实现对数据库操作</p>\n</li>\n<li><p>准备工作</p>\n<ol>\n<li><p>引入相关的依赖</p>\n<blockquote>\n<p>spring-tx-5.2.6.RELEASE.jar<br>spring-orm-5.2.6.RELEASE.jar<br>spring-jdbc-5.2.6.RELEASE.jar<br>druid-1.1.9.jar<br>mysql-connector-java-8.0.28.jar</p>\n</blockquote>\n</li>\n<li><p>在spring配置文件配置数据库连接池</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    数据库连接池--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;database&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;close&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql:///user_db&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置JDBCTemplate对象,注入DataSource</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建JDBCTemplate对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;jdbcTemplate&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--        注入dataSource--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Service类，创建dao类，在dao注入jdbcTemlate对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启组件扫描--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.test.spring5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入dao</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookDao bookDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BookDao</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入jdbcTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"二、JDBCTemplate操作数据库\"><a href=\"#二、JDBCTemplate操作数据库\" class=\"headerlink\" title=\"二、JDBCTemplate操作数据库\"></a>二、JDBCTemplate操作数据库</h4><h5 id=\"一、添加\"><a href=\"#一、添加\" class=\"headerlink\" title=\"一、添加\"></a>一、添加</h5><ol>\n<li><p>对应数据库创建实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String ustatus;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserId</span><span class=\"params\">(String userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写service和dao</p>\n<ol>\n<li><p>在dao层进行数据库添加操作</p>\n</li>\n<li><p>调用jdbctemplate对象里面的update方法实现添加操作</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String  SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>Object…  args</td>\n<td>可变参数，设置sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BookDao</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入jdbcTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"comment\">//添加的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(Book book)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法实现</span></span><br><span class=\"line\"><span class=\"comment\">//        int rows = jdbcTemplate.update(sql, book.getUserId(), book.getUsername(), book.getUstatus());</span></span><br><span class=\"line\">        Object[] args = &#123; book.getUserId(), book.getUsername(), book.getUstatus()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql,args);</span><br><span class=\"line\">        System.out.println(rows);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestBook</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testJDBCTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;bean1.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BookService</span> <span class=\"variable\">bookService</span> <span class=\"operator\">=</span> context.getBean(<span class=\"string\">&quot;bookService&quot;</span>, BookService.class);</span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        book.setUserId(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        book.setUsername(<span class=\"string\">&quot;红露面&quot;</span>);</span><br><span class=\"line\">        book.setUstatus(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        bookService.addBook(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"二、修改\"><a href=\"#二、修改\" class=\"headerlink\" title=\"二、修改\"></a>二、修改</h5><ol>\n<li><p>BookService添加修改方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现修改方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        book.setUserId(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        book.setUsername(<span class=\"string\">&quot;许仙&quot;</span>);</span><br><span class=\"line\">        book.setUstatus(<span class=\"string\">&quot;AAAA&quot;</span>);</span><br><span class=\"line\">        bookService.updateBook(book);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"三、删除\"><a href=\"#三、删除\" class=\"headerlink\" title=\"三、删除\"></a>三、删除</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateBook</span><span class=\"params\">(Book book)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">        Object[] args = &#123; book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">update</span> <span class=\"operator\">=</span> jdbcTemplate.update(sql, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;修改了&quot;</span>+update+<span class=\"string\">&quot;记录&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Book</span>();</span><br><span class=\"line\">        bookService.deleteBook(<span class=\"string\">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"四、查询\"><a href=\"#四、查询\" class=\"headerlink\" title=\"四、查询\"></a>四、查询</h5><ol>\n<li><p><strong>查询返回某个值</strong></p>\n<ol>\n<li><p>查询表里面有多少条记录，返回某个值</p>\n</li>\n<li><p>使用jdbcTemplate实现返回某个值代码</p>\n<p>queryForObject</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String  SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>Class<T> requiredType</td>\n<td>返回类型Class</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">selectCount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select count(*) from t_book&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> bookService.findCount();</span><br><span class=\"line\">       System.out.println(count);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>查询返回对象</strong></p>\n<ol>\n<li><p>场景：查询图书的详情页面</p>\n</li>\n<li><p>JDBCTemplate实现查询返回对象</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>RowMapper<T> rowMapper</td>\n<td>rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装</td>\n</tr>\n<tr>\n<td>object… args</td>\n<td>sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Book <span class=\"title function_\">findBookInfo</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">book</span> <span class=\"operator\">=</span> jdbcTemplate.queryForObject(sql, <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class), id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> book;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回对象</span></span><br><span class=\"line\">        <span class=\"type\">Book</span> <span class=\"variable\">one</span> <span class=\"operator\">=</span> bookService.findOne(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        System.out.println(one);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p><strong>查询返回集合</strong></p>\n<ol>\n<li><p>场景：查询图书列表分页…</p>\n</li>\n<li><p>调用jdbcTemplate方法实现查询返回集合</p>\n<p>query()</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>RowMapper<T> rowMapper</td>\n<td>rowmapper,是接口，返回不同类型数据，用接口里面实现类完成数据封装</td>\n</tr>\n<tr>\n<td>object… args</td>\n<td>sql语句值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title function_\">findALlBook</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from t_book&quot;</span>;</span><br><span class=\"line\">        List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bookList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询返回集合</span></span><br><span class=\"line\">        List&lt;Book&gt; all = bookService.findAll();</span><br><span class=\"line\">        System.out.println(all);</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"五、批量操作\"><a href=\"#五、批量操作\" class=\"headerlink\" title=\"五、批量操作\"></a>五、批量操作</h5><ol>\n<li><p>批量操作：操作表里面多条记录</p>\n</li>\n<li><p>jdbcTemplate实现批量添加的操作</p>\n<p>batchUpdate(String sql,List&lt;Object[]&gt; barchArgs)</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String SQL</td>\n<td>sql语句</td>\n</tr>\n<tr>\n<td>List&lt;object[]&gt; barchArgs</td>\n<td>list集合添加的多条记录数据</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量添加</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchAddBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(Arrays.toString(ints));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量添加</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;张三&quot;</span>,<span class=\"string\">&quot;qwe&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;李四&quot;</span>,<span class=\"string\">&quot;qwerty&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o3 = &#123;<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;王五&quot;</span>,<span class=\"string\">&quot;ewq&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        list.add(o3);</span><br><span class=\"line\">        bookService.batchAdd(list);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jdbcTemplate实现批量修改的操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchUpdateBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(Arrays.toString(ints));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量修改</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;红楼梦&quot;</span>,<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;1&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;西游记&quot;</span>,<span class=\"string\">&quot;bbb&quot;</span>,<span class=\"string\">&quot;2&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o3 = &#123;<span class=\"string\">&quot;水浒传&quot;</span>,<span class=\"string\">&quot;ccc&quot;</span>,<span class=\"string\">&quot;3&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        list.add(o3);</span><br><span class=\"line\">        bookService.batchUpdate(list);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>批量删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量删除</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">batchDeleteBook</span><span class=\"params\">(List&lt;Object[]&gt; bachArgs)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span>[] ints = jdbcTemplate.batchUpdate(sql, bachArgs);</span><br><span class=\"line\">       System.out.println(ints);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//批量删除</span></span><br><span class=\"line\">        List&lt;Object[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Object[] o1 = &#123;<span class=\"string\">&quot;4&quot;</span>&#125;;</span><br><span class=\"line\">        Object[] o2 = &#123;<span class=\"string\">&quot;5&quot;</span>&#125;;</span><br><span class=\"line\">        list.add(o1);</span><br><span class=\"line\">        list.add(o2);</span><br><span class=\"line\">        bookService.batchUpdate(list);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"五、事务管理\"><a href=\"#五、事务管理\" class=\"headerlink\" title=\"五、事务管理\"></a>五、事务管理</h2><h4 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h4><ol>\n<li>事务是数据库操作的最基本单元，逻辑上一组操作，要么都成功，要么失败一个其他所有操作都是失败</li>\n<li>典型场景：银行转账</li>\n<li>事务四个特性(ACID)<ol>\n<li>原子性</li>\n<li>一致性</li>\n<li>隔离性</li>\n<li>持久性</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"二、事务操作\"><a href=\"#二、事务操作\" class=\"headerlink\" title=\"二、事务操作\"></a>二、事务操作</h4><h5 id=\"1-搭建事务操作环境\"><a href=\"#1-搭建事务操作环境\" class=\"headerlink\" title=\"1.搭建事务操作环境\"></a>1.搭建事务操作环境</h5><ol>\n<li><p>创建数据库表，添加记录</p>\n</li>\n<li><p>创建service，创建dao，完成对象创建和注入关系</p>\n<p>service注入dao，在dao注入jdbcTemplate，在jdbcTemplate注入DataSource</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注入dao</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在dao创建两个方法：多钱和少钱方法，在service创建方法(转账的方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class=\"line\">        jdbcTemplate.update(sql, <span class=\"number\">100</span>, <span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reduceMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class=\"line\">        jdbcTemplate.update(sql, <span class=\"number\">100</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//转账方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accountMoney</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        userDao.reduceMoney();</span><br><span class=\"line\">        userDao.addMoney();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面代码，正常执行没有问题，但是代码如果产生异常，会有问题</p>\n<p>问题：张三扣除100块，而李四并没有收到100块</p>\n<p>以上问题问题解决方案，使用事务进行解决，要么一起成功要么一起失败</p>\n<blockquote>\n<p>事务的操作过程：</p>\n<ol>\n<li>开启事务</li>\n<li>进行业务操作(try~catch捕获并处理异常)</li>\n<li>没有异常，提交事务</li>\n<li>出现了异常，事务回滚</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"2-事务操作-spring事务管理介绍\"><a href=\"#2-事务操作-spring事务管理介绍\" class=\"headerlink\" title=\"2.事务操作(spring事务管理介绍)\"></a>2.事务操作(spring事务管理介绍)</h5><ol>\n<li><p>事务添加到JavaEE三层结构里面Service层(业务逻辑层)</p>\n</li>\n<li><p>在Spring进行事务管理操作</p>\n<blockquote>\n<p>有两种方式：编程式事务管理和声明式事务管理(使用)</p>\n</blockquote>\n</li>\n<li><p>声明式事务管理</p>\n<ol>\n<li>基于注解方式</li>\n<li>基于xml配置文件方式</li>\n</ol>\n</li>\n<li><p>在Spring进行声明式事务管理，底层使用AOP原理</p>\n</li>\n<li><p>Spring事务管理API</p>\n<ol>\n<li><p>提供了一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类</p>\n<p><code>PlatformTransactionManager</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-事务操作-注解声明式事务管理\"><a href=\"#3-事务操作-注解声明式事务管理\" class=\"headerlink\" title=\"3.事务操作(注解声明式事务管理)\"></a>3.事务操作(注解声明式事务管理)</h5><ol>\n<li><p>在Spring配置文件配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建事务管理器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--        注入数据源--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Spring配置文件,开启事务注解</p>\n<p>在spring配置文件引入名称空间tx</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    开启事务注解--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在service类上面添加事务注解</p>\n<p>@Transactional,这个注解添加到类上面,也可以添加到方法上面</p>\n<p>添加在类上,表示这个类中所有方法都添加了事务</p>\n<p>添加到方法上,只为该方法提供事务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"4-事务操作-声明式事务管理参数\"><a href=\"#4-事务操作-声明式事务管理参数\" class=\"headerlink\" title=\"4.事务操作(声明式事务管理参数)\"></a>4.事务操作(声明式事务管理参数)</h5><table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Propagation propagation()</td>\n<td>事务的传播行为</td>\n</tr>\n<tr>\n<td>Isolation isolation()</td>\n<td>事务的隔离级别</td>\n</tr>\n<tr>\n<td>int timeout()</td>\n<td>事务的超时时间</td>\n</tr>\n<tr>\n<td>boolearn readOnly</td>\n<td>是否只读</td>\n</tr>\n<tr>\n<td>rollbackFor</td>\n<td>回滚</td>\n</tr>\n<tr>\n<td>noRollbackFor</td>\n<td>不回滚</td>\n</tr>\n</tbody></table>\n<p>   <strong><code>propagation()</code></strong>:事务的传播行为</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MANDATORY</td>\n<td>支持当前事务，如果不存在则引发异常。</td>\n</tr>\n<tr>\n<td>NESTED</td>\n<td>如果当前事务存在，则在嵌套事务内执行，否则行为类似于 <code>REQUIRED</code></td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>以非事务方式执行，如果存在事务则引发异常。</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>以非事务方式执行，如果存在当前事务，则挂起当前事务。</td>\n</tr>\n<tr>\n<td>REQUIRED</td>\n<td>支持当前事务，如果不存在则创建新事务。</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>创建一个新事务，如果当前事务存在，则挂起当前事务。</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>支持当前事务，如果不存在，则以非事务方式执行。</td>\n</tr>\n</tbody></table>\n<p>   <strong><code>isolation</code></strong>:事务的隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFAULT</td>\n<td>使用基础数据存储区的默认隔离级别。</td>\n</tr>\n<tr>\n<td>READ_COMMITTED</td>\n<td>一个常量，指示阻止脏读;可能发生不可重复的读取和幻像读取。</td>\n</tr>\n<tr>\n<td>READ_UNCOMMITTED</td>\n<td>一个常量，指示可能发生脏读、不可重复读和幻像读。</td>\n</tr>\n<tr>\n<td>REPEATABLF_READ</td>\n<td>一个常量，指示阻止脏读取和不可重复读取;可能发生幻象读取</td>\n</tr>\n<tr>\n<td>SERIALZABLE</td>\n<td>一个常量，指示阻止脏读、不可重复读和幻像读。</td>\n</tr>\n</tbody></table>\n<h5 id=\"5-事务操作-xml声明式事务管理\"><a href=\"#5-事务操作-xml声明式事务管理\" class=\"headerlink\" title=\"5.事务操作(xml声明式事务管理)\"></a>5.事务操作(xml声明式事务管理)</h5><ol>\n<li><p>在spring配置文件中进行配置</p>\n<p>第一步：配置事务管理器</p>\n<p>第二步：配置通知</p>\n<p>第三步：配置切入点和切面</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--    创建事务管理器--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        注入数据源--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;database&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!--    配置通知--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txadvice&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置事务参数--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">           <span class=\"comment\">&lt;!--            指定那种规则的方法上面添加事务--&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;accountMoney&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class=\"line\">           <span class=\"comment\">&lt;!--            &lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!--    配置切入点和切面--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置切入点--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pt&quot;</span> <span class=\"attr\">expression</span>=<span class=\"string\">&quot;execution(* com.test.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!--        配置切面--&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">&quot;txadvice&quot;</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">&quot;pt&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"URL和URI的区别？","date":"2022-07-15T04:22:45.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# URL和URI的区别\n## URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\nURI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。\nURL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol 、host、port、path、parameter、anchor。\nURN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。\n![](https://img-blog.csdnimg.cn/20210330215546460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nemhhbmJpbg==,size_16,color_FFFFFF,t_70#pic_center)\n## 举个例子：\n> 个人的身份证号码就是URN，个人的家庭地址就是URL，URN可以唯一标识一个人，而URL可以告诉邮递员怎么把货送到你手里。\n## 在举个例子：\n> `htttps://www.lanou3g.com/article/1321231`是个URl，通过这个网址可以告诉CDN找到这篇文章的所在地，并且还告诉用HTTP协议访问。\n## 详细说明\n### 一、URI\n> URI，统一资源标志符(Uniform Resource Identifier, URI),表示的是web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都由一个URI进行标识的。\n> URI通常由三部分组成：\n> 1.资源的命名机制；\n> 2.存放资源的主机名；\n> 3.资源自身的名称。\n\n(注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件)\n\n### 二、URL\n> URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。\n> 通俗地说，URL是Internet上描述信息资源得字符串，主要用在各种WWW客户程序和服务器程序上。\n> 采用URL可以用一种统一得格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。\n\nURL的一般格式为(带方括号[]的为可选项)：\n> protocol://hostname[:post]/path/parameters#fragment\n\n`URL的格式由三部分组成：`\n> 1.第一部分是协议(或称为服务方式).\n> 2.第二部分是存有该资源的主机IP地址(有时也包括端口号)。\n> 3.第三部分是主机资源的具体地址，如目录和文件名等。\n> 第一部分和第二部分用“：//”符号隔开。\n> 第二部分和第三部分用“/”符号隔开。\n> 第一部分和第二部分是不可缺少的，第三部分有时可以省略。\n\n> 如：`https://www.lanou3g.com/article/1231231`\n> 我们可以这样解释它：\n> 1.这是一个可以通过HTTPS协议访问的资源。\n> 2.位于主机`www.lanou3g.com`上。\n> 3.通过“/articale/1231231”可以对该资源进行唯一标识(注意，这个不一定是完整的路径)\n\n### 三、URI和URL之间的区别\n> 从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资\n> 源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可\n> 以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。\n\n### 四、通俗说\n>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。\n拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。\n那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，\n就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人\n可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/URL和URI的区别.md","raw":"---\ntitle: URL和URI的区别？\ndate: 2022-07-15 12:22:45\ntags: 网络\ncategories: 网络\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# URL和URI的区别\n## URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\nURI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。\nURL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol 、host、port、path、parameter、anchor。\nURN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。\n![](https://img-blog.csdnimg.cn/20210330215546460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nemhhbmJpbg==,size_16,color_FFFFFF,t_70#pic_center)\n## 举个例子：\n> 个人的身份证号码就是URN，个人的家庭地址就是URL，URN可以唯一标识一个人，而URL可以告诉邮递员怎么把货送到你手里。\n## 在举个例子：\n> `htttps://www.lanou3g.com/article/1321231`是个URl，通过这个网址可以告诉CDN找到这篇文章的所在地，并且还告诉用HTTP协议访问。\n## 详细说明\n### 一、URI\n> URI，统一资源标志符(Uniform Resource Identifier, URI),表示的是web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都由一个URI进行标识的。\n> URI通常由三部分组成：\n> 1.资源的命名机制；\n> 2.存放资源的主机名；\n> 3.资源自身的名称。\n\n(注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件)\n\n### 二、URL\n> URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。\n> 通俗地说，URL是Internet上描述信息资源得字符串，主要用在各种WWW客户程序和服务器程序上。\n> 采用URL可以用一种统一得格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。\n\nURL的一般格式为(带方括号[]的为可选项)：\n> protocol://hostname[:post]/path/parameters#fragment\n\n`URL的格式由三部分组成：`\n> 1.第一部分是协议(或称为服务方式).\n> 2.第二部分是存有该资源的主机IP地址(有时也包括端口号)。\n> 3.第三部分是主机资源的具体地址，如目录和文件名等。\n> 第一部分和第二部分用“：//”符号隔开。\n> 第二部分和第三部分用“/”符号隔开。\n> 第一部分和第二部分是不可缺少的，第三部分有时可以省略。\n\n> 如：`https://www.lanou3g.com/article/1231231`\n> 我们可以这样解释它：\n> 1.这是一个可以通过HTTPS协议访问的资源。\n> 2.位于主机`www.lanou3g.com`上。\n> 3.通过“/articale/1231231”可以对该资源进行唯一标识(注意，这个不一定是完整的路径)\n\n### 三、URI和URL之间的区别\n> 从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资\n> 源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可\n> 以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。\n\n### 四、通俗说\n>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。\n拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。\n那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，\n就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人\n可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"URL和URI的区别","published":1,"updated":"2023-08-10T07:47:35.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9t001cfswo4wzmby56","content":"<h1 id=\"URL和URI的区别\"><a href=\"#URL和URI的区别\" class=\"headerlink\" title=\"URL和URI的区别\"></a>URL和URI的区别</h1><h2 id=\"URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\"><a href=\"#URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\" class=\"headerlink\" title=\"URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\"></a>URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL</h2><p>URI &#x3D; Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。<br>URL &#x3D; Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol 、host、port、path、parameter、anchor。<br>URN &#x3D; Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。<br><img src=\"https://img-blog.csdnimg.cn/20210330215546460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nemhhbmJpbg==,size_16,color_FFFFFF,t_70#pic_center\"></p>\n<h2 id=\"举个例子：\"><a href=\"#举个例子：\" class=\"headerlink\" title=\"举个例子：\"></a>举个例子：</h2><blockquote>\n<p>个人的身份证号码就是URN，个人的家庭地址就是URL，URN可以唯一标识一个人，而URL可以告诉邮递员怎么把货送到你手里。</p>\n</blockquote>\n<h2 id=\"在举个例子：\"><a href=\"#在举个例子：\" class=\"headerlink\" title=\"在举个例子：\"></a>在举个例子：</h2><blockquote>\n<p><code>htttps://www.lanou3g.com/article/1321231</code>是个URl，通过这个网址可以告诉CDN找到这篇文章的所在地，并且还告诉用HTTP协议访问。</p>\n</blockquote>\n<h2 id=\"详细说明\"><a href=\"#详细说明\" class=\"headerlink\" title=\"详细说明\"></a>详细说明</h2><h3 id=\"一、URI\"><a href=\"#一、URI\" class=\"headerlink\" title=\"一、URI\"></a>一、URI</h3><blockquote>\n<p>URI，统一资源标志符(Uniform Resource Identifier, URI),表示的是web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都由一个URI进行标识的。<br>URI通常由三部分组成：<br>1.资源的命名机制；<br>2.存放资源的主机名；<br>3.资源自身的名称。</p>\n</blockquote>\n<p>(注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件)</p>\n<h3 id=\"二、URL\"><a href=\"#二、URL\" class=\"headerlink\" title=\"二、URL\"></a>二、URL</h3><blockquote>\n<p>URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。<br>通俗地说，URL是Internet上描述信息资源得字符串，主要用在各种WWW客户程序和服务器程序上。<br>采用URL可以用一种统一得格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p>\n</blockquote>\n<p>URL的一般格式为(带方括号[]的为可选项)：</p>\n<blockquote>\n<p>protocol:&#x2F;&#x2F;hostname[:post]&#x2F;path&#x2F;parameters#fragment</p>\n</blockquote>\n<p><code>URL的格式由三部分组成：</code></p>\n<blockquote>\n<p>1.第一部分是协议(或称为服务方式).<br>2.第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>3.第三部分是主机资源的具体地址，如目录和文件名等。<br>第一部分和第二部分用“：&#x2F;&#x2F;”符号隔开。<br>第二部分和第三部分用“&#x2F;”符号隔开。<br>第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p>\n</blockquote>\n<blockquote>\n<p>如：<code>https://www.lanou3g.com/article/1231231</code><br>我们可以这样解释它：<br>1.这是一个可以通过HTTPS协议访问的资源。<br>2.位于主机<code>www.lanou3g.com</code>上。<br>3.通过“&#x2F;articale&#x2F;1231231”可以对该资源进行唯一标识(注意，这个不一定是完整的路径)</p>\n</blockquote>\n<h3 id=\"三、URI和URL之间的区别\"><a href=\"#三、URI和URL之间的区别\" class=\"headerlink\" title=\"三、URI和URL之间的区别\"></a>三、URI和URL之间的区别</h3><blockquote>\n<p>从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资<br>源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可<br>以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p>\n</blockquote>\n<h3 id=\"四、通俗说\"><a href=\"#四、通俗说\" class=\"headerlink\" title=\"四、通俗说\"></a>四、通俗说</h3><blockquote>\n<p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。<br>拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。<br>那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，<br>就可以有：动物住址协议:&#x2F;&#x2F;地球&#x2F;中国&#x2F;浙江省&#x2F;杭州市&#x2F;西湖区&#x2F;某大学&#x2F;14号宿舍楼&#x2F;525号寝&#x2F;张三.人<br>可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。</p>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"URL和URI的区别\"><a href=\"#URL和URI的区别\" class=\"headerlink\" title=\"URL和URI的区别\"></a>URL和URI的区别</h1><h2 id=\"URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\"><a href=\"#URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\" class=\"headerlink\" title=\"URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL\"></a>URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL</h2><p>URI &#x3D; Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。<br>URL &#x3D; Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol 、host、port、path、parameter、anchor。<br>URN &#x3D; Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。<br><img src=\"https://img-blog.csdnimg.cn/20210330215546460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nemhhbmJpbg==,size_16,color_FFFFFF,t_70#pic_center\"></p>\n<h2 id=\"举个例子：\"><a href=\"#举个例子：\" class=\"headerlink\" title=\"举个例子：\"></a>举个例子：</h2><blockquote>\n<p>个人的身份证号码就是URN，个人的家庭地址就是URL，URN可以唯一标识一个人，而URL可以告诉邮递员怎么把货送到你手里。</p>\n</blockquote>\n<h2 id=\"在举个例子：\"><a href=\"#在举个例子：\" class=\"headerlink\" title=\"在举个例子：\"></a>在举个例子：</h2><blockquote>\n<p><code>htttps://www.lanou3g.com/article/1321231</code>是个URl，通过这个网址可以告诉CDN找到这篇文章的所在地，并且还告诉用HTTP协议访问。</p>\n</blockquote>\n<h2 id=\"详细说明\"><a href=\"#详细说明\" class=\"headerlink\" title=\"详细说明\"></a>详细说明</h2><h3 id=\"一、URI\"><a href=\"#一、URI\" class=\"headerlink\" title=\"一、URI\"></a>一、URI</h3><blockquote>\n<p>URI，统一资源标志符(Uniform Resource Identifier, URI),表示的是web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都由一个URI进行标识的。<br>URI通常由三部分组成：<br>1.资源的命名机制；<br>2.存放资源的主机名；<br>3.资源自身的名称。</p>\n</blockquote>\n<p>(注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件)</p>\n<h3 id=\"二、URL\"><a href=\"#二、URL\" class=\"headerlink\" title=\"二、URL\"></a>二、URL</h3><blockquote>\n<p>URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。<br>通俗地说，URL是Internet上描述信息资源得字符串，主要用在各种WWW客户程序和服务器程序上。<br>采用URL可以用一种统一得格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p>\n</blockquote>\n<p>URL的一般格式为(带方括号[]的为可选项)：</p>\n<blockquote>\n<p>protocol:&#x2F;&#x2F;hostname[:post]&#x2F;path&#x2F;parameters#fragment</p>\n</blockquote>\n<p><code>URL的格式由三部分组成：</code></p>\n<blockquote>\n<p>1.第一部分是协议(或称为服务方式).<br>2.第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>3.第三部分是主机资源的具体地址，如目录和文件名等。<br>第一部分和第二部分用“：&#x2F;&#x2F;”符号隔开。<br>第二部分和第三部分用“&#x2F;”符号隔开。<br>第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p>\n</blockquote>\n<blockquote>\n<p>如：<code>https://www.lanou3g.com/article/1231231</code><br>我们可以这样解释它：<br>1.这是一个可以通过HTTPS协议访问的资源。<br>2.位于主机<code>www.lanou3g.com</code>上。<br>3.通过“&#x2F;articale&#x2F;1231231”可以对该资源进行唯一标识(注意，这个不一定是完整的路径)</p>\n</blockquote>\n<h3 id=\"三、URI和URL之间的区别\"><a href=\"#三、URI和URL之间的区别\" class=\"headerlink\" title=\"三、URI和URL之间的区别\"></a>三、URI和URL之间的区别</h3><blockquote>\n<p>从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资<br>源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可<br>以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p>\n</blockquote>\n<h3 id=\"四、通俗说\"><a href=\"#四、通俗说\" class=\"headerlink\" title=\"四、通俗说\"></a>四、通俗说</h3><blockquote>\n<p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。<br>拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。<br>那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，<br>就可以有：动物住址协议:&#x2F;&#x2F;地球&#x2F;中国&#x2F;浙江省&#x2F;杭州市&#x2F;西湖区&#x2F;某大学&#x2F;14号宿舍楼&#x2F;525号寝&#x2F;张三.人<br>可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。</p>\n</blockquote>\n"},{"title":"XML学习","date":"2022-08-18T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# XML\n\n### 一、xml概念\n\n​\tExtensiable Markup Language\n\n​\t可扩展标记语言\n\n### 二、 xml作用\n\n1. 数据传输格式(由json代替了)\n\n2. 数据库存储格式\n\n3. 应用程序的配置文件(主要用于web开发,以及框架的配置)\n\n   配置文件常格式: .xml .properties  .yml\n\n### 三、xml基本组成部分\n\n1. 声明\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n   ```\n\n   指定版本号和编码方式\n\n2. DTD约束/Schemal约束\n\n   主要用于约束当前xml文件应该写那些标签，\n   以及这些标签所出现的先后顺序和嵌套顺序如果没有DTD约束，\n   那么标签可以自己随便写\n\n3. 标签Tag(一对尖括号)\n\n4. 元素Element\n\n   元素=开始标签+中间内容+结束标签\n\n5. 根元素RootElement\n\n   一篇xml文档有且仅有一个根元素\n\n6. 属性Attribute\n\n   以key=value形式出现在开始标签中\n\n   属性值必须带上单引号或者双引号\n\n7. 节点Node\n\n8. 文档对象\n\n### 四、xml解析\n\n从xml文件提取出我们想要的数据\n\n1. dom解析               \n2. dom4解析\n3. pull解析\n4. sax解析","source":"_posts/XML.md","raw":"---\ntitle: XML学习\ndate: 2022-08-18 11:18:57\ntags: 计算机学习\ncategories: 计算机学习\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# XML\n\n### 一、xml概念\n\n​\tExtensiable Markup Language\n\n​\t可扩展标记语言\n\n### 二、 xml作用\n\n1. 数据传输格式(由json代替了)\n\n2. 数据库存储格式\n\n3. 应用程序的配置文件(主要用于web开发,以及框架的配置)\n\n   配置文件常格式: .xml .properties  .yml\n\n### 三、xml基本组成部分\n\n1. 声明\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n   ```\n\n   指定版本号和编码方式\n\n2. DTD约束/Schemal约束\n\n   主要用于约束当前xml文件应该写那些标签，\n   以及这些标签所出现的先后顺序和嵌套顺序如果没有DTD约束，\n   那么标签可以自己随便写\n\n3. 标签Tag(一对尖括号)\n\n4. 元素Element\n\n   元素=开始标签+中间内容+结束标签\n\n5. 根元素RootElement\n\n   一篇xml文档有且仅有一个根元素\n\n6. 属性Attribute\n\n   以key=value形式出现在开始标签中\n\n   属性值必须带上单引号或者双引号\n\n7. 节点Node\n\n8. 文档对象\n\n### 四、xml解析\n\n从xml文件提取出我们想要的数据\n\n1. dom解析               \n2. dom4解析\n3. pull解析\n4. sax解析","slug":"XML","published":1,"updated":"2023-08-10T07:47:32.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9u001ffswo13pr9gbc","content":"<h1 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h1><h3 id=\"一、xml概念\"><a href=\"#一、xml概念\" class=\"headerlink\" title=\"一、xml概念\"></a>一、xml概念</h3><p>​\tExtensiable Markup Language</p>\n<p>​\t可扩展标记语言</p>\n<h3 id=\"二、-xml作用\"><a href=\"#二、-xml作用\" class=\"headerlink\" title=\"二、 xml作用\"></a>二、 xml作用</h3><ol>\n<li><p>数据传输格式(由json代替了)</p>\n</li>\n<li><p>数据库存储格式</p>\n</li>\n<li><p>应用程序的配置文件(主要用于web开发,以及框架的配置)</p>\n<p>配置文件常格式: .xml .properties  .yml</p>\n</li>\n</ol>\n<h3 id=\"三、xml基本组成部分\"><a href=\"#三、xml基本组成部分\" class=\"headerlink\" title=\"三、xml基本组成部分\"></a>三、xml基本组成部分</h3><ol>\n<li><p>声明</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>指定版本号和编码方式</p>\n</li>\n<li><p>DTD约束&#x2F;Schemal约束</p>\n<p>主要用于约束当前xml文件应该写那些标签，<br>以及这些标签所出现的先后顺序和嵌套顺序如果没有DTD约束，<br>那么标签可以自己随便写</p>\n</li>\n<li><p>标签Tag(一对尖括号)</p>\n</li>\n<li><p>元素Element</p>\n<p>元素&#x3D;开始标签+中间内容+结束标签</p>\n</li>\n<li><p>根元素RootElement</p>\n<p>一篇xml文档有且仅有一个根元素</p>\n</li>\n<li><p>属性Attribute</p>\n<p>以key&#x3D;value形式出现在开始标签中</p>\n<p>属性值必须带上单引号或者双引号</p>\n</li>\n<li><p>节点Node</p>\n</li>\n<li><p>文档对象</p>\n</li>\n</ol>\n<h3 id=\"四、xml解析\"><a href=\"#四、xml解析\" class=\"headerlink\" title=\"四、xml解析\"></a>四、xml解析</h3><p>从xml文件提取出我们想要的数据</p>\n<ol>\n<li>dom解析               </li>\n<li>dom4解析</li>\n<li>pull解析</li>\n<li>sax解析</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h1><h3 id=\"一、xml概念\"><a href=\"#一、xml概念\" class=\"headerlink\" title=\"一、xml概念\"></a>一、xml概念</h3><p>​\tExtensiable Markup Language</p>\n<p>​\t可扩展标记语言</p>\n<h3 id=\"二、-xml作用\"><a href=\"#二、-xml作用\" class=\"headerlink\" title=\"二、 xml作用\"></a>二、 xml作用</h3><ol>\n<li><p>数据传输格式(由json代替了)</p>\n</li>\n<li><p>数据库存储格式</p>\n</li>\n<li><p>应用程序的配置文件(主要用于web开发,以及框架的配置)</p>\n<p>配置文件常格式: .xml .properties  .yml</p>\n</li>\n</ol>\n<h3 id=\"三、xml基本组成部分\"><a href=\"#三、xml基本组成部分\" class=\"headerlink\" title=\"三、xml基本组成部分\"></a>三、xml基本组成部分</h3><ol>\n<li><p>声明</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>指定版本号和编码方式</p>\n</li>\n<li><p>DTD约束&#x2F;Schemal约束</p>\n<p>主要用于约束当前xml文件应该写那些标签，<br>以及这些标签所出现的先后顺序和嵌套顺序如果没有DTD约束，<br>那么标签可以自己随便写</p>\n</li>\n<li><p>标签Tag(一对尖括号)</p>\n</li>\n<li><p>元素Element</p>\n<p>元素&#x3D;开始标签+中间内容+结束标签</p>\n</li>\n<li><p>根元素RootElement</p>\n<p>一篇xml文档有且仅有一个根元素</p>\n</li>\n<li><p>属性Attribute</p>\n<p>以key&#x3D;value形式出现在开始标签中</p>\n<p>属性值必须带上单引号或者双引号</p>\n</li>\n<li><p>节点Node</p>\n</li>\n<li><p>文档对象</p>\n</li>\n</ol>\n<h3 id=\"四、xml解析\"><a href=\"#四、xml解析\" class=\"headerlink\" title=\"四、xml解析\"></a>四、xml解析</h3><p>从xml文件提取出我们想要的数据</p>\n<ol>\n<li>dom解析               </li>\n<li>dom4解析</li>\n<li>pull解析</li>\n<li>sax解析</li>\n</ol>\n"},{"title":"MarkDown基本语法","date":"2022-07-20T03:18:57.000Z","cover":"https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg","_content":"\n# MarkDown基本语法\n> `MarkDown`是一个快速实现文档排版及添加基本样式的语法工具，基于`MarkDown`语法的文件可以快速导出`PDF`文档，或者带有对应样式的`html`文档。是现代博客的主流书写方式。\n\n### 1.标题\n`Markdown`语法中的标题与网页中的标题标签对应，根据字号大小分为`h1~h6`共6个标题。\n** 基本语法：**\n- `h1`： \\# 空格 标题文字\n- `h2`： \\## 空格 标题文字\n- `h3`： \\### 空格 标题文字\n- `h4`： \\#### 空格 标题文字\n- `h5`： \\##### 空格 标题文字\n- `h6`： \\###### 空格 标题文字\n**Typora快捷键: **\n- `h1`： `ctrl+1`\n- `h2`： `ctrl+2`\n- `h3`： `ctrl+3`\n- `h4`： `ctrl+4`\n- `h5`： `ctrl+5`\n- `h6`： `ctrl+6`\n\n### 2.引用\n在一篇博客中，经常需要引用其他文章，此时可以使用引用语法来引入。\n**基本语法**\n- 一级引用：\\> 空格 引用文字\n- 二级引用：\\>> 空格 引用文字\n- 多级引用：\\>>> 空格 引用文字 （多少级就有多少个尖括号）\n示例：\n>> 这是一段引用文字\n\n### 3.超链接\n文章中经常会加入超链接以引用某些网站的内容。其语法结构如下。\n**基本语法：**\n\\[超链接名称](链接地址)\n**示例：**\n[百度一下，你就知道](https://www.baidu.com)\n\n### 4.引入图片\n文章中经常需要通过图片来佐证当前的内容，故而需要引入对应图片。图片分为如下两种形式：\n- 本地图片：与当前文档出于同一个电脑上，一般情况下会与文档出于同一个文件夹中，此时该图片的访问路径为相对路径。\n例如：`./xxx.jpg`或者`../images/xxx.jpg`\n- 网络图片：在服务器上的一个完整的图片地址。\n例如：`https://img.baidu.com/xxx.jpg`\n**基本语法：**\n\\!\\[alt图片未加载是显示的说明文字](图片地址，可以是本地图片，也可以是网络图片)\n例如：\n![这是一张风景图](https://xxxxx.com)\n\n### 5.列表\n文档中经常使用列表来描述几项信息，列表通常表现为有序列表和无序列表。\n- 有序列表：以数字序号为序，序号从1开始递增。一般用于描述有先后顺序的内容。\n- 无序列表：以圆点为序号，用于表示并列的几项内容。与顺序无关。\n**基本语法：**\n- 无序列表：\\- 空格 列表内容\n- 有序列表： 1. 空格 列表内容\n>注意：两种列表在默认情况下，只需要写一行指令即可进入当前列表，第二项开始回车换行后自动加入序号。\n\n\n### 6.表格\n表格是用于组织管理一组结构相似或者一致的数据。按照数据结构的要求，我们 可以定义每个数据的数据项，我们称之为表头。每一行数据称为一条表格记录。这样的行列模式方便查找和修改。\n**基本语法：**\n\\|表头1|表头2|表头3|\n\\|---|---|---|\n\\|数据项|数据项|数据项|\n\\|数据项2|数据项2|数据项2|\n例如：\n|表头1|表头2|表头3|\n|---|---|---|\n|数据项|数据项|数据项|\n|数据项2|数据项2|数据项2|\n\n**语法特点：**\n- 表头与数据项之间会有一行控制行，格式为：|---|---|\n- 表头文字与数据项文字左右两边通过竖线包含，格式为：|文字|文字|\n- 表头控制行可以控制为当前列的对齐方式，默认为左对齐。\n1.左对齐可以写成 |:--|\n2.居中对齐可以写成 |:--:|\n3.右对齐可以写成 |--:|\n\n### 7.代码\n博客中经常需要添加代码显示，代码分为单行代码和代码块。\n**基本语法：**\n- 单行代码：\\`单行代码\\`\n- 代码块：\\`\\`\\`语言类型 代码块\\`\\`\\`\n例如：\n单行代码：`int a = 0;`\n代码块：\n```c\nfor(int i = 0;i<10;i++){\n\tprintf(\"%d\",i)\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/markdown基本语法.md","raw":"---\ntitle: MarkDown基本语法\ndate: 2022-07-20 11:18:57\ntags: 计算机学习\ncategories: 计算机学习\ncover: https://w.wallhaven.cc/full/85/wallhaven-85gw6k.jpg \n---\n\n# MarkDown基本语法\n> `MarkDown`是一个快速实现文档排版及添加基本样式的语法工具，基于`MarkDown`语法的文件可以快速导出`PDF`文档，或者带有对应样式的`html`文档。是现代博客的主流书写方式。\n\n### 1.标题\n`Markdown`语法中的标题与网页中的标题标签对应，根据字号大小分为`h1~h6`共6个标题。\n** 基本语法：**\n- `h1`： \\# 空格 标题文字\n- `h2`： \\## 空格 标题文字\n- `h3`： \\### 空格 标题文字\n- `h4`： \\#### 空格 标题文字\n- `h5`： \\##### 空格 标题文字\n- `h6`： \\###### 空格 标题文字\n**Typora快捷键: **\n- `h1`： `ctrl+1`\n- `h2`： `ctrl+2`\n- `h3`： `ctrl+3`\n- `h4`： `ctrl+4`\n- `h5`： `ctrl+5`\n- `h6`： `ctrl+6`\n\n### 2.引用\n在一篇博客中，经常需要引用其他文章，此时可以使用引用语法来引入。\n**基本语法**\n- 一级引用：\\> 空格 引用文字\n- 二级引用：\\>> 空格 引用文字\n- 多级引用：\\>>> 空格 引用文字 （多少级就有多少个尖括号）\n示例：\n>> 这是一段引用文字\n\n### 3.超链接\n文章中经常会加入超链接以引用某些网站的内容。其语法结构如下。\n**基本语法：**\n\\[超链接名称](链接地址)\n**示例：**\n[百度一下，你就知道](https://www.baidu.com)\n\n### 4.引入图片\n文章中经常需要通过图片来佐证当前的内容，故而需要引入对应图片。图片分为如下两种形式：\n- 本地图片：与当前文档出于同一个电脑上，一般情况下会与文档出于同一个文件夹中，此时该图片的访问路径为相对路径。\n例如：`./xxx.jpg`或者`../images/xxx.jpg`\n- 网络图片：在服务器上的一个完整的图片地址。\n例如：`https://img.baidu.com/xxx.jpg`\n**基本语法：**\n\\!\\[alt图片未加载是显示的说明文字](图片地址，可以是本地图片，也可以是网络图片)\n例如：\n![这是一张风景图](https://xxxxx.com)\n\n### 5.列表\n文档中经常使用列表来描述几项信息，列表通常表现为有序列表和无序列表。\n- 有序列表：以数字序号为序，序号从1开始递增。一般用于描述有先后顺序的内容。\n- 无序列表：以圆点为序号，用于表示并列的几项内容。与顺序无关。\n**基本语法：**\n- 无序列表：\\- 空格 列表内容\n- 有序列表： 1. 空格 列表内容\n>注意：两种列表在默认情况下，只需要写一行指令即可进入当前列表，第二项开始回车换行后自动加入序号。\n\n\n### 6.表格\n表格是用于组织管理一组结构相似或者一致的数据。按照数据结构的要求，我们 可以定义每个数据的数据项，我们称之为表头。每一行数据称为一条表格记录。这样的行列模式方便查找和修改。\n**基本语法：**\n\\|表头1|表头2|表头3|\n\\|---|---|---|\n\\|数据项|数据项|数据项|\n\\|数据项2|数据项2|数据项2|\n例如：\n|表头1|表头2|表头3|\n|---|---|---|\n|数据项|数据项|数据项|\n|数据项2|数据项2|数据项2|\n\n**语法特点：**\n- 表头与数据项之间会有一行控制行，格式为：|---|---|\n- 表头文字与数据项文字左右两边通过竖线包含，格式为：|文字|文字|\n- 表头控制行可以控制为当前列的对齐方式，默认为左对齐。\n1.左对齐可以写成 |:--|\n2.居中对齐可以写成 |:--:|\n3.右对齐可以写成 |--:|\n\n### 7.代码\n博客中经常需要添加代码显示，代码分为单行代码和代码块。\n**基本语法：**\n- 单行代码：\\`单行代码\\`\n- 代码块：\\`\\`\\`语言类型 代码块\\`\\`\\`\n例如：\n单行代码：`int a = 0;`\n代码块：\n```c\nfor(int i = 0;i<10;i++){\n\tprintf(\"%d\",i)\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"markdown基本语法","published":1,"updated":"2023-08-10T07:47:28.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9w001kfswob61xeb70","content":"<h1 id=\"MarkDown基本语法\"><a href=\"#MarkDown基本语法\" class=\"headerlink\" title=\"MarkDown基本语法\"></a>MarkDown基本语法</h1><blockquote>\n<p><code>MarkDown</code>是一个快速实现文档排版及添加基本样式的语法工具，基于<code>MarkDown</code>语法的文件可以快速导出<code>PDF</code>文档，或者带有对应样式的<code>html</code>文档。是现代博客的主流书写方式。</p>\n</blockquote>\n<h3 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h3><p><code>Markdown</code>语法中的标题与网页中的标题标签对应，根据字号大小分为<code>h1~h6</code>共6个标题。<br>** 基本语法：**</p>\n<ul>\n<li><code>h1</code>： # 空格 标题文字</li>\n<li><code>h2</code>： ## 空格 标题文字</li>\n<li><code>h3</code>： ### 空格 标题文字</li>\n<li><code>h4</code>： #### 空格 标题文字</li>\n<li><code>h5</code>： ##### 空格 标题文字</li>\n<li><code>h6</code>： ###### 空格 标题文字<br>**Typora快捷键: **</li>\n<li><code>h1</code>： <code>ctrl+1</code></li>\n<li><code>h2</code>： <code>ctrl+2</code></li>\n<li><code>h3</code>： <code>ctrl+3</code></li>\n<li><code>h4</code>： <code>ctrl+4</code></li>\n<li><code>h5</code>： <code>ctrl+5</code></li>\n<li><code>h6</code>： <code>ctrl+6</code></li>\n</ul>\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h3><p>在一篇博客中，经常需要引用其他文章，此时可以使用引用语法来引入。<br><strong>基本语法</strong></p>\n<ul>\n<li>一级引用：&gt; 空格 引用文字</li>\n<li>二级引用：&gt;&gt; 空格 引用文字</li>\n<li>多级引用：&gt;&gt;&gt; 空格 引用文字 （多少级就有多少个尖括号）<br>示例：<blockquote>\n<blockquote>\n<p>这是一段引用文字</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3-超链接\"><a href=\"#3-超链接\" class=\"headerlink\" title=\"3.超链接\"></a>3.超链接</h3><p>文章中经常会加入超链接以引用某些网站的内容。其语法结构如下。<br><strong>基本语法：</strong><br>[超链接名称](链接地址)<br><strong>示例：</strong><br><a href=\"https://www.baidu.com/\">百度一下，你就知道</a></p>\n<h3 id=\"4-引入图片\"><a href=\"#4-引入图片\" class=\"headerlink\" title=\"4.引入图片\"></a>4.引入图片</h3><p>文章中经常需要通过图片来佐证当前的内容，故而需要引入对应图片。图片分为如下两种形式：</p>\n<ul>\n<li>本地图片：与当前文档出于同一个电脑上，一般情况下会与文档出于同一个文件夹中，此时该图片的访问路径为相对路径。<br>例如：<code>./xxx.jpg</code>或者<code>../images/xxx.jpg</code></li>\n<li>网络图片：在服务器上的一个完整的图片地址。<br>例如：<code>https://img.baidu.com/xxx.jpg</code><br><strong>基本语法：</strong><br>![alt图片未加载是显示的说明文字](图片地址，可以是本地图片，也可以是网络图片)<br>例如：<br><img src=\"https://xxxxx.com/\" alt=\"这是一张风景图\"></li>\n</ul>\n<h3 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h3><p>文档中经常使用列表来描述几项信息，列表通常表现为有序列表和无序列表。</p>\n<ul>\n<li>有序列表：以数字序号为序，序号从1开始递增。一般用于描述有先后顺序的内容。</li>\n<li>无序列表：以圆点为序号，用于表示并列的几项内容。与顺序无关。<br><strong>基本语法：</strong></li>\n<li>无序列表：- 空格 列表内容</li>\n<li>有序列表： 1. 空格 列表内容<blockquote>\n<p>注意：两种列表在默认情况下，只需要写一行指令即可进入当前列表，第二项开始回车换行后自动加入序号。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"6-表格\"><a href=\"#6-表格\" class=\"headerlink\" title=\"6.表格\"></a>6.表格</h3><p>表格是用于组织管理一组结构相似或者一致的数据。按照数据结构的要求，我们 可以定义每个数据的数据项，我们称之为表头。每一行数据称为一条表格记录。这样的行列模式方便查找和修改。<br><strong>基本语法：</strong><br>|表头1|表头2|表头3|<br>|—|—|—|<br>|数据项|数据项|数据项|<br>|数据项2|数据项2|数据项2|<br>例如：</p>\n<table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n<th>表头3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据项</td>\n<td>数据项</td>\n<td>数据项</td>\n</tr>\n<tr>\n<td>数据项2</td>\n<td>数据项2</td>\n<td>数据项2</td>\n</tr>\n</tbody></table>\n<p><strong>语法特点：</strong></p>\n<ul>\n<li>表头与数据项之间会有一行控制行，格式为：|—|—|</li>\n<li>表头文字与数据项文字左右两边通过竖线包含，格式为：|文字|文字|</li>\n<li>表头控制行可以控制为当前列的对齐方式，默认为左对齐。<br>1.左对齐可以写成 |:–|<br>2.居中对齐可以写成 |:–:|<br>3.右对齐可以写成 |–:|</li>\n</ul>\n<h3 id=\"7-代码\"><a href=\"#7-代码\" class=\"headerlink\" title=\"7.代码\"></a>7.代码</h3><p>博客中经常需要添加代码显示，代码分为单行代码和代码块。<br><strong>基本语法：</strong></p>\n<ul>\n<li>单行代码：`单行代码`</li>\n<li>代码块：```语言类型 代码块```<br>例如：<br>单行代码：<code>int a = 0;</code><br>代码块：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"MarkDown基本语法\"><a href=\"#MarkDown基本语法\" class=\"headerlink\" title=\"MarkDown基本语法\"></a>MarkDown基本语法</h1><blockquote>\n<p><code>MarkDown</code>是一个快速实现文档排版及添加基本样式的语法工具，基于<code>MarkDown</code>语法的文件可以快速导出<code>PDF</code>文档，或者带有对应样式的<code>html</code>文档。是现代博客的主流书写方式。</p>\n</blockquote>\n<h3 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h3><p><code>Markdown</code>语法中的标题与网页中的标题标签对应，根据字号大小分为<code>h1~h6</code>共6个标题。<br>** 基本语法：**</p>\n<ul>\n<li><code>h1</code>： # 空格 标题文字</li>\n<li><code>h2</code>： ## 空格 标题文字</li>\n<li><code>h3</code>： ### 空格 标题文字</li>\n<li><code>h4</code>： #### 空格 标题文字</li>\n<li><code>h5</code>： ##### 空格 标题文字</li>\n<li><code>h6</code>： ###### 空格 标题文字<br>**Typora快捷键: **</li>\n<li><code>h1</code>： <code>ctrl+1</code></li>\n<li><code>h2</code>： <code>ctrl+2</code></li>\n<li><code>h3</code>： <code>ctrl+3</code></li>\n<li><code>h4</code>： <code>ctrl+4</code></li>\n<li><code>h5</code>： <code>ctrl+5</code></li>\n<li><code>h6</code>： <code>ctrl+6</code></li>\n</ul>\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h3><p>在一篇博客中，经常需要引用其他文章，此时可以使用引用语法来引入。<br><strong>基本语法</strong></p>\n<ul>\n<li>一级引用：&gt; 空格 引用文字</li>\n<li>二级引用：&gt;&gt; 空格 引用文字</li>\n<li>多级引用：&gt;&gt;&gt; 空格 引用文字 （多少级就有多少个尖括号）<br>示例：<blockquote>\n<blockquote>\n<p>这是一段引用文字</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3-超链接\"><a href=\"#3-超链接\" class=\"headerlink\" title=\"3.超链接\"></a>3.超链接</h3><p>文章中经常会加入超链接以引用某些网站的内容。其语法结构如下。<br><strong>基本语法：</strong><br>[超链接名称](链接地址)<br><strong>示例：</strong><br><a href=\"https://www.baidu.com/\">百度一下，你就知道</a></p>\n<h3 id=\"4-引入图片\"><a href=\"#4-引入图片\" class=\"headerlink\" title=\"4.引入图片\"></a>4.引入图片</h3><p>文章中经常需要通过图片来佐证当前的内容，故而需要引入对应图片。图片分为如下两种形式：</p>\n<ul>\n<li>本地图片：与当前文档出于同一个电脑上，一般情况下会与文档出于同一个文件夹中，此时该图片的访问路径为相对路径。<br>例如：<code>./xxx.jpg</code>或者<code>../images/xxx.jpg</code></li>\n<li>网络图片：在服务器上的一个完整的图片地址。<br>例如：<code>https://img.baidu.com/xxx.jpg</code><br><strong>基本语法：</strong><br>![alt图片未加载是显示的说明文字](图片地址，可以是本地图片，也可以是网络图片)<br>例如：<br><img src=\"https://xxxxx.com/\" alt=\"这是一张风景图\"></li>\n</ul>\n<h3 id=\"5-列表\"><a href=\"#5-列表\" class=\"headerlink\" title=\"5.列表\"></a>5.列表</h3><p>文档中经常使用列表来描述几项信息，列表通常表现为有序列表和无序列表。</p>\n<ul>\n<li>有序列表：以数字序号为序，序号从1开始递增。一般用于描述有先后顺序的内容。</li>\n<li>无序列表：以圆点为序号，用于表示并列的几项内容。与顺序无关。<br><strong>基本语法：</strong></li>\n<li>无序列表：- 空格 列表内容</li>\n<li>有序列表： 1. 空格 列表内容<blockquote>\n<p>注意：两种列表在默认情况下，只需要写一行指令即可进入当前列表，第二项开始回车换行后自动加入序号。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"6-表格\"><a href=\"#6-表格\" class=\"headerlink\" title=\"6.表格\"></a>6.表格</h3><p>表格是用于组织管理一组结构相似或者一致的数据。按照数据结构的要求，我们 可以定义每个数据的数据项，我们称之为表头。每一行数据称为一条表格记录。这样的行列模式方便查找和修改。<br><strong>基本语法：</strong><br>|表头1|表头2|表头3|<br>|—|—|—|<br>|数据项|数据项|数据项|<br>|数据项2|数据项2|数据项2|<br>例如：</p>\n<table>\n<thead>\n<tr>\n<th>表头1</th>\n<th>表头2</th>\n<th>表头3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据项</td>\n<td>数据项</td>\n<td>数据项</td>\n</tr>\n<tr>\n<td>数据项2</td>\n<td>数据项2</td>\n<td>数据项2</td>\n</tr>\n</tbody></table>\n<p><strong>语法特点：</strong></p>\n<ul>\n<li>表头与数据项之间会有一行控制行，格式为：|—|—|</li>\n<li>表头文字与数据项文字左右两边通过竖线包含，格式为：|文字|文字|</li>\n<li>表头控制行可以控制为当前列的对齐方式，默认为左对齐。<br>1.左对齐可以写成 |:–|<br>2.居中对齐可以写成 |:–:|<br>3.右对齐可以写成 |–:|</li>\n</ul>\n<h3 id=\"7-代码\"><a href=\"#7-代码\" class=\"headerlink\" title=\"7.代码\"></a>7.代码</h3><p>博客中经常需要添加代码显示，代码分为单行代码和代码块。<br><strong>基本语法：</strong></p>\n<ul>\n<li>单行代码：`单行代码`</li>\n<li>代码块：```语言类型 代码块```<br>例如：<br>单行代码：<code>int a = 0;</code><br>代码块：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"到底什么是CDN？","date":"2022-07-18T03:18:57.000Z","cover":"/img/images/mesh2.jpg","_content":"# 到底什么是CDN？\n\n### **`CDN`的诞生**\n\n利用数学运算法则来处理内容的动态路由算法技术\n\n### **`CDN`的原理**\n\n`CDN`这个技术其实说起来并不复杂，最初的核心理念，就是**将内容缓存在终端用户附近**。\n\n内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？\n\n\n\n\n\n![动图封面](https://pic1.zhimg.com/v2-aa9f483b52208241bcbbe6ce95028344_b.jpg)\n\n\n\n\n\n\n\n因为这项技术是把内容进行了分发，所以，它的名字就叫做`CDN——**Content Delivery Network`，内容分发网络**。\n\n**`CDN`=更智能的镜像+缓存+流量导流**。\n\n### **`CDN`的好处**\n\n采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。\n\n### **`CDN`和通信行业**\n\n互联网服务提供商采用`CDN`，是**以存储换时延**。花钱购置`CDN`服务器或云计算服务，以此换取更好的用户体验。\n\n通信运营商也追捧`CDN`，但它们的目的，是**以存储换带宽**——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。\n\n这个很好理解啊，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。不是么？\n\n\n\n\n\n![img](https://pic2.zhimg.com/80/v2-3c80761e11564dff74e73841f243979d_720w.webp)\n\n\n\n\n\n很多运营商已经将`CDN`下沉到地市级，以此减轻压力，同时可以提升用户体验。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/到底什么是CDN.md","raw":"---\ntitle: 到底什么是CDN？\ndate: 2022-07-18 11:18:57\ntags: 网络\ncategories: 网络\ncover: /img/images/mesh2.jpg\n---\n# 到底什么是CDN？\n\n### **`CDN`的诞生**\n\n利用数学运算法则来处理内容的动态路由算法技术\n\n### **`CDN`的原理**\n\n`CDN`这个技术其实说起来并不复杂，最初的核心理念，就是**将内容缓存在终端用户附近**。\n\n内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？\n\n\n\n\n\n![动图封面](https://pic1.zhimg.com/v2-aa9f483b52208241bcbbe6ce95028344_b.jpg)\n\n\n\n\n\n\n\n因为这项技术是把内容进行了分发，所以，它的名字就叫做`CDN——**Content Delivery Network`，内容分发网络**。\n\n**`CDN`=更智能的镜像+缓存+流量导流**。\n\n### **`CDN`的好处**\n\n采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。\n\n### **`CDN`和通信行业**\n\n互联网服务提供商采用`CDN`，是**以存储换时延**。花钱购置`CDN`服务器或云计算服务，以此换取更好的用户体验。\n\n通信运营商也追捧`CDN`，但它们的目的，是**以存储换带宽**——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。\n\n这个很好理解啊，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。不是么？\n\n\n\n\n\n![img](https://pic2.zhimg.com/80/v2-3c80761e11564dff74e73841f243979d_720w.webp)\n\n\n\n\n\n很多运营商已经将`CDN`下沉到地市级，以此减轻压力，同时可以提升用户体验。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"到底什么是CDN","published":1,"updated":"2023-08-10T09:34:59.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9x001nfswo7m1baiuf","content":"<h1 id=\"到底什么是CDN？\"><a href=\"#到底什么是CDN？\" class=\"headerlink\" title=\"到底什么是CDN？\"></a>到底什么是CDN？</h1><h3 id=\"CDN的诞生\"><a href=\"#CDN的诞生\" class=\"headerlink\" title=\"CDN的诞生\"></a><strong><code>CDN</code>的诞生</strong></h3><p>利用数学运算法则来处理内容的动态路由算法技术</p>\n<h3 id=\"CDN的原理\"><a href=\"#CDN的原理\" class=\"headerlink\" title=\"CDN的原理\"></a><strong><code>CDN</code>的原理</strong></h3><p><code>CDN</code>这个技术其实说起来并不复杂，最初的核心理念，就是<strong>将内容缓存在终端用户附近</strong>。</p>\n<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>\n<p><img src=\"https://pic1.zhimg.com/v2-aa9f483b52208241bcbbe6ce95028344_b.jpg\" alt=\"动图封面\"></p>\n<p>因为这项技术是把内容进行了分发，所以，它的名字就叫做<code>CDN——**Content Delivery Network</code>，内容分发网络**。</p>\n<p><strong><code>CDN</code>&#x3D;更智能的镜像+缓存+流量导流</strong>。</p>\n<h3 id=\"CDN的好处\"><a href=\"#CDN的好处\" class=\"headerlink\" title=\"CDN的好处\"></a><strong><code>CDN</code>的好处</strong></h3><p>采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</p>\n<h3 id=\"CDN和通信行业\"><a href=\"#CDN和通信行业\" class=\"headerlink\" title=\"CDN和通信行业\"></a><strong><code>CDN</code>和通信行业</strong></h3><p>互联网服务提供商采用<code>CDN</code>，是<strong>以存储换时延</strong>。花钱购置<code>CDN</code>服务器或云计算服务，以此换取更好的用户体验。</p>\n<p>通信运营商也追捧<code>CDN</code>，但它们的目的，是<strong>以存储换带宽</strong>——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。</p>\n<p>这个很好理解啊，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。不是么？</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-3c80761e11564dff74e73841f243979d_720w.webp\" alt=\"img\"></p>\n<p>很多运营商已经将<code>CDN</code>下沉到地市级，以此减轻压力，同时可以提升用户体验。</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"到底什么是CDN？\"><a href=\"#到底什么是CDN？\" class=\"headerlink\" title=\"到底什么是CDN？\"></a>到底什么是CDN？</h1><h3 id=\"CDN的诞生\"><a href=\"#CDN的诞生\" class=\"headerlink\" title=\"CDN的诞生\"></a><strong><code>CDN</code>的诞生</strong></h3><p>利用数学运算法则来处理内容的动态路由算法技术</p>\n<h3 id=\"CDN的原理\"><a href=\"#CDN的原理\" class=\"headerlink\" title=\"CDN的原理\"></a><strong><code>CDN</code>的原理</strong></h3><p><code>CDN</code>这个技术其实说起来并不复杂，最初的核心理念，就是<strong>将内容缓存在终端用户附近</strong>。</p>\n<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>\n<p><img src=\"https://pic1.zhimg.com/v2-aa9f483b52208241bcbbe6ce95028344_b.jpg\" alt=\"动图封面\"></p>\n<p>因为这项技术是把内容进行了分发，所以，它的名字就叫做<code>CDN——**Content Delivery Network</code>，内容分发网络**。</p>\n<p><strong><code>CDN</code>&#x3D;更智能的镜像+缓存+流量导流</strong>。</p>\n<h3 id=\"CDN的好处\"><a href=\"#CDN的好处\" class=\"headerlink\" title=\"CDN的好处\"></a><strong><code>CDN</code>的好处</strong></h3><p>采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</p>\n<h3 id=\"CDN和通信行业\"><a href=\"#CDN和通信行业\" class=\"headerlink\" title=\"CDN和通信行业\"></a><strong><code>CDN</code>和通信行业</strong></h3><p>互联网服务提供商采用<code>CDN</code>，是<strong>以存储换时延</strong>。花钱购置<code>CDN</code>服务器或云计算服务，以此换取更好的用户体验。</p>\n<p>通信运营商也追捧<code>CDN</code>，但它们的目的，是<strong>以存储换带宽</strong>——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。</p>\n<p>这个很好理解啊，如果大量的业务流量数据在骨干网跑来跑去，骨干网肯定吃不消，要拼命扩容。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。不是么？</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-3c80761e11564dff74e73841f243979d_720w.webp\" alt=\"img\"></p>\n<p>很多运营商已经将<code>CDN</code>下沉到地市级，以此减轻压力，同时可以提升用户体验。</p>\n"},{"title":"代理模式","date":"2023-03-12T03:18:57.000Z","cover":"/img/images/earth.png","_content":"# 代理模式\n\n​\t代理模式是常见的设计模式之一，顾名思义，代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执行的前后，对操作进行增强处理。（为真实对象提供代理，然后供其他对象通过代理访问真实对象）\n\n|   角色   | 作用                                                         |\n| :------: | :----------------------------------------------------------- |\n| 抽象角色 | 声明真实对象和代理对象的共同接口                             |\n| 代理角色 | 代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能够代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 |\n| 真实角色 | 代理角色所代表的真实对象，是我们最终要引用的对象             |\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n**应用场景**\n 静态代理主要用来处理少部分类的托管或者扩展。静态代理对于被代理的对象很固定，我们只需要去代理一个类或者若干固定的类，数量不是太多的时候，可以使用，而且其实效果比动态代理更好。\n 动态代理在运行期间动态生成代理类，需要消耗的时间会更久一点。优点是可以做很多类的扩展（譬如可以通过动态代理实现aop，hibernate使用cglib来代理单端多对一和一对一关联等）。而且如果一个类的接口发生了变化，那么静态代理这时候修改起来就很麻烦了。这就是说动态代理灵活的原因。\n\n动态代理主流的实现有两种，一种是基于接口的Java Proxy的代理机制，一种是基于继承的cglib代理机制。两种也都有其应用场景。（视乎具体业务逻辑而言）\n\n## 静态代理\n\n#### 一、基于类实现静态代理\n\n1、首先编写核心业务(被代理类)\n\n```java\npublic class Service{\n    public void insert(){\n        //核心业务\n        System.out.println(\"Service-----insert\")\n    }\n}\n```\n\n2、编写代理类(代理类需要继承被代理类)\n\n```java\npublic class ProxyService extends Service{\n    public void insert(){\n        try{\n            System.out.println(\"开始事务\")；\n            super.insert();//核心业务；\n            System.out.println(\"提交事务\")；\n        }catch{\n            System.out.println(\"回滚事务\")；\n        }\n    }\n}\n```\n\n3.测试\n\n```java\npublic class Test{\n    public static void main(){\n        ProxyService ps = new ProxyService();\n        ps.insert();\n    }\n}\n```\n\n#### 二、基于接口实现静态代理\n\n1、首先编写一个接口(与它相关的核心业务类都要实现本接口)\n\n```java\npublic interface IService{\n    void insert();\n}\n```\n\n2、编写一个核心业务类并实现接口(接口的实现类)\n\n```java\npublic class Service implements IService{\n    @Override\n    public void insert(){\n        //核心业务\n        System.out.println(\"Service--------insert\")\n    }\n}\n```\n\n3、编写一个代理类\n\n> 1. 私有一个接口对象IService，这个是我们后面要被代理的对象；\n> 2. 写一个一参构造方法，当外面要创建本ProxyTranService 代理对象时，需要传递一个实现了IService接口的核心业务类才能创建代理对象；\n> 3. 本ProxyTranService 代理对象也要实现IService接口；\n> 4. 本类重写的核心方法由外部传进来的被代理对象提供，其他业务由本代理提供。\n\n```java\npublic class ProxyTranService implements IService{\n    private IService service;//被代理对象\n    public ProxyTranService(IService service){\n        this.service = service;\n    }\n    @Override\n    public void insert(){\n        try{\n            System.out.println(\"开始事务\")；\n            super.insert();//核心业务；\n            System.out.println(\"提交事务\")；\n        }catch{\n            System.out.println(\"回滚事务\")；\n        }\n    }\n}\n```\n\n4、测试\n\n```java\npublic class Test{\n    public static void main(){\n        Service service = new Service();\n        ProxyTranService pts = new ProxyTranService(service);\n        pts.insert();\n    }\n}\n```\n\n\n\n## 动态代理\n\n相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要哦我们必须实现接口，我们可以直接代理实现类(CGLib动态代理机制)\n\n#### JDK动态理机制\n\n在java动态代理机制中InvocationHandler接口和Proxy类是核心\n\nProxy类中使用频率最高的方法是：`newProxyInstance()`,这个方法主要用来生成一个代理对象\n\n```java\npublic static Object newProxyInstance(\n    Classloader loader，\n    Class<?>[] interfaces,\n    InvocationHandler h)\n    throws IllegalArgumentException\n{\n    .........\n}\n```\n\n这个方法一共有三个参数：\n\n| 参数名            | 说明                              |\n| ----------------- | --------------------------------- |\n| loader            | 类加载器，用于加载代理对象        |\n| interfaces        | 被代理类实现的一些接口            |\n| InvocationHandler | 实现了InvocationHandler接口的对象 |\n\n要实现动态代理，还必须需要实现InvocationHandler来自定义处理逻辑。当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用\n\n```java\npublic interface InvocationHandler{\n    //当你使用代理对象调用方法的时候实际会调用到这个方法\n    public Object invoke(Object proxy,Method method,Object[] args) \n        throws Throwable;\n}\n```\n\ninvoke()方法有三个参数\n\n| 参数   | 说明                                               |\n| ------ | -------------------------------------------------- |\n| proxy  | 指代我们所代理的那个真实对象                       |\n| method | 指代的是我们所要调用真实对象的某个方法的Method对象 |\n| args   | 指代的是调用真实对象某个方法时接受的参数           |\n\n1、首先创建目标代理对目标方法的一个接口\n\n```java\npublic interface ISmsService {\n//目标代理对目标方法的一个接口\n/**\n* 发送消息\n* @param msg 消息\n*/\n    void send(String msg);\n}\n```\n\n2、实现 InvocationHandler 接口\n\n```java\n// 实现 InvocationHandler 接口\npublic class SmsInvocationHandler<T extends ISmsService> implements\n    InvocationHandler {\n    private final T target;\n    \n    public SmsInvocationHandler(T target) {\n        this.target = target;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws\n        Throwable {\n        //增强被代理类\n        //输出一个方法名\n        System.out.printf(\"被代理方法执行前运行-----前置通知%n\",method.getName());\n        //被代理类的调用，用到反射\n        Object result = method.invoke(target, args);\n        System.out.printf(\"被代理方法执行后运行-----后置通知%n\",method.getName());\n  \n        return result;\n    }\n}\n```\n\n3、创建代理类工厂、\n\n```java\n// 代理类工厂\n//获取代理类的实例\npublic class SmsProxyFactory {\n    public static ISmsService getProxy(ISmsService target){\n        Class<? extends ISmsService> clazz = target.getClass();\n\n        return (ISmsService) Proxy.newProxyInstance(\n            clazz.getClassLoader(),\n            clazz.getInterfaces(),\n            new SmsInvocationHandler(target)\n        );\n    }\n}\n```\n\n4、创建测试类\n\n```java\npublic class Main {\npublic static void main(String[] args) {\n    ISmsService smsService = msg -> System.out.println(\"被代理目标方法执行\" +\n                                                       msg);\n    ISmsService proxy = SmsProxyFactory.getProxy(smsService);\n    proxy.send(\"你好，世界\");\n    smsService.send(\"-----目标方法---\");\n\t}\n}\n```\n\n## cglib动态代理\n\nCglib依赖于ASM字节码技术，直接生成class文件，在采用类加载器读取到程序中\n使用 fastclass 对被代理类的方法建立索引, 文件不需要依赖于反射查找到目标方法\n所以效率比Jdk动态代理要高。\n\n```java\n/**\n *  cglib动态代理\n */\npublic class CglibMethodInterceptor implements MethodInterceptor {\n    /**\n     * @param obj 执行对象class(被代理类)\n     * @param method 执行对象class的方法\n     * @param args 执行对象class的方法的参数\n     * @param proxy 代理类\n     * @return\n     * @throws Throwable\n     */\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\">> cglib动态代理执行开始\");\n        Object result = proxy.invokeSuper(obj, args);\n        System.out.println(\">> cglib动态代理执行结束\");\n        return result;\n    }\n}\n```\n\n```java\npublic interface MemberService {\n    String addMember(String userName);\n}\n```\n\n```java\npublic class MemberServiceImpl  implements MemberService  {\n    public String addMember(String userName) {\n        System.out.println(\"执行方法-------\");\n        return userName;\n    }\n}\n```\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        // 保存class 文件到-->\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"D:\\\\code\");\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(MemberServiceImpl.class);\n        enhancer.setCallback(new CglibMethodInterceptor());\n        // 创建代理代理对象\n        MemberService memberService = (MemberService) enhancer.create();\n        String res = memberService.addMember(\"123456789\");\n        System.out.println(\"----> cglib动态代理返回数据为：\" + res);\n    }\n}\n```\n\n\n\n### JDK动态代理和CGLib动态代理的区别\n\n##### JDK代理：\n\n利用拦截器（必须实现InvocationHandler接口）加上**反射机制**生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理\n\n##### CGLib代理：\n\n利用ASM框架，对代理对象类生成的class文件加载进来，通过**修改其字节码生成子类来进行代理**\n\n\n\n- **如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;**\n- **如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；**\n\n\n\n","source":"_posts/代理模式.md","raw":"---\ntitle: 代理模式\ndate: 2023-03-12 11:18:57\ntags: 设计模式\ncategories: 设计模式\ncover: /img/images/earth.png\n---\n# 代理模式\n\n​\t代理模式是常见的设计模式之一，顾名思义，代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执行的前后，对操作进行增强处理。（为真实对象提供代理，然后供其他对象通过代理访问真实对象）\n\n|   角色   | 作用                                                         |\n| :------: | :----------------------------------------------------------- |\n| 抽象角色 | 声明真实对象和代理对象的共同接口                             |\n| 代理角色 | 代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能够代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 |\n| 真实角色 | 代理角色所代表的真实对象，是我们最终要引用的对象             |\n\n**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。\n\n**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n**注意事项：** 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n**应用场景**\n 静态代理主要用来处理少部分类的托管或者扩展。静态代理对于被代理的对象很固定，我们只需要去代理一个类或者若干固定的类，数量不是太多的时候，可以使用，而且其实效果比动态代理更好。\n 动态代理在运行期间动态生成代理类，需要消耗的时间会更久一点。优点是可以做很多类的扩展（譬如可以通过动态代理实现aop，hibernate使用cglib来代理单端多对一和一对一关联等）。而且如果一个类的接口发生了变化，那么静态代理这时候修改起来就很麻烦了。这就是说动态代理灵活的原因。\n\n动态代理主流的实现有两种，一种是基于接口的Java Proxy的代理机制，一种是基于继承的cglib代理机制。两种也都有其应用场景。（视乎具体业务逻辑而言）\n\n## 静态代理\n\n#### 一、基于类实现静态代理\n\n1、首先编写核心业务(被代理类)\n\n```java\npublic class Service{\n    public void insert(){\n        //核心业务\n        System.out.println(\"Service-----insert\")\n    }\n}\n```\n\n2、编写代理类(代理类需要继承被代理类)\n\n```java\npublic class ProxyService extends Service{\n    public void insert(){\n        try{\n            System.out.println(\"开始事务\")；\n            super.insert();//核心业务；\n            System.out.println(\"提交事务\")；\n        }catch{\n            System.out.println(\"回滚事务\")；\n        }\n    }\n}\n```\n\n3.测试\n\n```java\npublic class Test{\n    public static void main(){\n        ProxyService ps = new ProxyService();\n        ps.insert();\n    }\n}\n```\n\n#### 二、基于接口实现静态代理\n\n1、首先编写一个接口(与它相关的核心业务类都要实现本接口)\n\n```java\npublic interface IService{\n    void insert();\n}\n```\n\n2、编写一个核心业务类并实现接口(接口的实现类)\n\n```java\npublic class Service implements IService{\n    @Override\n    public void insert(){\n        //核心业务\n        System.out.println(\"Service--------insert\")\n    }\n}\n```\n\n3、编写一个代理类\n\n> 1. 私有一个接口对象IService，这个是我们后面要被代理的对象；\n> 2. 写一个一参构造方法，当外面要创建本ProxyTranService 代理对象时，需要传递一个实现了IService接口的核心业务类才能创建代理对象；\n> 3. 本ProxyTranService 代理对象也要实现IService接口；\n> 4. 本类重写的核心方法由外部传进来的被代理对象提供，其他业务由本代理提供。\n\n```java\npublic class ProxyTranService implements IService{\n    private IService service;//被代理对象\n    public ProxyTranService(IService service){\n        this.service = service;\n    }\n    @Override\n    public void insert(){\n        try{\n            System.out.println(\"开始事务\")；\n            super.insert();//核心业务；\n            System.out.println(\"提交事务\")；\n        }catch{\n            System.out.println(\"回滚事务\")；\n        }\n    }\n}\n```\n\n4、测试\n\n```java\npublic class Test{\n    public static void main(){\n        Service service = new Service();\n        ProxyTranService pts = new ProxyTranService(service);\n        pts.insert();\n    }\n}\n```\n\n\n\n## 动态代理\n\n相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要哦我们必须实现接口，我们可以直接代理实现类(CGLib动态代理机制)\n\n#### JDK动态理机制\n\n在java动态代理机制中InvocationHandler接口和Proxy类是核心\n\nProxy类中使用频率最高的方法是：`newProxyInstance()`,这个方法主要用来生成一个代理对象\n\n```java\npublic static Object newProxyInstance(\n    Classloader loader，\n    Class<?>[] interfaces,\n    InvocationHandler h)\n    throws IllegalArgumentException\n{\n    .........\n}\n```\n\n这个方法一共有三个参数：\n\n| 参数名            | 说明                              |\n| ----------------- | --------------------------------- |\n| loader            | 类加载器，用于加载代理对象        |\n| interfaces        | 被代理类实现的一些接口            |\n| InvocationHandler | 实现了InvocationHandler接口的对象 |\n\n要实现动态代理，还必须需要实现InvocationHandler来自定义处理逻辑。当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用\n\n```java\npublic interface InvocationHandler{\n    //当你使用代理对象调用方法的时候实际会调用到这个方法\n    public Object invoke(Object proxy,Method method,Object[] args) \n        throws Throwable;\n}\n```\n\ninvoke()方法有三个参数\n\n| 参数   | 说明                                               |\n| ------ | -------------------------------------------------- |\n| proxy  | 指代我们所代理的那个真实对象                       |\n| method | 指代的是我们所要调用真实对象的某个方法的Method对象 |\n| args   | 指代的是调用真实对象某个方法时接受的参数           |\n\n1、首先创建目标代理对目标方法的一个接口\n\n```java\npublic interface ISmsService {\n//目标代理对目标方法的一个接口\n/**\n* 发送消息\n* @param msg 消息\n*/\n    void send(String msg);\n}\n```\n\n2、实现 InvocationHandler 接口\n\n```java\n// 实现 InvocationHandler 接口\npublic class SmsInvocationHandler<T extends ISmsService> implements\n    InvocationHandler {\n    private final T target;\n    \n    public SmsInvocationHandler(T target) {\n        this.target = target;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws\n        Throwable {\n        //增强被代理类\n        //输出一个方法名\n        System.out.printf(\"被代理方法执行前运行-----前置通知%n\",method.getName());\n        //被代理类的调用，用到反射\n        Object result = method.invoke(target, args);\n        System.out.printf(\"被代理方法执行后运行-----后置通知%n\",method.getName());\n  \n        return result;\n    }\n}\n```\n\n3、创建代理类工厂、\n\n```java\n// 代理类工厂\n//获取代理类的实例\npublic class SmsProxyFactory {\n    public static ISmsService getProxy(ISmsService target){\n        Class<? extends ISmsService> clazz = target.getClass();\n\n        return (ISmsService) Proxy.newProxyInstance(\n            clazz.getClassLoader(),\n            clazz.getInterfaces(),\n            new SmsInvocationHandler(target)\n        );\n    }\n}\n```\n\n4、创建测试类\n\n```java\npublic class Main {\npublic static void main(String[] args) {\n    ISmsService smsService = msg -> System.out.println(\"被代理目标方法执行\" +\n                                                       msg);\n    ISmsService proxy = SmsProxyFactory.getProxy(smsService);\n    proxy.send(\"你好，世界\");\n    smsService.send(\"-----目标方法---\");\n\t}\n}\n```\n\n## cglib动态代理\n\nCglib依赖于ASM字节码技术，直接生成class文件，在采用类加载器读取到程序中\n使用 fastclass 对被代理类的方法建立索引, 文件不需要依赖于反射查找到目标方法\n所以效率比Jdk动态代理要高。\n\n```java\n/**\n *  cglib动态代理\n */\npublic class CglibMethodInterceptor implements MethodInterceptor {\n    /**\n     * @param obj 执行对象class(被代理类)\n     * @param method 执行对象class的方法\n     * @param args 执行对象class的方法的参数\n     * @param proxy 代理类\n     * @return\n     * @throws Throwable\n     */\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\">> cglib动态代理执行开始\");\n        Object result = proxy.invokeSuper(obj, args);\n        System.out.println(\">> cglib动态代理执行结束\");\n        return result;\n    }\n}\n```\n\n```java\npublic interface MemberService {\n    String addMember(String userName);\n}\n```\n\n```java\npublic class MemberServiceImpl  implements MemberService  {\n    public String addMember(String userName) {\n        System.out.println(\"执行方法-------\");\n        return userName;\n    }\n}\n```\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        // 保存class 文件到-->\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"D:\\\\code\");\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(MemberServiceImpl.class);\n        enhancer.setCallback(new CglibMethodInterceptor());\n        // 创建代理代理对象\n        MemberService memberService = (MemberService) enhancer.create();\n        String res = memberService.addMember(\"123456789\");\n        System.out.println(\"----> cglib动态代理返回数据为：\" + res);\n    }\n}\n```\n\n\n\n### JDK动态代理和CGLib动态代理的区别\n\n##### JDK代理：\n\n利用拦截器（必须实现InvocationHandler接口）加上**反射机制**生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理\n\n##### CGLib代理：\n\n利用ASM框架，对代理对象类生成的class文件加载进来，通过**修改其字节码生成子类来进行代理**\n\n\n\n- **如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;**\n- **如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；**\n\n\n\n","slug":"代理模式","published":1,"updated":"2023-08-10T09:34:22.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pw9y001pfswodd7ncppg","content":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>​\t代理模式是常见的设计模式之一，顾名思义，代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执行的前后，对操作进行增强处理。（为真实对象提供代理，然后供其他对象通过代理访问真实对象）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">角色</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">抽象角色</td>\n<td align=\"left\">声明真实对象和代理对象的共同接口</td>\n</tr>\n<tr>\n<td align=\"center\">代理角色</td>\n<td align=\"left\">代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能够代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</td>\n</tr>\n<tr>\n<td align=\"center\">真实角色</td>\n<td align=\"left\">代理角色所代表的真实对象，是我们最终要引用的对象</td>\n</tr>\n</tbody></table>\n<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>\n<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>\n<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>\n<p><strong>应用场景</strong><br> 静态代理主要用来处理少部分类的托管或者扩展。静态代理对于被代理的对象很固定，我们只需要去代理一个类或者若干固定的类，数量不是太多的时候，可以使用，而且其实效果比动态代理更好。<br> 动态代理在运行期间动态生成代理类，需要消耗的时间会更久一点。优点是可以做很多类的扩展（譬如可以通过动态代理实现aop，hibernate使用cglib来代理单端多对一和一对一关联等）。而且如果一个类的接口发生了变化，那么静态代理这时候修改起来就很麻烦了。这就是说动态代理灵活的原因。</p>\n<p>动态代理主流的实现有两种，一种是基于接口的Java Proxy的代理机制，一种是基于继承的cglib代理机制。两种也都有其应用场景。（视乎具体业务逻辑而言）</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h4 id=\"一、基于类实现静态代理\"><a href=\"#一、基于类实现静态代理\" class=\"headerlink\" title=\"一、基于类实现静态代理\"></a>一、基于类实现静态代理</h4><p>1、首先编写核心业务(被代理类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//核心业务</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service-----insert&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、编写代理类(代理类需要继承被代理类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;开始事务&quot;</span>)；</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.insert();<span class=\"comment\">//核心业务；</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;提交事务&quot;</span>)；</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;回滚事务&quot;</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ProxyService</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyService</span>();</span><br><span class=\"line\">        ps.insert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"二、基于接口实现静态代理\"><a href=\"#二、基于接口实现静态代理\" class=\"headerlink\" title=\"二、基于接口实现静态代理\"></a>二、基于接口实现静态代理</h4><p>1、首先编写一个接口(与它相关的核心业务类都要实现本接口)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、编写一个核心业务类并实现接口(接口的实现类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//核心业务</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service--------insert&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、编写一个代理类</p>\n<blockquote>\n<ol>\n<li>私有一个接口对象IService，这个是我们后面要被代理的对象；</li>\n<li>写一个一参构造方法，当外面要创建本ProxyTranService 代理对象时，需要传递一个实现了IService接口的核心业务类才能创建代理对象；</li>\n<li>本ProxyTranService 代理对象也要实现IService接口；</li>\n<li>本类重写的核心方法由外部传进来的被代理对象提供，其他业务由本代理提供。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTranService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IService service;<span class=\"comment\">//被代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyTranService</span><span class=\"params\">(IService service)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;开始事务&quot;</span>)；</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.insert();<span class=\"comment\">//核心业务；</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;提交事务&quot;</span>)；</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;回滚事务&quot;</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();</span><br><span class=\"line\">        <span class=\"type\">ProxyTranService</span> <span class=\"variable\">pts</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyTranService</span>(service);</span><br><span class=\"line\">        pts.insert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要哦我们必须实现接口，我们可以直接代理实现类(CGLib动态代理机制)</p>\n<h4 id=\"JDK动态理机制\"><a href=\"#JDK动态理机制\" class=\"headerlink\" title=\"JDK动态理机制\"></a>JDK动态理机制</h4><p>在java动态代理机制中InvocationHandler接口和Proxy类是核心</p>\n<p>Proxy类中使用频率最高的方法是：<code>newProxyInstance()</code>,这个方法主要用来生成一个代理对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    Classloader loader，</span></span><br><span class=\"line\"><span class=\"params\">    Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"params\">    InvocationHandler h)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法一共有三个参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>loader</td>\n<td>类加载器，用于加载代理对象</td>\n</tr>\n<tr>\n<td>interfaces</td>\n<td>被代理类实现的一些接口</td>\n</tr>\n<tr>\n<td>InvocationHandler</td>\n<td>实现了InvocationHandler接口的对象</td>\n</tr>\n</tbody></table>\n<p>要实现动态代理，还必须需要实现InvocationHandler来自定义处理逻辑。当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">InvocationHandler</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy,Method method,Object[] args)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>invoke()方法有三个参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>proxy</td>\n<td>指代我们所代理的那个真实对象</td>\n</tr>\n<tr>\n<td>method</td>\n<td>指代的是我们所要调用真实对象的某个方法的Method对象</td>\n</tr>\n<tr>\n<td>args</td>\n<td>指代的是调用真实对象某个方法时接受的参数</td>\n</tr>\n</tbody></table>\n<p>1、首先创建目标代理对目标方法的一个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ISmsService</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//目标代理对目标方法的一个接口</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> msg 消息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、实现 InvocationHandler 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现 InvocationHandler 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsInvocationHandler</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ISmsService</span>&gt; <span class=\"keyword\">implements</span></span><br><span class=\"line\">    <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> T target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SmsInvocationHandler</span><span class=\"params\">(T target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">        Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//增强被代理类</span></span><br><span class=\"line\">        <span class=\"comment\">//输出一个方法名</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;被代理方法执行前运行-----前置通知%n&quot;</span>,method.getName());</span><br><span class=\"line\">        <span class=\"comment\">//被代理类的调用，用到反射</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;被代理方法执行后运行-----后置通知%n&quot;</span>,method.getName());</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、创建代理类工厂、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理类工厂</span></span><br><span class=\"line\"><span class=\"comment\">//获取代理类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ISmsService <span class=\"title function_\">getProxy</span><span class=\"params\">(ISmsService target)</span>&#123;</span><br><span class=\"line\">        Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">ISmsService</span>&gt; clazz = target.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (ISmsService) Proxy.newProxyInstance(</span><br><span class=\"line\">            clazz.getClassLoader(),</span><br><span class=\"line\">            clazz.getInterfaces(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">SmsInvocationHandler</span>(target)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、创建测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ISmsService</span> <span class=\"variable\">smsService</span> <span class=\"operator\">=</span> msg -&gt; System.out.println(<span class=\"string\">&quot;被代理目标方法执行&quot;</span> +</span><br><span class=\"line\">                                                       msg);</span><br><span class=\"line\">    <span class=\"type\">ISmsService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> SmsProxyFactory.getProxy(smsService);</span><br><span class=\"line\">    proxy.send(<span class=\"string\">&quot;你好，世界&quot;</span>);</span><br><span class=\"line\">    smsService.send(<span class=\"string\">&quot;-----目标方法---&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"cglib动态代理\"><a href=\"#cglib动态代理\" class=\"headerlink\" title=\"cglib动态代理\"></a>cglib动态代理</h2><p>Cglib依赖于ASM字节码技术，直接生成class文件，在采用类加载器读取到程序中<br>使用 fastclass 对被代理类的方法建立索引, 文件不需要依赖于反射查找到目标方法<br>所以效率比Jdk动态代理要高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  cglib动态代理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj 执行对象class(被代理类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 执行对象class的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 执行对象class的方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt; cglib动态代理执行开始&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proxy.invokeSuper(obj, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt; cglib动态代理执行结束&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MemberService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">addMember</span><span class=\"params\">(String userName)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemberServiceImpl</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MemberService</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">addMember</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行方法-------&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 保存class 文件到--&gt;</span></span><br><span class=\"line\">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class=\"string\">&quot;D:\\\\code&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        enhancer.setSuperclass(MemberServiceImpl.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">CglibMethodInterceptor</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理代理对象</span></span><br><span class=\"line\">        <span class=\"type\">MemberService</span> <span class=\"variable\">memberService</span> <span class=\"operator\">=</span> (MemberService) enhancer.create();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> memberService.addMember(<span class=\"string\">&quot;123456789&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;----&gt; cglib动态代理返回数据为：&quot;</span> + res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"JDK动态代理和CGLib动态代理的区别\"><a href=\"#JDK动态代理和CGLib动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLib动态代理的区别\"></a>JDK动态代理和CGLib动态代理的区别</h3><h5 id=\"JDK代理：\"><a href=\"#JDK代理：\" class=\"headerlink\" title=\"JDK代理：\"></a>JDK代理：</h5><p>利用拦截器（必须实现InvocationHandler接口）加上<strong>反射机制</strong>生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p>\n<h5 id=\"CGLib代理：\"><a href=\"#CGLib代理：\" class=\"headerlink\" title=\"CGLib代理：\"></a>CGLib代理：</h5><p>利用ASM框架，对代理对象类生成的class文件加载进来，通过<strong>修改其字节码生成子类来进行代理</strong></p>\n<ul>\n<li><strong>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</strong></li>\n<li><strong>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</strong></li>\n</ul>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>​\t代理模式是常见的设计模式之一，顾名思义，代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执行的前后，对操作进行增强处理。（为真实对象提供代理，然后供其他对象通过代理访问真实对象）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">角色</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">抽象角色</td>\n<td align=\"left\">声明真实对象和代理对象的共同接口</td>\n</tr>\n<tr>\n<td align=\"center\">代理角色</td>\n<td align=\"left\">代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能够代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</td>\n</tr>\n<tr>\n<td align=\"center\">真实角色</td>\n<td align=\"left\">代理角色所代表的真实对象，是我们最终要引用的对象</td>\n</tr>\n</tbody></table>\n<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>\n<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>\n<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>\n<p><strong>应用场景</strong><br> 静态代理主要用来处理少部分类的托管或者扩展。静态代理对于被代理的对象很固定，我们只需要去代理一个类或者若干固定的类，数量不是太多的时候，可以使用，而且其实效果比动态代理更好。<br> 动态代理在运行期间动态生成代理类，需要消耗的时间会更久一点。优点是可以做很多类的扩展（譬如可以通过动态代理实现aop，hibernate使用cglib来代理单端多对一和一对一关联等）。而且如果一个类的接口发生了变化，那么静态代理这时候修改起来就很麻烦了。这就是说动态代理灵活的原因。</p>\n<p>动态代理主流的实现有两种，一种是基于接口的Java Proxy的代理机制，一种是基于继承的cglib代理机制。两种也都有其应用场景。（视乎具体业务逻辑而言）</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h4 id=\"一、基于类实现静态代理\"><a href=\"#一、基于类实现静态代理\" class=\"headerlink\" title=\"一、基于类实现静态代理\"></a>一、基于类实现静态代理</h4><p>1、首先编写核心业务(被代理类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//核心业务</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service-----insert&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、编写代理类(代理类需要继承被代理类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;开始事务&quot;</span>)；</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.insert();<span class=\"comment\">//核心业务；</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;提交事务&quot;</span>)；</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;回滚事务&quot;</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">ProxyService</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyService</span>();</span><br><span class=\"line\">        ps.insert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"二、基于接口实现静态代理\"><a href=\"#二、基于接口实现静态代理\" class=\"headerlink\" title=\"二、基于接口实现静态代理\"></a>二、基于接口实现静态代理</h4><p>1、首先编写一个接口(与它相关的核心业务类都要实现本接口)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、编写一个核心业务类并实现接口(接口的实现类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//核心业务</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service--------insert&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、编写一个代理类</p>\n<blockquote>\n<ol>\n<li>私有一个接口对象IService，这个是我们后面要被代理的对象；</li>\n<li>写一个一参构造方法，当外面要创建本ProxyTranService 代理对象时，需要传递一个实现了IService接口的核心业务类才能创建代理对象；</li>\n<li>本ProxyTranService 代理对象也要实现IService接口；</li>\n<li>本类重写的核心方法由外部传进来的被代理对象提供，其他业务由本代理提供。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTranService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> IService service;<span class=\"comment\">//被代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyTranService</span><span class=\"params\">(IService service)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;开始事务&quot;</span>)；</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.insert();<span class=\"comment\">//核心业务；</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;提交事务&quot;</span>)；</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;回滚事务&quot;</span>)；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();</span><br><span class=\"line\">        <span class=\"type\">ProxyTranService</span> <span class=\"variable\">pts</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyTranService</span>(service);</span><br><span class=\"line\">        pts.insert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要哦我们必须实现接口，我们可以直接代理实现类(CGLib动态代理机制)</p>\n<h4 id=\"JDK动态理机制\"><a href=\"#JDK动态理机制\" class=\"headerlink\" title=\"JDK动态理机制\"></a>JDK动态理机制</h4><p>在java动态代理机制中InvocationHandler接口和Proxy类是核心</p>\n<p>Proxy类中使用频率最高的方法是：<code>newProxyInstance()</code>,这个方法主要用来生成一个代理对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    Classloader loader，</span></span><br><span class=\"line\"><span class=\"params\">    Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"params\">    InvocationHandler h)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法一共有三个参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>loader</td>\n<td>类加载器，用于加载代理对象</td>\n</tr>\n<tr>\n<td>interfaces</td>\n<td>被代理类实现的一些接口</td>\n</tr>\n<tr>\n<td>InvocationHandler</td>\n<td>实现了InvocationHandler接口的对象</td>\n</tr>\n</tbody></table>\n<p>要实现动态代理，还必须需要实现InvocationHandler来自定义处理逻辑。当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">InvocationHandler</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy,Method method,Object[] args)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>invoke()方法有三个参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>proxy</td>\n<td>指代我们所代理的那个真实对象</td>\n</tr>\n<tr>\n<td>method</td>\n<td>指代的是我们所要调用真实对象的某个方法的Method对象</td>\n</tr>\n<tr>\n<td>args</td>\n<td>指代的是调用真实对象某个方法时接受的参数</td>\n</tr>\n</tbody></table>\n<p>1、首先创建目标代理对目标方法的一个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ISmsService</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//目标代理对目标方法的一个接口</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> msg 消息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">(String msg)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、实现 InvocationHandler 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现 InvocationHandler 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsInvocationHandler</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ISmsService</span>&gt; <span class=\"keyword\">implements</span></span><br><span class=\"line\">    <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> T target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SmsInvocationHandler</span><span class=\"params\">(T target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">        Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//增强被代理类</span></span><br><span class=\"line\">        <span class=\"comment\">//输出一个方法名</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;被代理方法执行前运行-----前置通知%n&quot;</span>,method.getName());</span><br><span class=\"line\">        <span class=\"comment\">//被代理类的调用，用到反射</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;被代理方法执行后运行-----后置通知%n&quot;</span>,method.getName());</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、创建代理类工厂、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理类工厂</span></span><br><span class=\"line\"><span class=\"comment\">//获取代理类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ISmsService <span class=\"title function_\">getProxy</span><span class=\"params\">(ISmsService target)</span>&#123;</span><br><span class=\"line\">        Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">ISmsService</span>&gt; clazz = target.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (ISmsService) Proxy.newProxyInstance(</span><br><span class=\"line\">            clazz.getClassLoader(),</span><br><span class=\"line\">            clazz.getInterfaces(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">SmsInvocationHandler</span>(target)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、创建测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ISmsService</span> <span class=\"variable\">smsService</span> <span class=\"operator\">=</span> msg -&gt; System.out.println(<span class=\"string\">&quot;被代理目标方法执行&quot;</span> +</span><br><span class=\"line\">                                                       msg);</span><br><span class=\"line\">    <span class=\"type\">ISmsService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> SmsProxyFactory.getProxy(smsService);</span><br><span class=\"line\">    proxy.send(<span class=\"string\">&quot;你好，世界&quot;</span>);</span><br><span class=\"line\">    smsService.send(<span class=\"string\">&quot;-----目标方法---&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"cglib动态代理\"><a href=\"#cglib动态代理\" class=\"headerlink\" title=\"cglib动态代理\"></a>cglib动态代理</h2><p>Cglib依赖于ASM字节码技术，直接生成class文件，在采用类加载器读取到程序中<br>使用 fastclass 对被代理类的方法建立索引, 文件不需要依赖于反射查找到目标方法<br>所以效率比Jdk动态代理要高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  cglib动态代理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj 执行对象class(被代理类)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method 执行对象class的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args 执行对象class的方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> proxy 代理类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt; cglib动态代理执行开始&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proxy.invokeSuper(obj, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt; cglib动态代理执行结束&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MemberService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">addMember</span><span class=\"params\">(String userName)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemberServiceImpl</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MemberService</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">addMember</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行方法-------&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 保存class 文件到--&gt;</span></span><br><span class=\"line\">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class=\"string\">&quot;D:\\\\code&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        enhancer.setSuperclass(MemberServiceImpl.class);</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">CglibMethodInterceptor</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理代理对象</span></span><br><span class=\"line\">        <span class=\"type\">MemberService</span> <span class=\"variable\">memberService</span> <span class=\"operator\">=</span> (MemberService) enhancer.create();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> memberService.addMember(<span class=\"string\">&quot;123456789&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;----&gt; cglib动态代理返回数据为：&quot;</span> + res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"JDK动态代理和CGLib动态代理的区别\"><a href=\"#JDK动态代理和CGLib动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLib动态代理的区别\"></a>JDK动态代理和CGLib动态代理的区别</h3><h5 id=\"JDK代理：\"><a href=\"#JDK代理：\" class=\"headerlink\" title=\"JDK代理：\"></a>JDK代理：</h5><p>利用拦截器（必须实现InvocationHandler接口）加上<strong>反射机制</strong>生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p>\n<h5 id=\"CGLib代理：\"><a href=\"#CGLib代理：\" class=\"headerlink\" title=\"CGLib代理：\"></a>CGLib代理：</h5><p>利用ASM框架，对代理对象类生成的class文件加载进来，通过<strong>修改其字节码生成子类来进行代理</strong></p>\n<ul>\n<li><strong>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</strong></li>\n<li><strong>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</strong></li>\n</ul>\n"},{"title":"HTML","date":"2022-08-22T03:18:57.000Z","cover":"/img/images/Internet2.jpg","_content":"\n### HTML\n\n#### 一、什么是HTML\n\n​\tHyperText Markup Language\n\n​\t超文本标记语言\n\n​\t超文本：超出纯文本的范畴，不仅仅是纯文本，可以让文本显示不同的大小，颜色，甚至可以显示图片，表格，音频，视频等元素\n\n​\t标记：HTML语言的语法特征\n\n​\t单标记：</>\n\n​\t双标记：<></>\n\n#### 二、HTML语言作用\n\n​\t设计网站的前台界面\n\n​\t也可以用于写手机App界面\n\n​\t前端三大基础语言之一：HTML-CSS-JavaScript\n\n> HTML:定义网页的基本骨架(网页有什么)\n>\n> CSS:对网页的样式进行渲染(网页长什么样子，给网页化妆)\n>\n> JavaScript:对网页进行动态效果设置(网页各个地方点了能干啥)","source":"_posts/前端.md","raw":"---\ntitle: HTML\ndate: 2022-08-22 11:18:57\ntags: 前端\ncategories: 前端\ncover: /img/images/Internet2.jpg\n---\n\n### HTML\n\n#### 一、什么是HTML\n\n​\tHyperText Markup Language\n\n​\t超文本标记语言\n\n​\t超文本：超出纯文本的范畴，不仅仅是纯文本，可以让文本显示不同的大小，颜色，甚至可以显示图片，表格，音频，视频等元素\n\n​\t标记：HTML语言的语法特征\n\n​\t单标记：</>\n\n​\t双标记：<></>\n\n#### 二、HTML语言作用\n\n​\t设计网站的前台界面\n\n​\t也可以用于写手机App界面\n\n​\t前端三大基础语言之一：HTML-CSS-JavaScript\n\n> HTML:定义网页的基本骨架(网页有什么)\n>\n> CSS:对网页的样式进行渲染(网页长什么样子，给网页化妆)\n>\n> JavaScript:对网页进行动态效果设置(网页各个地方点了能干啥)","slug":"前端","published":1,"updated":"2023-08-10T09:49:25.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwa3001ufswo77gl18qt","content":"<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><h4 id=\"一、什么是HTML\"><a href=\"#一、什么是HTML\" class=\"headerlink\" title=\"一、什么是HTML\"></a>一、什么是HTML</h4><p>​\tHyperText Markup Language</p>\n<p>​\t超文本标记语言</p>\n<p>​\t超文本：超出纯文本的范畴，不仅仅是纯文本，可以让文本显示不同的大小，颜色，甚至可以显示图片，表格，音频，视频等元素</p>\n<p>​\t标记：HTML语言的语法特征</p>\n<p>​\t单标记：&lt;&#x2F;&gt;</p>\n<p>​\t双标记：&lt;&gt;&lt;&#x2F;&gt;</p>\n<h4 id=\"二、HTML语言作用\"><a href=\"#二、HTML语言作用\" class=\"headerlink\" title=\"二、HTML语言作用\"></a>二、HTML语言作用</h4><p>​\t设计网站的前台界面</p>\n<p>​\t也可以用于写手机App界面</p>\n<p>​\t前端三大基础语言之一：HTML-CSS-JavaScript</p>\n<blockquote>\n<p>HTML:定义网页的基本骨架(网页有什么)</p>\n<p>CSS:对网页的样式进行渲染(网页长什么样子，给网页化妆)</p>\n<p>JavaScript:对网页进行动态效果设置(网页各个地方点了能干啥)</p>\n</blockquote>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><h4 id=\"一、什么是HTML\"><a href=\"#一、什么是HTML\" class=\"headerlink\" title=\"一、什么是HTML\"></a>一、什么是HTML</h4><p>​\tHyperText Markup Language</p>\n<p>​\t超文本标记语言</p>\n<p>​\t超文本：超出纯文本的范畴，不仅仅是纯文本，可以让文本显示不同的大小，颜色，甚至可以显示图片，表格，音频，视频等元素</p>\n<p>​\t标记：HTML语言的语法特征</p>\n<p>​\t单标记：&lt;&#x2F;&gt;</p>\n<p>​\t双标记：&lt;&gt;&lt;&#x2F;&gt;</p>\n<h4 id=\"二、HTML语言作用\"><a href=\"#二、HTML语言作用\" class=\"headerlink\" title=\"二、HTML语言作用\"></a>二、HTML语言作用</h4><p>​\t设计网站的前台界面</p>\n<p>​\t也可以用于写手机App界面</p>\n<p>​\t前端三大基础语言之一：HTML-CSS-JavaScript</p>\n<blockquote>\n<p>HTML:定义网页的基本骨架(网页有什么)</p>\n<p>CSS:对网页的样式进行渲染(网页长什么样子，给网页化妆)</p>\n<p>JavaScript:对网页进行动态效果设置(网页各个地方点了能干啥)</p>\n</blockquote>\n"},{"title":"数据结构与算法","date":"2023-03-12T03:18:57.000Z","cover":"/img/images/network.jpg","_content":"\n一、软件（程序）的概念\n\n​\t数据结构+算法\n\n数据结构：\n\n1. 什么是数据结构：一堆用于存储并组织数据的容器\n2. 数据结构的种类：\n   1. 数组：连续不间断\n   2. 栈：先进后出\n   3. 队列：先进先出（单向队列）默认双向队列\n   4. 链表：一个拉着一个\n   5. 哈希表（散列表）：\n   6. 树\n      1. 二叉排序树(二分搜索树，二叉查找树)\n      2. 特点：每个父节点最多有两个子节点，左子节点数据不为空一定小于他的父节点，右子节点数据不为空，一定大于他的父节点，层数I从1开始，第I层最多有2^(i-1)个结点，最大查找次数等于二叉树的层数，查找效率高，时间复杂度为ln，节点内容不能为null值，且不能相同（equals），且必须能狗比较大小（Comparable，Comparator）\n      3. 遍历方式：前序遍历(父->左->右)，中序遍历(左->父->右),后序遍历(左->右->父)\n   7. 堆\n   8. 图\n\n\n\n二、算法\n\n1. 什么是算法\n   1. 对数据结构所存储数据的各种操作\n2. 算法的分类\n   1. 排序算法（冒泡，插入，选择...）\n   2. 检索算法\n   3. 插入\n   4. 更新\n   5. 删除","source":"_posts/数据结构+算法.md","raw":"---\ntitle: 数据结构与算法\ndate: 2023-03-12 11:18:57\ntags: 数据结构\ncategories: 设计模式\ncover: /img/images/network.jpg\n---\n\n一、软件（程序）的概念\n\n​\t数据结构+算法\n\n数据结构：\n\n1. 什么是数据结构：一堆用于存储并组织数据的容器\n2. 数据结构的种类：\n   1. 数组：连续不间断\n   2. 栈：先进后出\n   3. 队列：先进先出（单向队列）默认双向队列\n   4. 链表：一个拉着一个\n   5. 哈希表（散列表）：\n   6. 树\n      1. 二叉排序树(二分搜索树，二叉查找树)\n      2. 特点：每个父节点最多有两个子节点，左子节点数据不为空一定小于他的父节点，右子节点数据不为空，一定大于他的父节点，层数I从1开始，第I层最多有2^(i-1)个结点，最大查找次数等于二叉树的层数，查找效率高，时间复杂度为ln，节点内容不能为null值，且不能相同（equals），且必须能狗比较大小（Comparable，Comparator）\n      3. 遍历方式：前序遍历(父->左->右)，中序遍历(左->父->右),后序遍历(左->右->父)\n   7. 堆\n   8. 图\n\n\n\n二、算法\n\n1. 什么是算法\n   1. 对数据结构所存储数据的各种操作\n2. 算法的分类\n   1. 排序算法（冒泡，插入，选择...）\n   2. 检索算法\n   3. 插入\n   4. 更新\n   5. 删除","slug":"数据结构+算法","published":1,"updated":"2023-08-10T09:22:46.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwa4001wfswobqx61unm","content":"<p>一、软件（程序）的概念</p>\n<p>​\t数据结构+算法</p>\n<p>数据结构：</p>\n<ol>\n<li>什么是数据结构：一堆用于存储并组织数据的容器</li>\n<li>数据结构的种类：<ol>\n<li>数组：连续不间断</li>\n<li>栈：先进后出</li>\n<li>队列：先进先出（单向队列）默认双向队列</li>\n<li>链表：一个拉着一个</li>\n<li>哈希表（散列表）：</li>\n<li>树<ol>\n<li>二叉排序树(二分搜索树，二叉查找树)</li>\n<li>特点：每个父节点最多有两个子节点，左子节点数据不为空一定小于他的父节点，右子节点数据不为空，一定大于他的父节点，层数I从1开始，第I层最多有2^(i-1)个结点，最大查找次数等于二叉树的层数，查找效率高，时间复杂度为ln，节点内容不能为null值，且不能相同（equals），且必须能狗比较大小（Comparable，Comparator）</li>\n<li>遍历方式：前序遍历(父-&gt;左-&gt;右)，中序遍历(左-&gt;父-&gt;右),后序遍历(左-&gt;右-&gt;父)</li>\n</ol>\n</li>\n<li>堆</li>\n<li>图</li>\n</ol>\n</li>\n</ol>\n<p>二、算法</p>\n<ol>\n<li>什么是算法<ol>\n<li>对数据结构所存储数据的各种操作</li>\n</ol>\n</li>\n<li>算法的分类<ol>\n<li>排序算法（冒泡，插入，选择…）</li>\n<li>检索算法</li>\n<li>插入</li>\n<li>更新</li>\n<li>删除</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<p>一、软件（程序）的概念</p>\n<p>​\t数据结构+算法</p>\n<p>数据结构：</p>\n<ol>\n<li>什么是数据结构：一堆用于存储并组织数据的容器</li>\n<li>数据结构的种类：<ol>\n<li>数组：连续不间断</li>\n<li>栈：先进后出</li>\n<li>队列：先进先出（单向队列）默认双向队列</li>\n<li>链表：一个拉着一个</li>\n<li>哈希表（散列表）：</li>\n<li>树<ol>\n<li>二叉排序树(二分搜索树，二叉查找树)</li>\n<li>特点：每个父节点最多有两个子节点，左子节点数据不为空一定小于他的父节点，右子节点数据不为空，一定大于他的父节点，层数I从1开始，第I层最多有2^(i-1)个结点，最大查找次数等于二叉树的层数，查找效率高，时间复杂度为ln，节点内容不能为null值，且不能相同（equals），且必须能狗比较大小（Comparable，Comparator）</li>\n<li>遍历方式：前序遍历(父-&gt;左-&gt;右)，中序遍历(左-&gt;父-&gt;右),后序遍历(左-&gt;右-&gt;父)</li>\n</ol>\n</li>\n<li>堆</li>\n<li>图</li>\n</ol>\n</li>\n</ol>\n<p>二、算法</p>\n<ol>\n<li>什么是算法<ol>\n<li>对数据结构所存储数据的各种操作</li>\n</ol>\n</li>\n<li>算法的分类<ol>\n<li>排序算法（冒泡，插入，选择…）</li>\n<li>检索算法</li>\n<li>插入</li>\n<li>更新</li>\n<li>删除</li>\n</ol>\n</li>\n</ol>\n"},{"title":"浏览器输入地址后的操作？","date":"2023-03-12T03:18:57.000Z","cover":"/img/images/Internet.jpg","_content":"\n# 面试题：浏览器输入了地址后都做了那些操作？\n\n> 作为普通用户，在浏览器地址栏中输入了一个目标网址，浏览器就会加载该网址对应的网站内容。\n>\n> 作为开发者，需要考虑浏览器输入了地址后，到浏览器页面加载显示网站内容都做了那些操作。\n\n#### 1.浏览器的处理流程\n\n1.对输入的地址进行域名解析(`DNS`解析)，得到对应的`IP`地址；\n\n2.建立基于`TCP/IP`协议的通信信道，TCP的三次握手；\n\n3.客户端(浏览器)发起基于`HTTP`协议的请求，来请求对应的网站资源(`html`文档、图片、音频、视频等内容)；\n\n4.服务的(后台)处理请求，并整理资源；\n\n5.客户端(浏览器)得到`HTTP`响应，并接受对应的数据；\n\n6.关闭通信信道，`TCP`的四次挥手；\n\n7.解析`HTML`文档，并渲染加载对应的数据；\n\n#### 2.DNS解析\n\n`DNS`的全称为`Domain Name System`,即域名系统。\n\n在当下的网络环境中，有数以亿计的主机(电脑和服务器)。为了标识每个网络环境中的主机，我们为其提供了`IP`地址作为其在该网络环境下的唯一标识。目前主流的`IP`地址依然是`IPv4`版本的地址编码方式。其地址范围为`0.0.0.0`~`255.255.255.255`。通常情况下通过`IP`地址可以快速准确的访问该网络环境中的主机。\n\n为了降低对`IP`地址这样的数字编号的记忆成本，我们为对应`IP`地址的主机设定其主机名，即通常所受的域名。域名的结构特点如下：www.xxxxx.comd\n\n- 域名前缀。`wwww:World Wild Web`\n- 主机名。可以通过域名注册服务商去申请，一般的注意事项就是简单、易懂、易记。\n- 域名后缀。用作域名的限定范围，有点像座机的区号。比如：`baidu.com`和`baidu.cn`就标识不同的域名。常用的域名后缀有`.com`、`.cn`、`.ne`t、`.org`、`.edu`、`.gov`.\n\n##### 2.1域名系统的作用\n\n主机之间的通信是通过访问`IP`地址来实现的，但是由于`IP`地址是一串数字编号，记忆成本很高。所以，为了方便起见公共可访问的主机设定域名来访问。此时需要域名系统对对应域名和其`IP`地址做映射记录。当访问某个域名时，会优先查询域名系统中对应的`IP`地址，最终通过`IP`地址来建立主机间的通信。\n\n##### 2.2域名解析过程\n\n1. 当我们输入一个王章的地址时（www.baidu.com），此时需要找到其对应的`IP`地址。会优先在浏览器缓存中查询是否存在该域名对应`IP`地址。如果有，则使用，如果没有则进入下一步查询；\n2. 查找本地缓存，我们当前电脑的`hosts`文件。如果有则使用，如果没有则进入下一步查询；\n3. 查找本地服务器，比如我们使用的是校园网，该服务器一般就在学校。如果有则使用，如果没有则进入下一步查询；\n4. 本地服务器会向根域名服务器发起请求信息，然后根域名服务器会返回一个`gTLD`(通用的顶级域)。接下来本地服务器会访问`gTLD`。`gTLD`会返回一个域名服务器的地址。也就是我们注册网络的服务器提供商的地址。最后该域名服务器会讲对应的`IP`地址推送给客户端。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/浏览器输入地址后操作.md","raw":"---\ntitle: 浏览器输入地址后的操作？\ndate: 2023-03-12 11:18:57\ntags: 网络\ncategories: 网络\ncover: /img/images/Internet.jpg \n---\n\n# 面试题：浏览器输入了地址后都做了那些操作？\n\n> 作为普通用户，在浏览器地址栏中输入了一个目标网址，浏览器就会加载该网址对应的网站内容。\n>\n> 作为开发者，需要考虑浏览器输入了地址后，到浏览器页面加载显示网站内容都做了那些操作。\n\n#### 1.浏览器的处理流程\n\n1.对输入的地址进行域名解析(`DNS`解析)，得到对应的`IP`地址；\n\n2.建立基于`TCP/IP`协议的通信信道，TCP的三次握手；\n\n3.客户端(浏览器)发起基于`HTTP`协议的请求，来请求对应的网站资源(`html`文档、图片、音频、视频等内容)；\n\n4.服务的(后台)处理请求，并整理资源；\n\n5.客户端(浏览器)得到`HTTP`响应，并接受对应的数据；\n\n6.关闭通信信道，`TCP`的四次挥手；\n\n7.解析`HTML`文档，并渲染加载对应的数据；\n\n#### 2.DNS解析\n\n`DNS`的全称为`Domain Name System`,即域名系统。\n\n在当下的网络环境中，有数以亿计的主机(电脑和服务器)。为了标识每个网络环境中的主机，我们为其提供了`IP`地址作为其在该网络环境下的唯一标识。目前主流的`IP`地址依然是`IPv4`版本的地址编码方式。其地址范围为`0.0.0.0`~`255.255.255.255`。通常情况下通过`IP`地址可以快速准确的访问该网络环境中的主机。\n\n为了降低对`IP`地址这样的数字编号的记忆成本，我们为对应`IP`地址的主机设定其主机名，即通常所受的域名。域名的结构特点如下：www.xxxxx.comd\n\n- 域名前缀。`wwww:World Wild Web`\n- 主机名。可以通过域名注册服务商去申请，一般的注意事项就是简单、易懂、易记。\n- 域名后缀。用作域名的限定范围，有点像座机的区号。比如：`baidu.com`和`baidu.cn`就标识不同的域名。常用的域名后缀有`.com`、`.cn`、`.ne`t、`.org`、`.edu`、`.gov`.\n\n##### 2.1域名系统的作用\n\n主机之间的通信是通过访问`IP`地址来实现的，但是由于`IP`地址是一串数字编号，记忆成本很高。所以，为了方便起见公共可访问的主机设定域名来访问。此时需要域名系统对对应域名和其`IP`地址做映射记录。当访问某个域名时，会优先查询域名系统中对应的`IP`地址，最终通过`IP`地址来建立主机间的通信。\n\n##### 2.2域名解析过程\n\n1. 当我们输入一个王章的地址时（www.baidu.com），此时需要找到其对应的`IP`地址。会优先在浏览器缓存中查询是否存在该域名对应`IP`地址。如果有，则使用，如果没有则进入下一步查询；\n2. 查找本地缓存，我们当前电脑的`hosts`文件。如果有则使用，如果没有则进入下一步查询；\n3. 查找本地服务器，比如我们使用的是校园网，该服务器一般就在学校。如果有则使用，如果没有则进入下一步查询；\n4. 本地服务器会向根域名服务器发起请求信息，然后根域名服务器会返回一个`gTLD`(通用的顶级域)。接下来本地服务器会访问`gTLD`。`gTLD`会返回一个域名服务器的地址。也就是我们注册网络的服务器提供商的地址。最后该域名服务器会讲对应的`IP`地址推送给客户端。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"浏览器输入地址后操作","published":1,"updated":"2023-08-10T09:24:03.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwah002vfswoa2l4covh","content":"<h1 id=\"面试题：浏览器输入了地址后都做了那些操作？\"><a href=\"#面试题：浏览器输入了地址后都做了那些操作？\" class=\"headerlink\" title=\"面试题：浏览器输入了地址后都做了那些操作？\"></a>面试题：浏览器输入了地址后都做了那些操作？</h1><blockquote>\n<p>作为普通用户，在浏览器地址栏中输入了一个目标网址，浏览器就会加载该网址对应的网站内容。</p>\n<p>作为开发者，需要考虑浏览器输入了地址后，到浏览器页面加载显示网站内容都做了那些操作。</p>\n</blockquote>\n<h4 id=\"1-浏览器的处理流程\"><a href=\"#1-浏览器的处理流程\" class=\"headerlink\" title=\"1.浏览器的处理流程\"></a>1.浏览器的处理流程</h4><p>1.对输入的地址进行域名解析(<code>DNS</code>解析)，得到对应的<code>IP</code>地址；</p>\n<p>2.建立基于<code>TCP/IP</code>协议的通信信道，TCP的三次握手；</p>\n<p>3.客户端(浏览器)发起基于<code>HTTP</code>协议的请求，来请求对应的网站资源(<code>html</code>文档、图片、音频、视频等内容)；</p>\n<p>4.服务的(后台)处理请求，并整理资源；</p>\n<p>5.客户端(浏览器)得到<code>HTTP</code>响应，并接受对应的数据；</p>\n<p>6.关闭通信信道，<code>TCP</code>的四次挥手；</p>\n<p>7.解析<code>HTML</code>文档，并渲染加载对应的数据；</p>\n<h4 id=\"2-DNS解析\"><a href=\"#2-DNS解析\" class=\"headerlink\" title=\"2.DNS解析\"></a>2.DNS解析</h4><p><code>DNS</code>的全称为<code>Domain Name System</code>,即域名系统。</p>\n<p>在当下的网络环境中，有数以亿计的主机(电脑和服务器)。为了标识每个网络环境中的主机，我们为其提供了<code>IP</code>地址作为其在该网络环境下的唯一标识。目前主流的<code>IP</code>地址依然是<code>IPv4</code>版本的地址编码方式。其地址范围为<code>0.0.0.0</code>~&#96;255.255.255.255<code>。通常情况下通过</code>IP&#96;地址可以快速准确的访问该网络环境中的主机。</p>\n<p>为了降低对<code>IP</code>地址这样的数字编号的记忆成本，我们为对应<code>IP</code>地址的主机设定其主机名，即通常所受的域名。域名的结构特点如下：<a href=\"http://www.xxxxx.comd/\">www.xxxxx.comd</a></p>\n<ul>\n<li>域名前缀。<code>wwww:World Wild Web</code></li>\n<li>主机名。可以通过域名注册服务商去申请，一般的注意事项就是简单、易懂、易记。</li>\n<li>域名后缀。用作域名的限定范围，有点像座机的区号。比如：<code>baidu.com</code>和<code>baidu.cn</code>就标识不同的域名。常用的域名后缀有<code>.com</code>、<code>.cn</code>、<code>.ne</code>t、<code>.org</code>、<code>.edu</code>、<code>.gov</code>.</li>\n</ul>\n<h5 id=\"2-1域名系统的作用\"><a href=\"#2-1域名系统的作用\" class=\"headerlink\" title=\"2.1域名系统的作用\"></a>2.1域名系统的作用</h5><p>主机之间的通信是通过访问<code>IP</code>地址来实现的，但是由于<code>IP</code>地址是一串数字编号，记忆成本很高。所以，为了方便起见公共可访问的主机设定域名来访问。此时需要域名系统对对应域名和其<code>IP</code>地址做映射记录。当访问某个域名时，会优先查询域名系统中对应的<code>IP</code>地址，最终通过<code>IP</code>地址来建立主机间的通信。</p>\n<h5 id=\"2-2域名解析过程\"><a href=\"#2-2域名解析过程\" class=\"headerlink\" title=\"2.2域名解析过程\"></a>2.2域名解析过程</h5><ol>\n<li>当我们输入一个王章的地址时（<a href=\"http://www.baidu.com),此时需要找到其对应的`ip`地址.会优先在浏览器缓存中查询是否存在该域名对应`ip`地址.如果有,则使用,如果没有则进入下一步查询;/\">www.baidu.com），此时需要找到其对应的`IP`地址。会优先在浏览器缓存中查询是否存在该域名对应`IP`地址。如果有，则使用，如果没有则进入下一步查询；</a></li>\n<li>查找本地缓存，我们当前电脑的<code>hosts</code>文件。如果有则使用，如果没有则进入下一步查询；</li>\n<li>查找本地服务器，比如我们使用的是校园网，该服务器一般就在学校。如果有则使用，如果没有则进入下一步查询；</li>\n<li>本地服务器会向根域名服务器发起请求信息，然后根域名服务器会返回一个<code>gTLD</code>(通用的顶级域)。接下来本地服务器会访问<code>gTLD</code>。<code>gTLD</code>会返回一个域名服务器的地址。也就是我们注册网络的服务器提供商的地址。最后该域名服务器会讲对应的<code>IP</code>地址推送给客户端。</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"面试题：浏览器输入了地址后都做了那些操作？\"><a href=\"#面试题：浏览器输入了地址后都做了那些操作？\" class=\"headerlink\" title=\"面试题：浏览器输入了地址后都做了那些操作？\"></a>面试题：浏览器输入了地址后都做了那些操作？</h1><blockquote>\n<p>作为普通用户，在浏览器地址栏中输入了一个目标网址，浏览器就会加载该网址对应的网站内容。</p>\n<p>作为开发者，需要考虑浏览器输入了地址后，到浏览器页面加载显示网站内容都做了那些操作。</p>\n</blockquote>\n<h4 id=\"1-浏览器的处理流程\"><a href=\"#1-浏览器的处理流程\" class=\"headerlink\" title=\"1.浏览器的处理流程\"></a>1.浏览器的处理流程</h4><p>1.对输入的地址进行域名解析(<code>DNS</code>解析)，得到对应的<code>IP</code>地址；</p>\n<p>2.建立基于<code>TCP/IP</code>协议的通信信道，TCP的三次握手；</p>\n<p>3.客户端(浏览器)发起基于<code>HTTP</code>协议的请求，来请求对应的网站资源(<code>html</code>文档、图片、音频、视频等内容)；</p>\n<p>4.服务的(后台)处理请求，并整理资源；</p>\n<p>5.客户端(浏览器)得到<code>HTTP</code>响应，并接受对应的数据；</p>\n<p>6.关闭通信信道，<code>TCP</code>的四次挥手；</p>\n<p>7.解析<code>HTML</code>文档，并渲染加载对应的数据；</p>\n<h4 id=\"2-DNS解析\"><a href=\"#2-DNS解析\" class=\"headerlink\" title=\"2.DNS解析\"></a>2.DNS解析</h4><p><code>DNS</code>的全称为<code>Domain Name System</code>,即域名系统。</p>\n<p>在当下的网络环境中，有数以亿计的主机(电脑和服务器)。为了标识每个网络环境中的主机，我们为其提供了<code>IP</code>地址作为其在该网络环境下的唯一标识。目前主流的<code>IP</code>地址依然是<code>IPv4</code>版本的地址编码方式。其地址范围为<code>0.0.0.0</code>~&#96;255.255.255.255<code>。通常情况下通过</code>IP&#96;地址可以快速准确的访问该网络环境中的主机。</p>\n<p>为了降低对<code>IP</code>地址这样的数字编号的记忆成本，我们为对应<code>IP</code>地址的主机设定其主机名，即通常所受的域名。域名的结构特点如下：<a href=\"http://www.xxxxx.comd/\">www.xxxxx.comd</a></p>\n<ul>\n<li>域名前缀。<code>wwww:World Wild Web</code></li>\n<li>主机名。可以通过域名注册服务商去申请，一般的注意事项就是简单、易懂、易记。</li>\n<li>域名后缀。用作域名的限定范围，有点像座机的区号。比如：<code>baidu.com</code>和<code>baidu.cn</code>就标识不同的域名。常用的域名后缀有<code>.com</code>、<code>.cn</code>、<code>.ne</code>t、<code>.org</code>、<code>.edu</code>、<code>.gov</code>.</li>\n</ul>\n<h5 id=\"2-1域名系统的作用\"><a href=\"#2-1域名系统的作用\" class=\"headerlink\" title=\"2.1域名系统的作用\"></a>2.1域名系统的作用</h5><p>主机之间的通信是通过访问<code>IP</code>地址来实现的，但是由于<code>IP</code>地址是一串数字编号，记忆成本很高。所以，为了方便起见公共可访问的主机设定域名来访问。此时需要域名系统对对应域名和其<code>IP</code>地址做映射记录。当访问某个域名时，会优先查询域名系统中对应的<code>IP</code>地址，最终通过<code>IP</code>地址来建立主机间的通信。</p>\n<h5 id=\"2-2域名解析过程\"><a href=\"#2-2域名解析过程\" class=\"headerlink\" title=\"2.2域名解析过程\"></a>2.2域名解析过程</h5><ol>\n<li>当我们输入一个王章的地址时（<a href=\"http://www.baidu.com),此时需要找到其对应的`ip`地址.会优先在浏览器缓存中查询是否存在该域名对应`ip`地址.如果有,则使用,如果没有则进入下一步查询;/\">www.baidu.com），此时需要找到其对应的`IP`地址。会优先在浏览器缓存中查询是否存在该域名对应`IP`地址。如果有，则使用，如果没有则进入下一步查询；</a></li>\n<li>查找本地缓存，我们当前电脑的<code>hosts</code>文件。如果有则使用，如果没有则进入下一步查询；</li>\n<li>查找本地服务器，比如我们使用的是校园网，该服务器一般就在学校。如果有则使用，如果没有则进入下一步查询；</li>\n<li>本地服务器会向根域名服务器发起请求信息，然后根域名服务器会返回一个<code>gTLD</code>(通用的顶级域)。接下来本地服务器会访问<code>gTLD</code>。<code>gTLD</code>会返回一个域名服务器的地址。也就是我们注册网络的服务器提供商的地址。最后该域名服务器会讲对应的<code>IP</code>地址推送给客户端。</li>\n</ol>\n"},{"title":"集合","date":"2023-01-10T03:18:57.000Z","cover":"/img/images/computer4.jpg","_content":"\n### 集合\n\n一、什么是集合\n\n​\t将一堆数据组织起来并存储带一个指定的数据结构容器中，Java中集合 其实就是一堆底层为数据结构容器的类或接口\n\n\n\n二、集合的分类\n\n​\tCollection(父接口)\n\n​\t主要用于存储单个元素\n\n1. list(子接口)：列表集合，该集合中存储的元素是允许重复，且能保证元素的添加顺序\n   1. ArrayList(实现类)底层实现为数组\n   2. LinkedList(实现类)底层实现为双向链表\n2. Set(子接口)：该集合中存储的元素是不允许重复的，且不能保证元素的添加顺序\n   1. HashSet(实现类)底层实现为HashMap\n   2. TreeSet(实现类)底层实现为TreeMap\n3. Queue(子接口)：默认为一个单向队列\n   1. Deque(子接口)：双向队列\n      1. LinkedList(实现类)通过双向链表数据结构实现了单向队列，双向队列和栈结构\n\n​\t\n\n​\tMap(父接口)\n\n​\t主要用于存储键值对形式的元素\n\n1. HashMap(实现类)底层实现为哈希表\n2. TreeMap(实现类)底层实现为二叉树(红黑树)\n\n\n\n三、集合工具类\n\n1. Arrays\n2. Collections\n3. Iterator\n4. Comparable\n5. Comparator\n6. Stream\n\n\n\n四、List接口\n\n​\t列表集合，Collection接口的子接口，存储在集合中的元素是可以重复的，并且能保证元素的添加顺序，其主要实现类为：Arraylist和LinkedList\n\n1. ArrayList\n\n   底层为一个Object[]数组\n   \n   ArrayList<E> list = new ArrayList<E>\n   \n   ArrayList<E> list = new ArrayList<E>(int initialCapacity)\n   \n   boolean add(E e)向集合末尾添加元素\n   \n   void add(E e)向集合中指定下标位置插入一个元素\n   \n   E get(int index)获取指定下标位置元素\n   \n   int size()获取集合长度\n   \n   E remove(int index)根据下标删除集合中元素，返回被删除的\n   \n   boolean remove(E e)根据内容删除集合中元素，返回是否删除成功\n   \n   int indexOf(E e)根据内容查找指定元素的下标\n   \n   E set(int index,E e)替换指定下标元素，返回被替换的元素\n   \n   boolean contains(E e)判断是否包含指定元素\n   \n   void clear()清空集合中的元素\n   \n   boolean isEmpty()判断集合是否为空\n   \n   Object[] toArray()将集合转为数组\n   \n   boolean addAll(Collection<? extends E> collect)向一个集合中添加另外一个集合中的元素\n   \n   boolean removeAll(Collection<? extends E> collect)向一个集合中移除另外一个集合中的元素\n   \n   > 快速失败机制：当集合中的元素正在迭代器中进行迭代时，不能通过集合对象元素进行添加或修改操作，会引发并发修改异常\n   \n   ArrayList扩容过程\n   \n   1. 当使用无参构造创建ArrayList对象时，会初始化一个长度为0的Object[]数组\n   2. 当第一次调用add()方法时，再将该Object[]数组长度扩容到10个\n   3. 当后续继续调用add()方法时，先判断长度是否够用，如果不够再将该Object[]数组长度扩容为之前的1.5倍\n   \n   Vector(了解)\n   \n   1. 和ArrayList相同，都是List接口的实现类，底层都是通过Object[]数组来存储元素\n   2. 当通过无参构造创建Vector对象时，默认初始化一个长度为10的Object[]数组,后续每次需要扩容，将扩容之前长度的2倍\n   3. Vector是一个线程安全的ArrayList\n   \n2. LinkedList\n\n   1. linkedList概念\n   \n   2. 底层实现了为一个双向链表，链表上的每一个结点由三部分组成\n      1. 前驱指针：保存上一个结点的内存地址\n      2. 结点内容：当前结点保存的值\n      3. 后驱指针：保存下一个结点的内存地址\n      \n   3. LinkedList作为双向链表使用\n   \n      实现了List接口，拥有和ArrayList相同的方法，但是其内部方法都是采用双向链表来进行实现\n      \n   4. LinkedList作为单向队列使用\n   \n      实现了Queue接口，因此可以作为一个单向队列来使用\n      \n      单向队列的方法：\n      \n      offer()\n      \n      队尾入队\n      \n      peek()\n      \n      获取但不移除队首元素\n      \n      poll()\n      \n      队首出队\n      \n   5. LinkedList作为双向队列使用\n      \n      实现了Deque接口，因此可以作为一个双向队列来使用\n      \n      队首入队，队尾出队\n      \n      队尾入队，队首出队\n      \n      双向队列的方法：\n      \n      offerFirst()队首入队\n      \n      offerLast()队尾入队\n      \n      peekFirst()获取但不移除队首元素\n      \n      peekLast()获取但不移除队尾元素\n      \n      pollFirst()队首出队\n      \n      pollLast()队尾出队\n      \n   6. LinkedList作为栈使用\n      \n      作为栈结构的方法：\n      \n      push()入栈，压栈\n      \n      pop()出栈，弹栈\n   \n 3. ArrayList和LinkedLisst有什么区别\n\n    1. 都是实现了List接口，因此都能保证元素的添加顺序以及可以添加重复元素\n    2. ArrayList底层实现为数组，因此查找和修改比较快，可以直接通过下标一次定位元素，但是删除和插入元素比较慢，因为需要复制和移动元素\n    3. linkedList底层实现为双向链表因为查找和修改元素比较慢，需要从头结点开始向后逐个遍历或从尾结点开始向前逐个遍历，但是删除和插入元素比较快，只需要修改指针的指向即可，不需要移动元素\n\n五、集合操作工具\n\n1. Iterator\n\n   迭代器，主要用于对Collection集合中的元素进行迭代遍历\n\n   1. iterator()：将Collection集合中元素放入到迭代器中，该方法必须由Collection接口的实现类来进行调用\n   2. hasNext():判断是否有下一个元素\n   3. next():将指针移动到下一行，并取当前元素\n   4. remove():通过迭代器删除集合中的元素\n\n   > 注意：当集合中元素正在迭代器中进行迭代时，不能通过集合来进行插入或删除元素，否则会发送并发修改异常（快速失败）\n\n2. Comparable\n\n   可比较的接口，用于比较两个引用类型对象之间的大小\n\n   使用方式;\n\n   1. 类型实现Comparable可比较接口\n   2. 在类中重写compareTo()方法，在方法中制定比较规则\n   3. 类中对象调用compareTo()方法，就可以比较大小了\n\n3. Collections\n\n   主要用于对Collection集合中的元素进行各种操作\n\n   主要方法：\n\n   1. addAll():一次性向集合中添加多个元素\n   2. reverse():翻转集合中元素\n   3. shuffle():洗牌，打乱集合中的元素\n   4. sort(List<T> list):对集合中的元素进行排序，要求集合中的元素必须实现Comparable可比较接口，然后按照重写compareTo()规则来对集合元素排序\n   5. sort(List<T> list,Comparator<? super T> c):对集合中元素按照Comparator比较器制定的规则来进行排序，如果集合中元素类型既实现了Comparable可比较接口，又外接了Comparator比较器，那么以Comparator比较器为准\n\n六、Map集合\n\n​\t主要用于key-value键值对格式的元素，其中key不能重复，如果key值相同，value值将会覆盖，不能保证元素的添加顺序，其主要实现类为：HashMap和TreeMap\n\n1. HashMap\n\n   1. key相同value覆盖\n   2. 不能保证添加顺序\n   3. 允许key或value为null\n\n2. 对象创建\n\n   1. 无参构造\n\n      ```java\n      HashMap<K,V> map = new HashMap<>();\n      ```\n\n3. 主要方法\n\n   1. put(K,V)：添加数据\n   2. get(K)：根据key获取value值\n   3. size()：获取集合长度\n   4. containsKey(K)：判断是否包含指定key值\n   5. containsValue(V)：判断是否包含指定value值\n   6. remove(K)：根据key值移除键值对\n   7. clear()：清空集合中元素\n   8. isEmpty()：判断集合是否为空\n   \n4. Map集合的三种遍历方式\n\n   1. 遍历所有的key\n\n      Set<K> set = map.keySet();\n\n   2. 遍历所有的value\n\n      Collection<V> value = map.values();\n\n   3. 遍历所有的Entry对象\n\n      Set<Map.Entry<K,V>> entries = map.entrySet();\n\n5. HashMap底层实现原理\n\n   HashMap底层实现为哈希表(散列表)\n\n   Java中哈希表的实现方案:\n\n   1. JDK<=1.7:哈希表=数组+单向链表\n\n   2. JDK>=1.8:哈希表=数组+单向链表+红黑树3\n\n   3. 数组：当使用无参构造创建HashMap对象时，默认初始化加载因子为0.75，当第一次调用put()方法向集合中添加元素时，会初始化一个16个长度的数组，当数组容量达到数组长度*加载因子时(第一次16\\*0.75),数组就会进行扩容，每次扩容之前长度的2倍，然后将之前数组中的所有元素取出来，重新计算下标值，再往新的数组中存储一次\n\n   4. 哈希表存数据具体过程\n\n      1. 根据key计算一个哈希值，然后再根据哈希值计算一个下标值\n\n      2. 如果该下标位置没有任何结点，直接存储\n\n      3. 该下标位置存在结点，进行比较，equals()返回true这是重复结点，就覆盖此结点返回false，以单向链表方式挂在该结点下\n\n      4. 如果该链表结点超过8个并且数组长度超过64个单向链表将换成红黑树\n\n      5. 如果链表结点超过8个，数组长度没有超过64，数组将进行翻倍扩容\n\n      6. 单向链表插入方式：\n\n         JDK<=1.7：头插法\n\n         JDK>=1.8:尾插法（避免多线程死链）\n\n      7. 当红黑树上的结点少于6个时，红黑树将转换成单向链表\n   \n6. 红黑树\n\n   1. 为什么使用红黑树\n\n      当往二叉排序树中插入数据时，如果后面的数据一直比前面的数据小或比前面的数据大，那么二叉树就会坍塌成一个单向链表，失去平衡，查找效率下降，所以需要红黑树来保证二叉排序树插入数据时的平衡性，红黑树是一种能够实现自平衡的二叉排序树\n\n   2. 红黑树的特点\n\n      1. 每个节点红色或者黑色，新节点默认红色\n      2. 根节点必须是黑色\n      3. 每个红色的节点的两个子节点必须是黑色节点\n      4. 每个叶子节点必须是黑色的空节点\n      5. 任一节点要每个叶子节点包含相同数量的黑色节点\n\n   3. 红黑树如何实现自平衡\n\n      1. 旋转\n      2. 变色\n\n7. Hashtable\n\n   HashMap和Hashtable的区别\n\n   1. HashMap和Hashtable都是Map接口的实现类，底层实现都是哈希表，其主要方法也相同\n   2. HashMap底层的哈希表为数组+单向链表+红黑树，Hashtable底层的哈希表为数组+单向链表\n   3. Hashtable线程安全，HashMap线程不安全\n\n8. TreeMap\n\n   1. 底层实现\n\n      TreeMap底层实现为红黑树，要求存储到集合中的key值必须能够比较大小，所以要求key值不能为null，key值要实现Comparable可比较接口或者在创建TreeMap对象时外接Comparator比较器，因此，TreeMap可以实现对Key值的排序，如果经过Comparable或Comparator比较两个key值的大小相等，那么value将会覆盖\n\n   2. 对象创建\n\n      1. 无参构造\n\n         > TreeMap<K,V> map = new TreeMap<>();\n         >\n         > 要求key必须实现Comparable可比较接口\n\n      2. 外接Comparator比较器\n\n         > TreeMap<K,V> map = new TreeMap<>(Comparator cmp)；\n         >\n         > 以Comparator比较器制定的规则来对key值进行排序，此时key可以不用实现Comparable可比较接口\n\n      3. 主要方法\n\n         与hashMap相同\n\n\n七、Set集合\n\n1. Set集合概念\n\n   Set是继承自Collection的子接口，里面只能用于存储单个元素，存储在该集合中的元素是不允许重复的，而且也不能保证元素的添加顺序\n\n   其主要的实现类：HashSet,TreeSet\n\n2. HashSet\n\n   1. 底层实现原理\n\n      HashSet底层是通过HashMap来进行数据存储，倍添加的数据会被当做是Key值，而value值是一个无意义的Object对象，最终将数据存储到哈希表中，所以要求Key必须重写HashCode（）和equals（）两个方法，相比较测认为是重复元素，那么后面元素就不存储了\n\n   2. 对象创建\n\n      HashSet<E> set = new HashSet<>();\n\n   3. 主要方法\n\n      参考ArrayList，没有根据下标取值的方法\n\n3. TreeSet\n\n   1. 底层实现原理\n\n      TreeSet底层是通过TreeMap来进行数据存储，被添加的数据会被当做Key值，而value值一个无意义的Object对象，添加的元素之间能够进行比较\n\n   2. 对象创建\n\n      1. 无参构造方法\n\n         TreeSet<E> set =new TreeSet<>();\n\n         要求被添加的元素必须实现Comparable可比较接口，按照重写的规则对元素数据进行排序\n\n      2. 外接Comparator比较器\n\n         TreeSet<E> map = new TreeSet<>(Comparator cmp);\n\n         以Comparator比较器制定的规则来对元素进行排序，此时被添加的元素可以不用实现Comparable可比较接口\n\n      3. 主要方法\n\n         参考ArrayList，没有更具下标取值的方法\n\n八、Stream流式操作\n\n1. 什么是Stream流式操作\n\n   将集合或数组中的元素当做是一种流，然后借助StreamApi以及lambda表达式对流中的数据来进行各种操作\n\n2. Stream流的使用步骤\n\n   1. 获取流对象\n\n      1. 单列集合：借助Collection接口中的stream默认方法\n      2. 双列集合：需要将其转成单列集合，第一种获取所有key，第二种获取所有value，第三种获取所有entry对象\n      3. 数组：借助Arrays工具类的Stream（）静态方法\n      4. 一堆零散数据：借助Stream类的of（）静态方法\n\n   2. 借助Stream流中方法来对数据进行操作\n\n      1. 中间操作\n\n         可以连续操作多次\n\n         filter（）：过滤\n\n         limit（）：获取前几个元素\n\n         skip（）：跳过前几个元素\n\n         distinct（）：去重\n\n         concat（）：合并两个流为一个流\n\n         map（）：转换流中数据类型\n\n      2. 最终操作\n\n         每个流只能进行一次操作，也就是最终操作方法调用万科后不能去调用其他方法了\n\n         forEach（）：迭代遍历\n\n         count（）：统计\n\n         toArray()：将剩下的数据存储到数组中\n\n         collect（）：将流中剩下的数据存储到集合中\n","source":"_posts/集合.md","raw":"---\ntitle: 集合\ndate: 2023-01-10 11:18:57\ntags: Java\ncategories: Java\ncover: /img/images/computer4.jpg\n---\n\n### 集合\n\n一、什么是集合\n\n​\t将一堆数据组织起来并存储带一个指定的数据结构容器中，Java中集合 其实就是一堆底层为数据结构容器的类或接口\n\n\n\n二、集合的分类\n\n​\tCollection(父接口)\n\n​\t主要用于存储单个元素\n\n1. list(子接口)：列表集合，该集合中存储的元素是允许重复，且能保证元素的添加顺序\n   1. ArrayList(实现类)底层实现为数组\n   2. LinkedList(实现类)底层实现为双向链表\n2. Set(子接口)：该集合中存储的元素是不允许重复的，且不能保证元素的添加顺序\n   1. HashSet(实现类)底层实现为HashMap\n   2. TreeSet(实现类)底层实现为TreeMap\n3. Queue(子接口)：默认为一个单向队列\n   1. Deque(子接口)：双向队列\n      1. LinkedList(实现类)通过双向链表数据结构实现了单向队列，双向队列和栈结构\n\n​\t\n\n​\tMap(父接口)\n\n​\t主要用于存储键值对形式的元素\n\n1. HashMap(实现类)底层实现为哈希表\n2. TreeMap(实现类)底层实现为二叉树(红黑树)\n\n\n\n三、集合工具类\n\n1. Arrays\n2. Collections\n3. Iterator\n4. Comparable\n5. Comparator\n6. Stream\n\n\n\n四、List接口\n\n​\t列表集合，Collection接口的子接口，存储在集合中的元素是可以重复的，并且能保证元素的添加顺序，其主要实现类为：Arraylist和LinkedList\n\n1. ArrayList\n\n   底层为一个Object[]数组\n   \n   ArrayList<E> list = new ArrayList<E>\n   \n   ArrayList<E> list = new ArrayList<E>(int initialCapacity)\n   \n   boolean add(E e)向集合末尾添加元素\n   \n   void add(E e)向集合中指定下标位置插入一个元素\n   \n   E get(int index)获取指定下标位置元素\n   \n   int size()获取集合长度\n   \n   E remove(int index)根据下标删除集合中元素，返回被删除的\n   \n   boolean remove(E e)根据内容删除集合中元素，返回是否删除成功\n   \n   int indexOf(E e)根据内容查找指定元素的下标\n   \n   E set(int index,E e)替换指定下标元素，返回被替换的元素\n   \n   boolean contains(E e)判断是否包含指定元素\n   \n   void clear()清空集合中的元素\n   \n   boolean isEmpty()判断集合是否为空\n   \n   Object[] toArray()将集合转为数组\n   \n   boolean addAll(Collection<? extends E> collect)向一个集合中添加另外一个集合中的元素\n   \n   boolean removeAll(Collection<? extends E> collect)向一个集合中移除另外一个集合中的元素\n   \n   > 快速失败机制：当集合中的元素正在迭代器中进行迭代时，不能通过集合对象元素进行添加或修改操作，会引发并发修改异常\n   \n   ArrayList扩容过程\n   \n   1. 当使用无参构造创建ArrayList对象时，会初始化一个长度为0的Object[]数组\n   2. 当第一次调用add()方法时，再将该Object[]数组长度扩容到10个\n   3. 当后续继续调用add()方法时，先判断长度是否够用，如果不够再将该Object[]数组长度扩容为之前的1.5倍\n   \n   Vector(了解)\n   \n   1. 和ArrayList相同，都是List接口的实现类，底层都是通过Object[]数组来存储元素\n   2. 当通过无参构造创建Vector对象时，默认初始化一个长度为10的Object[]数组,后续每次需要扩容，将扩容之前长度的2倍\n   3. Vector是一个线程安全的ArrayList\n   \n2. LinkedList\n\n   1. linkedList概念\n   \n   2. 底层实现了为一个双向链表，链表上的每一个结点由三部分组成\n      1. 前驱指针：保存上一个结点的内存地址\n      2. 结点内容：当前结点保存的值\n      3. 后驱指针：保存下一个结点的内存地址\n      \n   3. LinkedList作为双向链表使用\n   \n      实现了List接口，拥有和ArrayList相同的方法，但是其内部方法都是采用双向链表来进行实现\n      \n   4. LinkedList作为单向队列使用\n   \n      实现了Queue接口，因此可以作为一个单向队列来使用\n      \n      单向队列的方法：\n      \n      offer()\n      \n      队尾入队\n      \n      peek()\n      \n      获取但不移除队首元素\n      \n      poll()\n      \n      队首出队\n      \n   5. LinkedList作为双向队列使用\n      \n      实现了Deque接口，因此可以作为一个双向队列来使用\n      \n      队首入队，队尾出队\n      \n      队尾入队，队首出队\n      \n      双向队列的方法：\n      \n      offerFirst()队首入队\n      \n      offerLast()队尾入队\n      \n      peekFirst()获取但不移除队首元素\n      \n      peekLast()获取但不移除队尾元素\n      \n      pollFirst()队首出队\n      \n      pollLast()队尾出队\n      \n   6. LinkedList作为栈使用\n      \n      作为栈结构的方法：\n      \n      push()入栈，压栈\n      \n      pop()出栈，弹栈\n   \n 3. ArrayList和LinkedLisst有什么区别\n\n    1. 都是实现了List接口，因此都能保证元素的添加顺序以及可以添加重复元素\n    2. ArrayList底层实现为数组，因此查找和修改比较快，可以直接通过下标一次定位元素，但是删除和插入元素比较慢，因为需要复制和移动元素\n    3. linkedList底层实现为双向链表因为查找和修改元素比较慢，需要从头结点开始向后逐个遍历或从尾结点开始向前逐个遍历，但是删除和插入元素比较快，只需要修改指针的指向即可，不需要移动元素\n\n五、集合操作工具\n\n1. Iterator\n\n   迭代器，主要用于对Collection集合中的元素进行迭代遍历\n\n   1. iterator()：将Collection集合中元素放入到迭代器中，该方法必须由Collection接口的实现类来进行调用\n   2. hasNext():判断是否有下一个元素\n   3. next():将指针移动到下一行，并取当前元素\n   4. remove():通过迭代器删除集合中的元素\n\n   > 注意：当集合中元素正在迭代器中进行迭代时，不能通过集合来进行插入或删除元素，否则会发送并发修改异常（快速失败）\n\n2. Comparable\n\n   可比较的接口，用于比较两个引用类型对象之间的大小\n\n   使用方式;\n\n   1. 类型实现Comparable可比较接口\n   2. 在类中重写compareTo()方法，在方法中制定比较规则\n   3. 类中对象调用compareTo()方法，就可以比较大小了\n\n3. Collections\n\n   主要用于对Collection集合中的元素进行各种操作\n\n   主要方法：\n\n   1. addAll():一次性向集合中添加多个元素\n   2. reverse():翻转集合中元素\n   3. shuffle():洗牌，打乱集合中的元素\n   4. sort(List<T> list):对集合中的元素进行排序，要求集合中的元素必须实现Comparable可比较接口，然后按照重写compareTo()规则来对集合元素排序\n   5. sort(List<T> list,Comparator<? super T> c):对集合中元素按照Comparator比较器制定的规则来进行排序，如果集合中元素类型既实现了Comparable可比较接口，又外接了Comparator比较器，那么以Comparator比较器为准\n\n六、Map集合\n\n​\t主要用于key-value键值对格式的元素，其中key不能重复，如果key值相同，value值将会覆盖，不能保证元素的添加顺序，其主要实现类为：HashMap和TreeMap\n\n1. HashMap\n\n   1. key相同value覆盖\n   2. 不能保证添加顺序\n   3. 允许key或value为null\n\n2. 对象创建\n\n   1. 无参构造\n\n      ```java\n      HashMap<K,V> map = new HashMap<>();\n      ```\n\n3. 主要方法\n\n   1. put(K,V)：添加数据\n   2. get(K)：根据key获取value值\n   3. size()：获取集合长度\n   4. containsKey(K)：判断是否包含指定key值\n   5. containsValue(V)：判断是否包含指定value值\n   6. remove(K)：根据key值移除键值对\n   7. clear()：清空集合中元素\n   8. isEmpty()：判断集合是否为空\n   \n4. Map集合的三种遍历方式\n\n   1. 遍历所有的key\n\n      Set<K> set = map.keySet();\n\n   2. 遍历所有的value\n\n      Collection<V> value = map.values();\n\n   3. 遍历所有的Entry对象\n\n      Set<Map.Entry<K,V>> entries = map.entrySet();\n\n5. HashMap底层实现原理\n\n   HashMap底层实现为哈希表(散列表)\n\n   Java中哈希表的实现方案:\n\n   1. JDK<=1.7:哈希表=数组+单向链表\n\n   2. JDK>=1.8:哈希表=数组+单向链表+红黑树3\n\n   3. 数组：当使用无参构造创建HashMap对象时，默认初始化加载因子为0.75，当第一次调用put()方法向集合中添加元素时，会初始化一个16个长度的数组，当数组容量达到数组长度*加载因子时(第一次16\\*0.75),数组就会进行扩容，每次扩容之前长度的2倍，然后将之前数组中的所有元素取出来，重新计算下标值，再往新的数组中存储一次\n\n   4. 哈希表存数据具体过程\n\n      1. 根据key计算一个哈希值，然后再根据哈希值计算一个下标值\n\n      2. 如果该下标位置没有任何结点，直接存储\n\n      3. 该下标位置存在结点，进行比较，equals()返回true这是重复结点，就覆盖此结点返回false，以单向链表方式挂在该结点下\n\n      4. 如果该链表结点超过8个并且数组长度超过64个单向链表将换成红黑树\n\n      5. 如果链表结点超过8个，数组长度没有超过64，数组将进行翻倍扩容\n\n      6. 单向链表插入方式：\n\n         JDK<=1.7：头插法\n\n         JDK>=1.8:尾插法（避免多线程死链）\n\n      7. 当红黑树上的结点少于6个时，红黑树将转换成单向链表\n   \n6. 红黑树\n\n   1. 为什么使用红黑树\n\n      当往二叉排序树中插入数据时，如果后面的数据一直比前面的数据小或比前面的数据大，那么二叉树就会坍塌成一个单向链表，失去平衡，查找效率下降，所以需要红黑树来保证二叉排序树插入数据时的平衡性，红黑树是一种能够实现自平衡的二叉排序树\n\n   2. 红黑树的特点\n\n      1. 每个节点红色或者黑色，新节点默认红色\n      2. 根节点必须是黑色\n      3. 每个红色的节点的两个子节点必须是黑色节点\n      4. 每个叶子节点必须是黑色的空节点\n      5. 任一节点要每个叶子节点包含相同数量的黑色节点\n\n   3. 红黑树如何实现自平衡\n\n      1. 旋转\n      2. 变色\n\n7. Hashtable\n\n   HashMap和Hashtable的区别\n\n   1. HashMap和Hashtable都是Map接口的实现类，底层实现都是哈希表，其主要方法也相同\n   2. HashMap底层的哈希表为数组+单向链表+红黑树，Hashtable底层的哈希表为数组+单向链表\n   3. Hashtable线程安全，HashMap线程不安全\n\n8. TreeMap\n\n   1. 底层实现\n\n      TreeMap底层实现为红黑树，要求存储到集合中的key值必须能够比较大小，所以要求key值不能为null，key值要实现Comparable可比较接口或者在创建TreeMap对象时外接Comparator比较器，因此，TreeMap可以实现对Key值的排序，如果经过Comparable或Comparator比较两个key值的大小相等，那么value将会覆盖\n\n   2. 对象创建\n\n      1. 无参构造\n\n         > TreeMap<K,V> map = new TreeMap<>();\n         >\n         > 要求key必须实现Comparable可比较接口\n\n      2. 外接Comparator比较器\n\n         > TreeMap<K,V> map = new TreeMap<>(Comparator cmp)；\n         >\n         > 以Comparator比较器制定的规则来对key值进行排序，此时key可以不用实现Comparable可比较接口\n\n      3. 主要方法\n\n         与hashMap相同\n\n\n七、Set集合\n\n1. Set集合概念\n\n   Set是继承自Collection的子接口，里面只能用于存储单个元素，存储在该集合中的元素是不允许重复的，而且也不能保证元素的添加顺序\n\n   其主要的实现类：HashSet,TreeSet\n\n2. HashSet\n\n   1. 底层实现原理\n\n      HashSet底层是通过HashMap来进行数据存储，倍添加的数据会被当做是Key值，而value值是一个无意义的Object对象，最终将数据存储到哈希表中，所以要求Key必须重写HashCode（）和equals（）两个方法，相比较测认为是重复元素，那么后面元素就不存储了\n\n   2. 对象创建\n\n      HashSet<E> set = new HashSet<>();\n\n   3. 主要方法\n\n      参考ArrayList，没有根据下标取值的方法\n\n3. TreeSet\n\n   1. 底层实现原理\n\n      TreeSet底层是通过TreeMap来进行数据存储，被添加的数据会被当做Key值，而value值一个无意义的Object对象，添加的元素之间能够进行比较\n\n   2. 对象创建\n\n      1. 无参构造方法\n\n         TreeSet<E> set =new TreeSet<>();\n\n         要求被添加的元素必须实现Comparable可比较接口，按照重写的规则对元素数据进行排序\n\n      2. 外接Comparator比较器\n\n         TreeSet<E> map = new TreeSet<>(Comparator cmp);\n\n         以Comparator比较器制定的规则来对元素进行排序，此时被添加的元素可以不用实现Comparable可比较接口\n\n      3. 主要方法\n\n         参考ArrayList，没有更具下标取值的方法\n\n八、Stream流式操作\n\n1. 什么是Stream流式操作\n\n   将集合或数组中的元素当做是一种流，然后借助StreamApi以及lambda表达式对流中的数据来进行各种操作\n\n2. Stream流的使用步骤\n\n   1. 获取流对象\n\n      1. 单列集合：借助Collection接口中的stream默认方法\n      2. 双列集合：需要将其转成单列集合，第一种获取所有key，第二种获取所有value，第三种获取所有entry对象\n      3. 数组：借助Arrays工具类的Stream（）静态方法\n      4. 一堆零散数据：借助Stream类的of（）静态方法\n\n   2. 借助Stream流中方法来对数据进行操作\n\n      1. 中间操作\n\n         可以连续操作多次\n\n         filter（）：过滤\n\n         limit（）：获取前几个元素\n\n         skip（）：跳过前几个元素\n\n         distinct（）：去重\n\n         concat（）：合并两个流为一个流\n\n         map（）：转换流中数据类型\n\n      2. 最终操作\n\n         每个流只能进行一次操作，也就是最终操作方法调用万科后不能去调用其他方法了\n\n         forEach（）：迭代遍历\n\n         count（）：统计\n\n         toArray()：将剩下的数据存储到数组中\n\n         collect（）：将流中剩下的数据存储到集合中\n","slug":"集合","published":1,"updated":"2023-08-10T09:48:08.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwai002wfswofp5r41m1","content":"<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>一、什么是集合</p>\n<p>​\t将一堆数据组织起来并存储带一个指定的数据结构容器中，Java中集合 其实就是一堆底层为数据结构容器的类或接口</p>\n<p>二、集合的分类</p>\n<p>​\tCollection(父接口)</p>\n<p>​\t主要用于存储单个元素</p>\n<ol>\n<li>list(子接口)：列表集合，该集合中存储的元素是允许重复，且能保证元素的添加顺序<ol>\n<li>ArrayList(实现类)底层实现为数组</li>\n<li>LinkedList(实现类)底层实现为双向链表</li>\n</ol>\n</li>\n<li>Set(子接口)：该集合中存储的元素是不允许重复的，且不能保证元素的添加顺序<ol>\n<li>HashSet(实现类)底层实现为HashMap</li>\n<li>TreeSet(实现类)底层实现为TreeMap</li>\n</ol>\n</li>\n<li>Queue(子接口)：默认为一个单向队列<ol>\n<li>Deque(子接口)：双向队列<ol>\n<li>LinkedList(实现类)通过双向链表数据结构实现了单向队列，双向队列和栈结构</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>​\t</p>\n<p>​\tMap(父接口)</p>\n<p>​\t主要用于存储键值对形式的元素</p>\n<ol>\n<li>HashMap(实现类)底层实现为哈希表</li>\n<li>TreeMap(实现类)底层实现为二叉树(红黑树)</li>\n</ol>\n<p>三、集合工具类</p>\n<ol>\n<li>Arrays</li>\n<li>Collections</li>\n<li>Iterator</li>\n<li>Comparable</li>\n<li>Comparator</li>\n<li>Stream</li>\n</ol>\n<p>四、List接口</p>\n<p>​\t列表集合，Collection接口的子接口，存储在集合中的元素是可以重复的，并且能保证元素的添加顺序，其主要实现类为：Arraylist和LinkedList</p>\n<ol>\n<li><p>ArrayList</p>\n<p>底层为一个Object[]数组</p>\n<p>ArrayList<E> list &#x3D; new ArrayList<E></p>\n<p>ArrayList<E> list &#x3D; new ArrayList<E>(int initialCapacity)</p>\n<p>boolean add(E e)向集合末尾添加元素</p>\n<p>void add(E e)向集合中指定下标位置插入一个元素</p>\n<p>E get(int index)获取指定下标位置元素</p>\n<p>int size()获取集合长度</p>\n<p>E remove(int index)根据下标删除集合中元素，返回被删除的</p>\n<p>boolean remove(E e)根据内容删除集合中元素，返回是否删除成功</p>\n<p>int indexOf(E e)根据内容查找指定元素的下标</p>\n<p>E set(int index,E e)替换指定下标元素，返回被替换的元素</p>\n<p>boolean contains(E e)判断是否包含指定元素</p>\n<p>void clear()清空集合中的元素</p>\n<p>boolean isEmpty()判断集合是否为空</p>\n<p>Object[] toArray()将集合转为数组</p>\n<p>boolean addAll(Collection&lt;? extends E&gt; collect)向一个集合中添加另外一个集合中的元素</p>\n<p>boolean removeAll(Collection&lt;? extends E&gt; collect)向一个集合中移除另外一个集合中的元素</p>\n<blockquote>\n<p>快速失败机制：当集合中的元素正在迭代器中进行迭代时，不能通过集合对象元素进行添加或修改操作，会引发并发修改异常</p>\n</blockquote>\n<p>ArrayList扩容过程</p>\n<ol>\n<li>当使用无参构造创建ArrayList对象时，会初始化一个长度为0的Object[]数组</li>\n<li>当第一次调用add()方法时，再将该Object[]数组长度扩容到10个</li>\n<li>当后续继续调用add()方法时，先判断长度是否够用，如果不够再将该Object[]数组长度扩容为之前的1.5倍</li>\n</ol>\n<p>Vector(了解)</p>\n<ol>\n<li>和ArrayList相同，都是List接口的实现类，底层都是通过Object[]数组来存储元素</li>\n<li>当通过无参构造创建Vector对象时，默认初始化一个长度为10的Object[]数组,后续每次需要扩容，将扩容之前长度的2倍</li>\n<li>Vector是一个线程安全的ArrayList</li>\n</ol>\n</li>\n<li><p>LinkedList</p>\n<ol>\n<li><p>linkedList概念</p>\n</li>\n<li><p>底层实现了为一个双向链表，链表上的每一个结点由三部分组成</p>\n<ol>\n<li>前驱指针：保存上一个结点的内存地址</li>\n<li>结点内容：当前结点保存的值</li>\n<li>后驱指针：保存下一个结点的内存地址</li>\n</ol>\n</li>\n<li><p>LinkedList作为双向链表使用</p>\n<p>实现了List接口，拥有和ArrayList相同的方法，但是其内部方法都是采用双向链表来进行实现</p>\n</li>\n<li><p>LinkedList作为单向队列使用</p>\n<p>实现了Queue接口，因此可以作为一个单向队列来使用</p>\n<p>单向队列的方法：</p>\n<p>offer()</p>\n<p>队尾入队</p>\n<p>peek()</p>\n<p>获取但不移除队首元素</p>\n<p>poll()</p>\n<p>队首出队</p>\n</li>\n<li><p>LinkedList作为双向队列使用</p>\n<p>实现了Deque接口，因此可以作为一个双向队列来使用</p>\n<p>队首入队，队尾出队</p>\n<p>队尾入队，队首出队</p>\n<p>双向队列的方法：</p>\n<p>offerFirst()队首入队</p>\n<p>offerLast()队尾入队</p>\n<p>peekFirst()获取但不移除队首元素</p>\n<p>peekLast()获取但不移除队尾元素</p>\n<p>pollFirst()队首出队</p>\n<p>pollLast()队尾出队</p>\n</li>\n<li><p>LinkedList作为栈使用</p>\n<p>作为栈结构的方法：</p>\n<p>push()入栈，压栈</p>\n<p>pop()出栈，弹栈</p>\n</li>\n</ol>\n</li>\n<li><p>ArrayList和LinkedLisst有什么区别</p>\n<ol>\n<li>都是实现了List接口，因此都能保证元素的添加顺序以及可以添加重复元素</li>\n<li>ArrayList底层实现为数组，因此查找和修改比较快，可以直接通过下标一次定位元素，但是删除和插入元素比较慢，因为需要复制和移动元素</li>\n<li>linkedList底层实现为双向链表因为查找和修改元素比较慢，需要从头结点开始向后逐个遍历或从尾结点开始向前逐个遍历，但是删除和插入元素比较快，只需要修改指针的指向即可，不需要移动元素</li>\n</ol>\n</li>\n</ol>\n<p>五、集合操作工具</p>\n<ol>\n<li><p>Iterator</p>\n<p>迭代器，主要用于对Collection集合中的元素进行迭代遍历</p>\n<ol>\n<li>iterator()：将Collection集合中元素放入到迭代器中，该方法必须由Collection接口的实现类来进行调用</li>\n<li>hasNext():判断是否有下一个元素</li>\n<li>next():将指针移动到下一行，并取当前元素</li>\n<li>remove():通过迭代器删除集合中的元素</li>\n</ol>\n<blockquote>\n<p>注意：当集合中元素正在迭代器中进行迭代时，不能通过集合来进行插入或删除元素，否则会发送并发修改异常（快速失败）</p>\n</blockquote>\n</li>\n<li><p>Comparable</p>\n<p>可比较的接口，用于比较两个引用类型对象之间的大小</p>\n<p>使用方式;</p>\n<ol>\n<li>类型实现Comparable可比较接口</li>\n<li>在类中重写compareTo()方法，在方法中制定比较规则</li>\n<li>类中对象调用compareTo()方法，就可以比较大小了</li>\n</ol>\n</li>\n<li><p>Collections</p>\n<p>主要用于对Collection集合中的元素进行各种操作</p>\n<p>主要方法：</p>\n<ol>\n<li>addAll():一次性向集合中添加多个元素</li>\n<li>reverse():翻转集合中元素</li>\n<li>shuffle():洗牌，打乱集合中的元素</li>\n<li>sort(List<T> list):对集合中的元素进行排序，要求集合中的元素必须实现Comparable可比较接口，然后按照重写compareTo()规则来对集合元素排序</li>\n<li>sort(List<T> list,Comparator&lt;? super T&gt; c):对集合中元素按照Comparator比较器制定的规则来进行排序，如果集合中元素类型既实现了Comparable可比较接口，又外接了Comparator比较器，那么以Comparator比较器为准</li>\n</ol>\n</li>\n</ol>\n<p>六、Map集合</p>\n<p>​\t主要用于key-value键值对格式的元素，其中key不能重复，如果key值相同，value值将会覆盖，不能保证元素的添加顺序，其主要实现类为：HashMap和TreeMap</p>\n<ol>\n<li><p>HashMap</p>\n<ol>\n<li>key相同value覆盖</li>\n<li>不能保证添加顺序</li>\n<li>允许key或value为null</li>\n</ol>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;K,V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>主要方法</p>\n<ol>\n<li>put(K,V)：添加数据</li>\n<li>get(K)：根据key获取value值</li>\n<li>size()：获取集合长度</li>\n<li>containsKey(K)：判断是否包含指定key值</li>\n<li>containsValue(V)：判断是否包含指定value值</li>\n<li>remove(K)：根据key值移除键值对</li>\n<li>clear()：清空集合中元素</li>\n<li>isEmpty()：判断集合是否为空</li>\n</ol>\n</li>\n<li><p>Map集合的三种遍历方式</p>\n<ol>\n<li><p>遍历所有的key</p>\n<p>Set<K> set &#x3D; map.keySet();</p>\n</li>\n<li><p>遍历所有的value</p>\n<p>Collection<V> value &#x3D; map.values();</p>\n</li>\n<li><p>遍历所有的Entry对象</p>\n<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entries &#x3D; map.entrySet();</p>\n</li>\n</ol>\n</li>\n<li><p>HashMap底层实现原理</p>\n<p>HashMap底层实现为哈希表(散列表)</p>\n<p>Java中哈希表的实现方案:</p>\n<ol>\n<li><p>JDK&lt;&#x3D;1.7:哈希表&#x3D;数组+单向链表</p>\n</li>\n<li><p>JDK&gt;&#x3D;1.8:哈希表&#x3D;数组+单向链表+红黑树3</p>\n</li>\n<li><p>数组：当使用无参构造创建HashMap对象时，默认初始化加载因子为0.75，当第一次调用put()方法向集合中添加元素时，会初始化一个16个长度的数组，当数组容量达到数组长度*加载因子时(第一次16*0.75),数组就会进行扩容，每次扩容之前长度的2倍，然后将之前数组中的所有元素取出来，重新计算下标值，再往新的数组中存储一次</p>\n</li>\n<li><p>哈希表存数据具体过程</p>\n<ol>\n<li><p>根据key计算一个哈希值，然后再根据哈希值计算一个下标值</p>\n</li>\n<li><p>如果该下标位置没有任何结点，直接存储</p>\n</li>\n<li><p>该下标位置存在结点，进行比较，equals()返回true这是重复结点，就覆盖此结点返回false，以单向链表方式挂在该结点下</p>\n</li>\n<li><p>如果该链表结点超过8个并且数组长度超过64个单向链表将换成红黑树</p>\n</li>\n<li><p>如果链表结点超过8个，数组长度没有超过64，数组将进行翻倍扩容</p>\n</li>\n<li><p>单向链表插入方式：</p>\n<p>JDK&lt;&#x3D;1.7：头插法</p>\n<p>JDK&gt;&#x3D;1.8:尾插法（避免多线程死链）</p>\n</li>\n<li><p>当红黑树上的结点少于6个时，红黑树将转换成单向链表</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>红黑树</p>\n<ol>\n<li><p>为什么使用红黑树</p>\n<p>当往二叉排序树中插入数据时，如果后面的数据一直比前面的数据小或比前面的数据大，那么二叉树就会坍塌成一个单向链表，失去平衡，查找效率下降，所以需要红黑树来保证二叉排序树插入数据时的平衡性，红黑树是一种能够实现自平衡的二叉排序树</p>\n</li>\n<li><p>红黑树的特点</p>\n<ol>\n<li>每个节点红色或者黑色，新节点默认红色</li>\n<li>根节点必须是黑色</li>\n<li>每个红色的节点的两个子节点必须是黑色节点</li>\n<li>每个叶子节点必须是黑色的空节点</li>\n<li>任一节点要每个叶子节点包含相同数量的黑色节点</li>\n</ol>\n</li>\n<li><p>红黑树如何实现自平衡</p>\n<ol>\n<li>旋转</li>\n<li>变色</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Hashtable</p>\n<p>HashMap和Hashtable的区别</p>\n<ol>\n<li>HashMap和Hashtable都是Map接口的实现类，底层实现都是哈希表，其主要方法也相同</li>\n<li>HashMap底层的哈希表为数组+单向链表+红黑树，Hashtable底层的哈希表为数组+单向链表</li>\n<li>Hashtable线程安全，HashMap线程不安全</li>\n</ol>\n</li>\n<li><p>TreeMap</p>\n<ol>\n<li><p>底层实现</p>\n<p>TreeMap底层实现为红黑树，要求存储到集合中的key值必须能够比较大小，所以要求key值不能为null，key值要实现Comparable可比较接口或者在创建TreeMap对象时外接Comparator比较器，因此，TreeMap可以实现对Key值的排序，如果经过Comparable或Comparator比较两个key值的大小相等，那么value将会覆盖</p>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造</p>\n<blockquote>\n<p>TreeMap&lt;K,V&gt; map &#x3D; new TreeMap&lt;&gt;();</p>\n<p>要求key必须实现Comparable可比较接口</p>\n</blockquote>\n</li>\n<li><p>外接Comparator比较器</p>\n<blockquote>\n<p>TreeMap&lt;K,V&gt; map &#x3D; new TreeMap&lt;&gt;(Comparator cmp)；</p>\n<p>以Comparator比较器制定的规则来对key值进行排序，此时key可以不用实现Comparable可比较接口</p>\n</blockquote>\n</li>\n<li><p>主要方法</p>\n<p>与hashMap相同</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>七、Set集合</p>\n<ol>\n<li><p>Set集合概念</p>\n<p>Set是继承自Collection的子接口，里面只能用于存储单个元素，存储在该集合中的元素是不允许重复的，而且也不能保证元素的添加顺序</p>\n<p>其主要的实现类：HashSet,TreeSet</p>\n</li>\n<li><p>HashSet</p>\n<ol>\n<li><p>底层实现原理</p>\n<p>HashSet底层是通过HashMap来进行数据存储，倍添加的数据会被当做是Key值，而value值是一个无意义的Object对象，最终将数据存储到哈希表中，所以要求Key必须重写HashCode（）和equals（）两个方法，相比较测认为是重复元素，那么后面元素就不存储了</p>\n</li>\n<li><p>对象创建</p>\n<p>HashSet<E> set &#x3D; new HashSet&lt;&gt;();</p>\n</li>\n<li><p>主要方法</p>\n<p>参考ArrayList，没有根据下标取值的方法</p>\n</li>\n</ol>\n</li>\n<li><p>TreeSet</p>\n<ol>\n<li><p>底层实现原理</p>\n<p>TreeSet底层是通过TreeMap来进行数据存储，被添加的数据会被当做Key值，而value值一个无意义的Object对象，添加的元素之间能够进行比较</p>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造方法</p>\n<p>TreeSet<E> set &#x3D;new TreeSet&lt;&gt;();</p>\n<p>要求被添加的元素必须实现Comparable可比较接口，按照重写的规则对元素数据进行排序</p>\n</li>\n<li><p>外接Comparator比较器</p>\n<p>TreeSet<E> map &#x3D; new TreeSet&lt;&gt;(Comparator cmp);</p>\n<p>以Comparator比较器制定的规则来对元素进行排序，此时被添加的元素可以不用实现Comparable可比较接口</p>\n</li>\n<li><p>主要方法</p>\n<p>参考ArrayList，没有更具下标取值的方法</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>八、Stream流式操作</p>\n<ol>\n<li><p>什么是Stream流式操作</p>\n<p>将集合或数组中的元素当做是一种流，然后借助StreamApi以及lambda表达式对流中的数据来进行各种操作</p>\n</li>\n<li><p>Stream流的使用步骤</p>\n<ol>\n<li><p>获取流对象</p>\n<ol>\n<li>单列集合：借助Collection接口中的stream默认方法</li>\n<li>双列集合：需要将其转成单列集合，第一种获取所有key，第二种获取所有value，第三种获取所有entry对象</li>\n<li>数组：借助Arrays工具类的Stream（）静态方法</li>\n<li>一堆零散数据：借助Stream类的of（）静态方法</li>\n</ol>\n</li>\n<li><p>借助Stream流中方法来对数据进行操作</p>\n<ol>\n<li><p>中间操作</p>\n<p>可以连续操作多次</p>\n<p>filter（）：过滤</p>\n<p>limit（）：获取前几个元素</p>\n<p>skip（）：跳过前几个元素</p>\n<p>distinct（）：去重</p>\n<p>concat（）：合并两个流为一个流</p>\n<p>map（）：转换流中数据类型</p>\n</li>\n<li><p>最终操作</p>\n<p>每个流只能进行一次操作，也就是最终操作方法调用万科后不能去调用其他方法了</p>\n<p>forEach（）：迭代遍历</p>\n<p>count（）：统计</p>\n<p>toArray()：将剩下的数据存储到数组中</p>\n<p>collect（）：将流中剩下的数据存储到集合中</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>一、什么是集合</p>\n<p>​\t将一堆数据组织起来并存储带一个指定的数据结构容器中，Java中集合 其实就是一堆底层为数据结构容器的类或接口</p>\n<p>二、集合的分类</p>\n<p>​\tCollection(父接口)</p>\n<p>​\t主要用于存储单个元素</p>\n<ol>\n<li>list(子接口)：列表集合，该集合中存储的元素是允许重复，且能保证元素的添加顺序<ol>\n<li>ArrayList(实现类)底层实现为数组</li>\n<li>LinkedList(实现类)底层实现为双向链表</li>\n</ol>\n</li>\n<li>Set(子接口)：该集合中存储的元素是不允许重复的，且不能保证元素的添加顺序<ol>\n<li>HashSet(实现类)底层实现为HashMap</li>\n<li>TreeSet(实现类)底层实现为TreeMap</li>\n</ol>\n</li>\n<li>Queue(子接口)：默认为一个单向队列<ol>\n<li>Deque(子接口)：双向队列<ol>\n<li>LinkedList(实现类)通过双向链表数据结构实现了单向队列，双向队列和栈结构</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>​\t</p>\n<p>​\tMap(父接口)</p>\n<p>​\t主要用于存储键值对形式的元素</p>\n<ol>\n<li>HashMap(实现类)底层实现为哈希表</li>\n<li>TreeMap(实现类)底层实现为二叉树(红黑树)</li>\n</ol>\n<p>三、集合工具类</p>\n<ol>\n<li>Arrays</li>\n<li>Collections</li>\n<li>Iterator</li>\n<li>Comparable</li>\n<li>Comparator</li>\n<li>Stream</li>\n</ol>\n<p>四、List接口</p>\n<p>​\t列表集合，Collection接口的子接口，存储在集合中的元素是可以重复的，并且能保证元素的添加顺序，其主要实现类为：Arraylist和LinkedList</p>\n<ol>\n<li><p>ArrayList</p>\n<p>底层为一个Object[]数组</p>\n<p>ArrayList<E> list &#x3D; new ArrayList<E></p>\n<p>ArrayList<E> list &#x3D; new ArrayList<E>(int initialCapacity)</p>\n<p>boolean add(E e)向集合末尾添加元素</p>\n<p>void add(E e)向集合中指定下标位置插入一个元素</p>\n<p>E get(int index)获取指定下标位置元素</p>\n<p>int size()获取集合长度</p>\n<p>E remove(int index)根据下标删除集合中元素，返回被删除的</p>\n<p>boolean remove(E e)根据内容删除集合中元素，返回是否删除成功</p>\n<p>int indexOf(E e)根据内容查找指定元素的下标</p>\n<p>E set(int index,E e)替换指定下标元素，返回被替换的元素</p>\n<p>boolean contains(E e)判断是否包含指定元素</p>\n<p>void clear()清空集合中的元素</p>\n<p>boolean isEmpty()判断集合是否为空</p>\n<p>Object[] toArray()将集合转为数组</p>\n<p>boolean addAll(Collection&lt;? extends E&gt; collect)向一个集合中添加另外一个集合中的元素</p>\n<p>boolean removeAll(Collection&lt;? extends E&gt; collect)向一个集合中移除另外一个集合中的元素</p>\n<blockquote>\n<p>快速失败机制：当集合中的元素正在迭代器中进行迭代时，不能通过集合对象元素进行添加或修改操作，会引发并发修改异常</p>\n</blockquote>\n<p>ArrayList扩容过程</p>\n<ol>\n<li>当使用无参构造创建ArrayList对象时，会初始化一个长度为0的Object[]数组</li>\n<li>当第一次调用add()方法时，再将该Object[]数组长度扩容到10个</li>\n<li>当后续继续调用add()方法时，先判断长度是否够用，如果不够再将该Object[]数组长度扩容为之前的1.5倍</li>\n</ol>\n<p>Vector(了解)</p>\n<ol>\n<li>和ArrayList相同，都是List接口的实现类，底层都是通过Object[]数组来存储元素</li>\n<li>当通过无参构造创建Vector对象时，默认初始化一个长度为10的Object[]数组,后续每次需要扩容，将扩容之前长度的2倍</li>\n<li>Vector是一个线程安全的ArrayList</li>\n</ol>\n</li>\n<li><p>LinkedList</p>\n<ol>\n<li><p>linkedList概念</p>\n</li>\n<li><p>底层实现了为一个双向链表，链表上的每一个结点由三部分组成</p>\n<ol>\n<li>前驱指针：保存上一个结点的内存地址</li>\n<li>结点内容：当前结点保存的值</li>\n<li>后驱指针：保存下一个结点的内存地址</li>\n</ol>\n</li>\n<li><p>LinkedList作为双向链表使用</p>\n<p>实现了List接口，拥有和ArrayList相同的方法，但是其内部方法都是采用双向链表来进行实现</p>\n</li>\n<li><p>LinkedList作为单向队列使用</p>\n<p>实现了Queue接口，因此可以作为一个单向队列来使用</p>\n<p>单向队列的方法：</p>\n<p>offer()</p>\n<p>队尾入队</p>\n<p>peek()</p>\n<p>获取但不移除队首元素</p>\n<p>poll()</p>\n<p>队首出队</p>\n</li>\n<li><p>LinkedList作为双向队列使用</p>\n<p>实现了Deque接口，因此可以作为一个双向队列来使用</p>\n<p>队首入队，队尾出队</p>\n<p>队尾入队，队首出队</p>\n<p>双向队列的方法：</p>\n<p>offerFirst()队首入队</p>\n<p>offerLast()队尾入队</p>\n<p>peekFirst()获取但不移除队首元素</p>\n<p>peekLast()获取但不移除队尾元素</p>\n<p>pollFirst()队首出队</p>\n<p>pollLast()队尾出队</p>\n</li>\n<li><p>LinkedList作为栈使用</p>\n<p>作为栈结构的方法：</p>\n<p>push()入栈，压栈</p>\n<p>pop()出栈，弹栈</p>\n</li>\n</ol>\n</li>\n<li><p>ArrayList和LinkedLisst有什么区别</p>\n<ol>\n<li>都是实现了List接口，因此都能保证元素的添加顺序以及可以添加重复元素</li>\n<li>ArrayList底层实现为数组，因此查找和修改比较快，可以直接通过下标一次定位元素，但是删除和插入元素比较慢，因为需要复制和移动元素</li>\n<li>linkedList底层实现为双向链表因为查找和修改元素比较慢，需要从头结点开始向后逐个遍历或从尾结点开始向前逐个遍历，但是删除和插入元素比较快，只需要修改指针的指向即可，不需要移动元素</li>\n</ol>\n</li>\n</ol>\n<p>五、集合操作工具</p>\n<ol>\n<li><p>Iterator</p>\n<p>迭代器，主要用于对Collection集合中的元素进行迭代遍历</p>\n<ol>\n<li>iterator()：将Collection集合中元素放入到迭代器中，该方法必须由Collection接口的实现类来进行调用</li>\n<li>hasNext():判断是否有下一个元素</li>\n<li>next():将指针移动到下一行，并取当前元素</li>\n<li>remove():通过迭代器删除集合中的元素</li>\n</ol>\n<blockquote>\n<p>注意：当集合中元素正在迭代器中进行迭代时，不能通过集合来进行插入或删除元素，否则会发送并发修改异常（快速失败）</p>\n</blockquote>\n</li>\n<li><p>Comparable</p>\n<p>可比较的接口，用于比较两个引用类型对象之间的大小</p>\n<p>使用方式;</p>\n<ol>\n<li>类型实现Comparable可比较接口</li>\n<li>在类中重写compareTo()方法，在方法中制定比较规则</li>\n<li>类中对象调用compareTo()方法，就可以比较大小了</li>\n</ol>\n</li>\n<li><p>Collections</p>\n<p>主要用于对Collection集合中的元素进行各种操作</p>\n<p>主要方法：</p>\n<ol>\n<li>addAll():一次性向集合中添加多个元素</li>\n<li>reverse():翻转集合中元素</li>\n<li>shuffle():洗牌，打乱集合中的元素</li>\n<li>sort(List<T> list):对集合中的元素进行排序，要求集合中的元素必须实现Comparable可比较接口，然后按照重写compareTo()规则来对集合元素排序</li>\n<li>sort(List<T> list,Comparator&lt;? super T&gt; c):对集合中元素按照Comparator比较器制定的规则来进行排序，如果集合中元素类型既实现了Comparable可比较接口，又外接了Comparator比较器，那么以Comparator比较器为准</li>\n</ol>\n</li>\n</ol>\n<p>六、Map集合</p>\n<p>​\t主要用于key-value键值对格式的元素，其中key不能重复，如果key值相同，value值将会覆盖，不能保证元素的添加顺序，其主要实现类为：HashMap和TreeMap</p>\n<ol>\n<li><p>HashMap</p>\n<ol>\n<li>key相同value覆盖</li>\n<li>不能保证添加顺序</li>\n<li>允许key或value为null</li>\n</ol>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;K,V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>主要方法</p>\n<ol>\n<li>put(K,V)：添加数据</li>\n<li>get(K)：根据key获取value值</li>\n<li>size()：获取集合长度</li>\n<li>containsKey(K)：判断是否包含指定key值</li>\n<li>containsValue(V)：判断是否包含指定value值</li>\n<li>remove(K)：根据key值移除键值对</li>\n<li>clear()：清空集合中元素</li>\n<li>isEmpty()：判断集合是否为空</li>\n</ol>\n</li>\n<li><p>Map集合的三种遍历方式</p>\n<ol>\n<li><p>遍历所有的key</p>\n<p>Set<K> set &#x3D; map.keySet();</p>\n</li>\n<li><p>遍历所有的value</p>\n<p>Collection<V> value &#x3D; map.values();</p>\n</li>\n<li><p>遍历所有的Entry对象</p>\n<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entries &#x3D; map.entrySet();</p>\n</li>\n</ol>\n</li>\n<li><p>HashMap底层实现原理</p>\n<p>HashMap底层实现为哈希表(散列表)</p>\n<p>Java中哈希表的实现方案:</p>\n<ol>\n<li><p>JDK&lt;&#x3D;1.7:哈希表&#x3D;数组+单向链表</p>\n</li>\n<li><p>JDK&gt;&#x3D;1.8:哈希表&#x3D;数组+单向链表+红黑树3</p>\n</li>\n<li><p>数组：当使用无参构造创建HashMap对象时，默认初始化加载因子为0.75，当第一次调用put()方法向集合中添加元素时，会初始化一个16个长度的数组，当数组容量达到数组长度*加载因子时(第一次16*0.75),数组就会进行扩容，每次扩容之前长度的2倍，然后将之前数组中的所有元素取出来，重新计算下标值，再往新的数组中存储一次</p>\n</li>\n<li><p>哈希表存数据具体过程</p>\n<ol>\n<li><p>根据key计算一个哈希值，然后再根据哈希值计算一个下标值</p>\n</li>\n<li><p>如果该下标位置没有任何结点，直接存储</p>\n</li>\n<li><p>该下标位置存在结点，进行比较，equals()返回true这是重复结点，就覆盖此结点返回false，以单向链表方式挂在该结点下</p>\n</li>\n<li><p>如果该链表结点超过8个并且数组长度超过64个单向链表将换成红黑树</p>\n</li>\n<li><p>如果链表结点超过8个，数组长度没有超过64，数组将进行翻倍扩容</p>\n</li>\n<li><p>单向链表插入方式：</p>\n<p>JDK&lt;&#x3D;1.7：头插法</p>\n<p>JDK&gt;&#x3D;1.8:尾插法（避免多线程死链）</p>\n</li>\n<li><p>当红黑树上的结点少于6个时，红黑树将转换成单向链表</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>红黑树</p>\n<ol>\n<li><p>为什么使用红黑树</p>\n<p>当往二叉排序树中插入数据时，如果后面的数据一直比前面的数据小或比前面的数据大，那么二叉树就会坍塌成一个单向链表，失去平衡，查找效率下降，所以需要红黑树来保证二叉排序树插入数据时的平衡性，红黑树是一种能够实现自平衡的二叉排序树</p>\n</li>\n<li><p>红黑树的特点</p>\n<ol>\n<li>每个节点红色或者黑色，新节点默认红色</li>\n<li>根节点必须是黑色</li>\n<li>每个红色的节点的两个子节点必须是黑色节点</li>\n<li>每个叶子节点必须是黑色的空节点</li>\n<li>任一节点要每个叶子节点包含相同数量的黑色节点</li>\n</ol>\n</li>\n<li><p>红黑树如何实现自平衡</p>\n<ol>\n<li>旋转</li>\n<li>变色</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Hashtable</p>\n<p>HashMap和Hashtable的区别</p>\n<ol>\n<li>HashMap和Hashtable都是Map接口的实现类，底层实现都是哈希表，其主要方法也相同</li>\n<li>HashMap底层的哈希表为数组+单向链表+红黑树，Hashtable底层的哈希表为数组+单向链表</li>\n<li>Hashtable线程安全，HashMap线程不安全</li>\n</ol>\n</li>\n<li><p>TreeMap</p>\n<ol>\n<li><p>底层实现</p>\n<p>TreeMap底层实现为红黑树，要求存储到集合中的key值必须能够比较大小，所以要求key值不能为null，key值要实现Comparable可比较接口或者在创建TreeMap对象时外接Comparator比较器，因此，TreeMap可以实现对Key值的排序，如果经过Comparable或Comparator比较两个key值的大小相等，那么value将会覆盖</p>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造</p>\n<blockquote>\n<p>TreeMap&lt;K,V&gt; map &#x3D; new TreeMap&lt;&gt;();</p>\n<p>要求key必须实现Comparable可比较接口</p>\n</blockquote>\n</li>\n<li><p>外接Comparator比较器</p>\n<blockquote>\n<p>TreeMap&lt;K,V&gt; map &#x3D; new TreeMap&lt;&gt;(Comparator cmp)；</p>\n<p>以Comparator比较器制定的规则来对key值进行排序，此时key可以不用实现Comparable可比较接口</p>\n</blockquote>\n</li>\n<li><p>主要方法</p>\n<p>与hashMap相同</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>七、Set集合</p>\n<ol>\n<li><p>Set集合概念</p>\n<p>Set是继承自Collection的子接口，里面只能用于存储单个元素，存储在该集合中的元素是不允许重复的，而且也不能保证元素的添加顺序</p>\n<p>其主要的实现类：HashSet,TreeSet</p>\n</li>\n<li><p>HashSet</p>\n<ol>\n<li><p>底层实现原理</p>\n<p>HashSet底层是通过HashMap来进行数据存储，倍添加的数据会被当做是Key值，而value值是一个无意义的Object对象，最终将数据存储到哈希表中，所以要求Key必须重写HashCode（）和equals（）两个方法，相比较测认为是重复元素，那么后面元素就不存储了</p>\n</li>\n<li><p>对象创建</p>\n<p>HashSet<E> set &#x3D; new HashSet&lt;&gt;();</p>\n</li>\n<li><p>主要方法</p>\n<p>参考ArrayList，没有根据下标取值的方法</p>\n</li>\n</ol>\n</li>\n<li><p>TreeSet</p>\n<ol>\n<li><p>底层实现原理</p>\n<p>TreeSet底层是通过TreeMap来进行数据存储，被添加的数据会被当做Key值，而value值一个无意义的Object对象，添加的元素之间能够进行比较</p>\n</li>\n<li><p>对象创建</p>\n<ol>\n<li><p>无参构造方法</p>\n<p>TreeSet<E> set &#x3D;new TreeSet&lt;&gt;();</p>\n<p>要求被添加的元素必须实现Comparable可比较接口，按照重写的规则对元素数据进行排序</p>\n</li>\n<li><p>外接Comparator比较器</p>\n<p>TreeSet<E> map &#x3D; new TreeSet&lt;&gt;(Comparator cmp);</p>\n<p>以Comparator比较器制定的规则来对元素进行排序，此时被添加的元素可以不用实现Comparable可比较接口</p>\n</li>\n<li><p>主要方法</p>\n<p>参考ArrayList，没有更具下标取值的方法</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>八、Stream流式操作</p>\n<ol>\n<li><p>什么是Stream流式操作</p>\n<p>将集合或数组中的元素当做是一种流，然后借助StreamApi以及lambda表达式对流中的数据来进行各种操作</p>\n</li>\n<li><p>Stream流的使用步骤</p>\n<ol>\n<li><p>获取流对象</p>\n<ol>\n<li>单列集合：借助Collection接口中的stream默认方法</li>\n<li>双列集合：需要将其转成单列集合，第一种获取所有key，第二种获取所有value，第三种获取所有entry对象</li>\n<li>数组：借助Arrays工具类的Stream（）静态方法</li>\n<li>一堆零散数据：借助Stream类的of（）静态方法</li>\n</ol>\n</li>\n<li><p>借助Stream流中方法来对数据进行操作</p>\n<ol>\n<li><p>中间操作</p>\n<p>可以连续操作多次</p>\n<p>filter（）：过滤</p>\n<p>limit（）：获取前几个元素</p>\n<p>skip（）：跳过前几个元素</p>\n<p>distinct（）：去重</p>\n<p>concat（）：合并两个流为一个流</p>\n<p>map（）：转换流中数据类型</p>\n</li>\n<li><p>最终操作</p>\n<p>每个流只能进行一次操作，也就是最终操作方法调用万科后不能去调用其他方法了</p>\n<p>forEach（）：迭代遍历</p>\n<p>count（）：统计</p>\n<p>toArray()：将剩下的数据存储到数组中</p>\n<p>collect（）：将流中剩下的数据存储到集合中</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"线程Thread","date":"2023-01-15T03:18:57.000Z","cover":"/img/images/computer4.jpg","_content":"\n# 线程Thread\n\n### 一、什么是进程\n\n​\t进程（Process）：操作系统上一个正在运行中的程序，进程会拥有当前程序的所有资源\n\n​\t线程（Thread）：进程内部的一个执行功能单元，每个线程都会有自己独立的一块内存空间，一个进程内部会有一到多个线程组成，进程只是拥有程序的资源，而线程是负责获取资源来执行具体任务的，进程内部的资源会被当前进程内所有线程共享\n\n### 二、多线程的执行方式\n\n##### **并发（concurrent）**\n\n​\t多线程默认是并发执行\n\n​\t操作系统会将时间片划分为很多个时间点，在每个时间点上只允许一个线程获取CPU，并进入CPU中执行他的任务，执行一段时间后就退出CPU，下一个线程再获得CPU进入执行，依次类推，因此为时间被划分足够细，切换足够快所以从宏观上看是多个线程同时进行，而微观上看轮流切换执行，这种现象叫并发，并发并不是真正意义上的同时\n\n##### 并行(parlen)\n\n​\t并行只会出现多核CPU，一个CPU再一个时间段内只能干一件事，但是多个CPU就可以再 一个时间段内干多件事，这个就是真正意义上的同时\n\n##### 多线程并发的优点\n\n​\t优点：提升系统性能和工作效率\n\n​\t缺点：多线程对同一资源进行操作时，可能会发生并发问题导致数据不安全，可以通过加锁解决\n\n### 三、线程的创建方式\n\n##### 继承\n\n​\t继承Thread类\n\n\t1. 写一个线程类继承Thread类\n\t2. 重写run（）方法，代表线程所要执行的具体任务是什么\n\t3. 创建线程实例\n\t4. 调用start（）方法启动线程\n\n##### 实现Runnable接口\n\n\t1. 写一个任务类实现Runnable接口，该类实例代表线程所要执行的任务对象\n\t2. 重写run（）方法，代表执行的具体任务是什么\n\t3. 创建任务实例\n\t4. 创建一个线程实例，将任务实例作为参数传给线程实例\n\t5. 调用start（）方法启动线程\n\n> 推介使用：实现Runnable接口方式创建线程\n>\n> 1. 解决Java中单继承带来的弊端\n> 2. 可以让多个线程来执行同一个任务\n> 3. 将线程实例和任务实例解耦合\n\n> 注意：线程调用了start（)方法后，不会立即获得CPU，而是处于一个就绪（准备）状态，等待操作系统为其分配时间片，线程只有获得了时间片才会进入CPU中执行他的任务，也就是执行run（）方法中的代码\n\n### 四、线程的主要方法\n\n1. run()\n\n   线程获得CPU之后，执行的任务\n\n2. start()\n\n   启动线程，让线程处于就绪状态\n\n3. Thread static currentThread()\n\n   获取当前线程实例\n\n4. void setName(String name)/String getName()\n\n   获取/修改线程名称，线程默认名称：主线程：main，其他工作线程：Thread-0/Thread-1\n\n5. long getId()\n\n   获取线程Id,主线程id：1，其他工作线程，10，11，12....\n\n6. static int activeCount()\n\n   获取当前线程所属线程组中活动的线程数\n\n7. void setPriority(int priority)/getProiority()\n\n   获取/修改线程的优先级\n\n   线程默认优先级：5，最高优先级：10，最低优先级：1\n\n   > 优先级是改善线程获取CPU的概率\n\n8. setDaemon(True)\n\n   将线程设置后守护线程(后台线程，用户线程，精灵线程)那么其他的线程就会自动变为前台线程，一个进程最多只允许一个守护线程当其他所有前台线程都结束了，守护线程也就结束了必须要再启动线程之前设置\n\n9. Thread.sleep(long millis)\n\n   线程休眠,处于运行状态的线程如果调用了sleep()休眠方式，就会立即退出CPU,处于阻塞状态，在此期间线程是无法再次获得CPU的，休眠结束线程又重写回到就绪状态，等待操作系统重新为其分配时间片，处于休眠状态的线程可以再别的线程中通过调用interrupt（）方法进行唤醒\n   \n10. void join（）\n\n   插入式线程\n\n   将一个线程插入到另外一个线程前面去执行，被插入的线程就会处于阻塞状态，在此期间式无法获得CPU的，必须等待插入的线程在CPU中彻底执行完成任务退出CPU之后，被插入的线程才会结束阻塞状态进入就绪状态\n\n### 五、线程的状态(生命周期)\n\n1. 新建状态\n\n   线程实例刚被创建出来\n\n2. 就绪状态\n\n   等待操作系统为其分配时间片\n\n   1. 新建状态的线程调用start()方法\n   2. 阻塞状态的线程阻塞结束\n\n3. 运行状态\n\n   就绪状态获得了操作系统为其分配的时间片，进入CPU中执行他的任务，也就是调用run（）方法\n\n4. 阻塞状态\n\n   运行状态的线程退出CPU处于等待状态，在阻塞期间是无法获得CPU的\n\n   1. 线程休眠\n   2. 线程被插入\n   3. 线程wait()/await()等待\n   4. IO阻塞\n\n5. 死亡状态\n\n   线程执行完了他的任务，就会被操作系统回收\n\n### 六、线程同步与协作\n\n1. 异步和同步的概念\n\n   **异步**：一个进程内部的多个线程之间默认是异步并发执行的，轮流切换时间片来执行任务，宏观上看同时在进行\n\n   **同步**：因为多线程默认是异步并发执行的，所以如果有多个线程对同一资源(共享变量)进行操作时，就有可能会引发线程并发不安全问题，所以这时候就需要多线程，有先后顺序的来执行，这个就叫线程同步（串发）\n\n2. 如何将线程默认的异步操作改为同步操作\n\n   Java中提供了一种锁机制来支持多线程同步，保证共享资源的安全性\n\n   1. Synchronized同步锁\n      1. 同步代码块\n      \n         若干个线程过来之后，只会有一个线程先获得同步锁对象，然后进入同步代码块中执行代码，同时将这一块代码锁死在该线程执行期间，其他线程均处于阻塞状态，无法获得CPU，只要等当前线程执行完了同步代码块中所有代码之后，才会释放同步锁，其他处于阻塞状态的状态进入到就绪状态从而来枪已经释放的同步锁，进入同步代码块中执行任务，未抢到的锁的线程依然处于阻塞状态，依次类推，多线程就可以按顺序先后执行\n      \n         ```java\n         synchronized(同步锁对象){\n         \t//需要进行同步的代码\n         }\n         ```\n      \n      2. 同步方法\n      \n         多线程在调用这个方法时，只有一个线程会先获得同步锁对象，获得同步锁的线程会先来调用该方法，在调用期间其他线程也是处于阻塞状态，等该线程调用完方法释放同步锁后，其他线程才能获得同步锁来调用方法\n      \n         ```java\n         修饰符 synchronized 返回值类型 方法名(参数列表){\n         \t//需要进行同步的代码\n         }\n         ```\n      \n      3. 同步锁对象的选择\n      \n         任意引用类型对象都可以来当做同步锁，但是必须保证多个线程看到的是同一个锁对象\n      \n         实例方法同步锁对象默认为this\n      \n         静态方法同步锁对象默认为当前类(类名.class)\n         \n      4. synchronized的可重入性\n      \n         可重入锁，也叫递归锁\n      \n         如果一个线程在外部已经获得改锁，那么进入到线程内部的后可以继续获得该锁，而不会因为之前的锁没有释放无法获得这把锁，可重入锁可以在一定程度上避免线程死锁\n      \n   2. ReentrantLock可重入锁\n   \n      1. ReentrantLock实现线程重入锁实现线程同步\n      \n         1. lock（)获得锁，获取不到会阻塞\n         2. unlock()释放锁\n         3. trylock()尝试获得锁，获得True，未获得False,不会阻塞\n         4. lockInterruptibly（）获得锁，获取不到会阻塞，但是阻塞会被打断\n      \n         ```java\n         为了确保无论如何都会被释放：\n         try{\n         \t//获得锁\n         \t//需要进行同步的代码\n         }finally{\n         \t//释放锁\n         }\n         ```\n      \n      2. ReentrantLock实现锁的可重入性\n      \n         synchronized锁和ReentrantLock锁都是可重入锁\n      \n      3. ReentrantLock获得锁的过程\n      \n         1. 当多个线程来获得同一个锁对象时，只有一个线程能获得锁对象，其他未获得所得线程会被添加到等待队列中，先就绪的线程就会被添加到列的头部，等上一个获得锁的线程执行完成任务释放锁之后，就会从队列的取出，一个线程再来获取锁\n      \n            > 注意：线程只有调用Starrt()方法会处于就绪状态，但是先调用start（）方法的线程不一定就会先就绪\n      \n            **非公平锁**：创建对象不带参数或参数为false，创建的就是非公平锁，持有锁的线程再执行完任务释放的一瞬间，如果有非队列中的线程过来获取锁，那么该线程就能立即获得锁，所以如果一直非队列线程过来获得锁，就会造成队列中的线程一直处于等待状态（饥饿等待），但是非公平锁效率高，因为不需要频繁的往等待的队列中添加和取出线程\n      \n            **公平锁**：创建对象时带的参数为true，则代表创建的时公平锁，严格按照FIFO先进先出原则，从队列中依次取出线程来获得锁执行任务，即使再持有锁的线程执行完任务释放锁的一瞬间，有非队列线程过来也依然会被加入到队列的末尾中，不会造成饥饿等待，效率比较低，因为需要频繁的往队列添加和取出线程\n      \n      4. 读写锁\n      \n         多线程在对同一资源进行操作时，可以使用读写锁\n      \n         1. 读锁和读锁之间是线程共享的\n         2. 写锁和写锁之间是线程互斥的\n         3. 读锁和写锁之间是线程互斥的\n   \n3. 线程间协作(等待)的概念\n\n   1. 多线程在同步了的基础上，必须按照一个排好的顺序来获取CPU执行任务\n\n   2. 怎样实现线程间协作\n\n      1. 使用synchronized同步锁，可以借助Object类中wait()/notify()/notifyAll()三个方法来实现线程间协作\n\n      2. wait()\n\n         调用该方法的线程会释放已经获得的锁然后进入等待状态，一直等到其他具备相同锁的线程调用notify()或notifyAll()方法后才会结束等待进入就绪状态\n\n      3. notify()\n\n         调用该方法的线程会通知其他具备相同锁的线程结束等待，从而进入就绪状态，等到执行完同步代码块后才会释放同步锁，notify()方法本身是不会释放同步锁的，该方法一般写同步代码块最后面\n\n      4. 使用ReentrantLock可重入锁实现线程间协作\n\n         通过ReentrantLock来获取一个Condition对象，然后借助Condition对象中的await()/signal()/signalAll()三个方法\n\n      > 注意：\n      >\n      > 1. 以上三个方法必须在lock()和unlock()两个方法之间\n      > 2. 方法必须有condition对象来进行调用\n      > 3. 多线程间的condition对象必须是同一个\n\n### 七、线程池\n\n​\t线程池(ThreadPool线程的第三种创建方式)\n\n1. **线程池的概念**\n\n   用于创建和管理多个线程的容器对象，当我们的程序需要线程时可以直接从池中取出，当执行完任务后，将线程返回到池中，让线程得到复用，避免频繁的创建和销毁，从而节省系统的开销\n\n2. **线程池的创建**\n\n   ```java\n   ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                   int corePoolSize   核心线程数,\n                   int maximumPoolSize 最大线程数,\n                   long keepAliveTime 超时(空闲，活跃)时间,\n                   TimeUnit unit 时间单位,\n                   BlockingQueue<Runnable> workQueue 任务队列,\n                   ThreadFactory threadFactory 线程工厂,\n       \t\t\tRejectedExecutionHandler handler 拒绝执行处理;\n   )\n   ```\n\n3. **拒绝策略**\n\n   1、**AbortPolicy**\n      拒绝执行新的任务，并抛出RejectedExecutionException异常\n   2、**CallerRunPolicy**\n      如果线程池已关闭，直接丢弃该任务，\n      如果线程池没有关闭，不会使用线程池中的线程，\n      也不会将其加入到任务队列中，而是让当前线程直接来调用run()方法，\n      相当于没有创建额外的线程\n   3、**DiscardOldestPolicy**\n      如果线程池已关闭，直接丢掉该任务\n      入宫线程没有关闭，将任务队列存在最久的任务丢掉，\n      并将新的任务加入到任务队列中\n   4、**DiscardPolicy**\n      直接丢掉新的任务，但是不会抛出异常\n\n4. Java**自带的线程池**\n\n   1. 创建单线程的线程池\n\n      只有一个线程，不允许创建非核心线程      \n\n      ```java\n      ExecutorService es = Executors.newSingleThreadExecutor();\n      ```\n\n   2. 创建固定数量线程的线程池\n\n      传入的参数既是核心线程数也是最大线程数，不允许创建非核心线程\n\n      ```java\n      ExecutorService es = Executors.newFixedThreadPool(3);\n      ```\n\n   3. 创建可缓存线程池\n\n      内部没有核心线程，所有的线程都是非核心线程\n      所有的非核心线程都是超过60s处于空闲状态就会被回收\n\n      ```java\n      ExecutorService es = Executors.newCachedThreadPool();\n      ```\n\n   4. 创建周期性线程池\n\n      传入的参数为核心线程数，队列为延迟队列\n\n      ```java\n      ScheduledExecutorService es =Executors.newScheduledThreadPool(3);\n      ```\n\n      线程池主要方法\n\n      1. **execute**(Ruunable task)\n\n         将任务交给线程池来执行\n\n         线程池会自动获取出空闲的线程来执行该任务\n\n      2. **allowCoreThreadTimeOut**()\n\n         允许核心线程超时\n\n      3. **es.shutdownNow**();\n\n         立即关闭，可能会导致线程池中还没有执行完毕\n\n      4. **es.shutdown**();\n\n         安全关闭，必须等待线程池中所有线程都执行完成任务后才会关闭\n\n      5. **es.schedule**(Runnable command,long delay, TimeUnit unit);\n\n         周期性线程池执行周期任务\n\n      6. **es.scheduleAtFixedRate**\n\n         Runnable command, 要执行的任务\n         long initialDelay, 第一次执行任务的延迟时间\n         long period, 两次执行之间的间隔时间\n         TimeUnit unit 时间单位\n         任务的执行时间超过了间隔时间，那么在一次任务，执行完成后就会立即执行下一次任务如果没有超过间隔时间那么就会在指定间隔之后才会执行下一个任务\n\n      7. **es.scheduleWithFixedDelay**\n\n         不管任务的执行时间是否超过间隔时间,必须等待本次任务执行完成后,再间隔指定时间才会去执行下一次的任务\n      \n   5. **Callable**\n   \n      实现Callable接口的实现类为线程要执行的任务\n   \n      Callable使用步骤\n   \n      1. 写一个类实现Callable接口，并指定泛型，泛型为任务执行完成后需要得到的结果类型\n      2. 重写Call()方法，该方法所要执行的任务，相当于是Runnable中的run()方法\n      3. 通过线程来执行任务\n         1. 创建Callable实现实例，并通过FutureTask来封装该实例\n         2. 创建线程来执行FutureTask来执行实例\n         3. 调用FutureTask的get()方法 来获取任务执行结果\n      4. 通过线程池来执行任务\n         1. 创建Callable实现实例，创建线程池\n         2. 调用线程池的submit()方法执行Callable任务实例，返回一个Future()\n         3. 调用Future类的get()方法来获取任务执行结果\n\n### 八、线程内存模型\n\n##### JMM:Java Memory Model\n\n主要用于描述和定义Java程序中各种变量的访问和操作规则，以及在JVM中如何将变量存储到内存以及从内存读出的过程\n\n1. 多线程访问共享变量的规则\n   1. JVM会给每个线程更配一个自己独立的内存空间，同时也会有一个自己的主内存空间\n   2. 多线程间的共享变量会存在主内存空间\n   \n2. 线程的特性\n   1. 原子性\n   2. 可见性\n   \n   JMM:Java Memory Model\n         主要用于描述和定义Java程序中各种变量的访问和操作规则,\n         以及在Jvm中如何将变量存储到内存以及从内存读出的过程\n   \n         1、多线程访问共享变量的规则\n            1>Jvm会给每个线程分配一个自己独立的内存空间,\n              同时也会有一个自己的主内存空间\n            2>多线程间的共享变量会存储在主内存空间\n            3>线程对共享变量的操作,需要从\n              主内存中拷贝一份该变量的副本到自己独立的工作\n              内存中进行,修改完成后将该变量的值再重新拷贝到主内存中,\n              线程不能直接操作主内存的共享变量值\n            4>不同线程之间无法直接访问其他线程工作内存中的变量,\n              线程间变量值的传递必须通过主内存来进行完成\n   \n   \n   ​     \n   ​       2、线程的特性:\n   ​           1>原子性(不可分割)\n   ​             一系列的操作要么都执行,要么都不执行,不可再分割,\n   ​             比如从主内存中读取共享变量的值,在工作内存中修改后,\n   ​             再刷新回主内存,这些操作不可分割,\n   ​             线程与线程之间相互独立,在一个时间段内\n   ​    只允许一个线程进入cpu执行任务操作共享变量,\n   ​    synchronized同步锁和ReentrantLock可重入锁\n   ​    都可以实现线程原子性\n   ​    \n   ​           2>可见性\n   ​             1)一个线程对共享变量的操作,能够及时的被其他线程所看到\n   ​             2)可见性实现原理\n   ​                1)每次操作该变量时都会将主内存中\n   ​      共享变量拷贝到工作内存\n   ​    2)每次在工作内存中操作完该变量时,\n   ​      都会把值同步到主内存中\n   ​       3)Synchronized,ReentrantLock以及\n   ​      volatile都可以实现线程可见性\n   ​    \n   ​             3)synchronize实现可见性原理\n   ​                1>获取同步锁\n   ​                2>清空工作内存中的副本值\n   ​                3>从主内中拷贝共享变量的最新值到自己的工作内存中\n   ​                4>在工作内存中执行代码\n   ​                5>将更改之后共享变量的值刷新到主内存\n   ​                6>释放同步锁\n   ​                7>synchronized既能保证原子性也能保证可见性\n   ​    \n   ​             4)volatile实现可见性原理\n   ​                volatile只能保证共享变量的可见性,但不能保证原子性\n   ​                当线程需要去修改volatile变量值:\n   ​                1>先从主内存中读取volatile共享变量的最新值到工作内存\n   ​                2>再操作工作内存volatile变量的副本值\n   ​                3>再将改变之后的副本值从工作内存刷新到主内存\n   ​    \n   ​                 volatile使用场景:线程多次修改的共享值之间不存在依赖关系\n   ​    \n   ​              5)synchronized和volatile区别\n   ​                1>volatile不需要加锁,比synchronized更加轻量级,\n   ​                  不会阻塞线程\n   ​                2>synchronized既保证可见性又保证原子性,\n   ​                  而volatile只保证了可见性,不保证原子性\n   ​                3>synchronized比validate使用场景更多,范围更广\n   ​    \n              3>有序性(非指令重排性):让JVM在解释执行字节码文件时,\n          严格按照字节码中的顺序来执行指令,不要进行重排序\n   \n   \n     4、指令重排序\n      1>重排序概念\n        代码的编写顺序和最终执行顺序不一致\n        \n      2>重排序目的\n        编译器或处理器做优化,提高程序的执行性能,哪个指令先来,\n        先执行哪个\n   \n      2.1>编译器优化重排序\n        2.2>处理器指令级并行重排序或内存系统的重排序\n            源代\n   \n   2.1>编译器优化重排序\n        2.2>处理器指令级并行重排序或内存系统的重排序\n            源代码 -> 编译器优化的重排 -> \n         指令并行的重排 -> 内存系统的重排 -> 最终执行指令\n   \n      3>重排序导致后果\n        3.1>单线程重排序会遵循as-if-serial原则,\n          也就是会考虑数据依赖问题,\n          无论如何重排序,程序最终执行结果必须\n          与代码顺序执行结果一致\n   \n      3.2>多线程并发情况下,指令重排序可能会导致\n           最终结果与预期结果不一致\n   \n      3.3>synchronized和volatile都能禁止指令重排序\n          volatile:通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化,\n          volatile的写和读的时候，加入屏障，防止出现指令重排的\n        \n        线程A:\n        int a = 10;\n        int b = 20;\n        \n        线程B:\n        int c = a+b;\n          \n        Object obj = new Object();\n        创建对象过程\n        1>初始化一块内存空间\n        2>给成员变量赋初始值\n        3>将内存空间地址赋值给引用\n       \n        if(obj!=null){\n           //执行代码 \n        }\n\n","source":"_posts/线程.md","raw":"---\ntitle: 线程Thread\ndate: 2023-01-15 11:18:57\ntags: Java\ncategories: Java\ncover: /img/images/computer4.jpg\n---\n\n# 线程Thread\n\n### 一、什么是进程\n\n​\t进程（Process）：操作系统上一个正在运行中的程序，进程会拥有当前程序的所有资源\n\n​\t线程（Thread）：进程内部的一个执行功能单元，每个线程都会有自己独立的一块内存空间，一个进程内部会有一到多个线程组成，进程只是拥有程序的资源，而线程是负责获取资源来执行具体任务的，进程内部的资源会被当前进程内所有线程共享\n\n### 二、多线程的执行方式\n\n##### **并发（concurrent）**\n\n​\t多线程默认是并发执行\n\n​\t操作系统会将时间片划分为很多个时间点，在每个时间点上只允许一个线程获取CPU，并进入CPU中执行他的任务，执行一段时间后就退出CPU，下一个线程再获得CPU进入执行，依次类推，因此为时间被划分足够细，切换足够快所以从宏观上看是多个线程同时进行，而微观上看轮流切换执行，这种现象叫并发，并发并不是真正意义上的同时\n\n##### 并行(parlen)\n\n​\t并行只会出现多核CPU，一个CPU再一个时间段内只能干一件事，但是多个CPU就可以再 一个时间段内干多件事，这个就是真正意义上的同时\n\n##### 多线程并发的优点\n\n​\t优点：提升系统性能和工作效率\n\n​\t缺点：多线程对同一资源进行操作时，可能会发生并发问题导致数据不安全，可以通过加锁解决\n\n### 三、线程的创建方式\n\n##### 继承\n\n​\t继承Thread类\n\n\t1. 写一个线程类继承Thread类\n\t2. 重写run（）方法，代表线程所要执行的具体任务是什么\n\t3. 创建线程实例\n\t4. 调用start（）方法启动线程\n\n##### 实现Runnable接口\n\n\t1. 写一个任务类实现Runnable接口，该类实例代表线程所要执行的任务对象\n\t2. 重写run（）方法，代表执行的具体任务是什么\n\t3. 创建任务实例\n\t4. 创建一个线程实例，将任务实例作为参数传给线程实例\n\t5. 调用start（）方法启动线程\n\n> 推介使用：实现Runnable接口方式创建线程\n>\n> 1. 解决Java中单继承带来的弊端\n> 2. 可以让多个线程来执行同一个任务\n> 3. 将线程实例和任务实例解耦合\n\n> 注意：线程调用了start（)方法后，不会立即获得CPU，而是处于一个就绪（准备）状态，等待操作系统为其分配时间片，线程只有获得了时间片才会进入CPU中执行他的任务，也就是执行run（）方法中的代码\n\n### 四、线程的主要方法\n\n1. run()\n\n   线程获得CPU之后，执行的任务\n\n2. start()\n\n   启动线程，让线程处于就绪状态\n\n3. Thread static currentThread()\n\n   获取当前线程实例\n\n4. void setName(String name)/String getName()\n\n   获取/修改线程名称，线程默认名称：主线程：main，其他工作线程：Thread-0/Thread-1\n\n5. long getId()\n\n   获取线程Id,主线程id：1，其他工作线程，10，11，12....\n\n6. static int activeCount()\n\n   获取当前线程所属线程组中活动的线程数\n\n7. void setPriority(int priority)/getProiority()\n\n   获取/修改线程的优先级\n\n   线程默认优先级：5，最高优先级：10，最低优先级：1\n\n   > 优先级是改善线程获取CPU的概率\n\n8. setDaemon(True)\n\n   将线程设置后守护线程(后台线程，用户线程，精灵线程)那么其他的线程就会自动变为前台线程，一个进程最多只允许一个守护线程当其他所有前台线程都结束了，守护线程也就结束了必须要再启动线程之前设置\n\n9. Thread.sleep(long millis)\n\n   线程休眠,处于运行状态的线程如果调用了sleep()休眠方式，就会立即退出CPU,处于阻塞状态，在此期间线程是无法再次获得CPU的，休眠结束线程又重写回到就绪状态，等待操作系统重新为其分配时间片，处于休眠状态的线程可以再别的线程中通过调用interrupt（）方法进行唤醒\n   \n10. void join（）\n\n   插入式线程\n\n   将一个线程插入到另外一个线程前面去执行，被插入的线程就会处于阻塞状态，在此期间式无法获得CPU的，必须等待插入的线程在CPU中彻底执行完成任务退出CPU之后，被插入的线程才会结束阻塞状态进入就绪状态\n\n### 五、线程的状态(生命周期)\n\n1. 新建状态\n\n   线程实例刚被创建出来\n\n2. 就绪状态\n\n   等待操作系统为其分配时间片\n\n   1. 新建状态的线程调用start()方法\n   2. 阻塞状态的线程阻塞结束\n\n3. 运行状态\n\n   就绪状态获得了操作系统为其分配的时间片，进入CPU中执行他的任务，也就是调用run（）方法\n\n4. 阻塞状态\n\n   运行状态的线程退出CPU处于等待状态，在阻塞期间是无法获得CPU的\n\n   1. 线程休眠\n   2. 线程被插入\n   3. 线程wait()/await()等待\n   4. IO阻塞\n\n5. 死亡状态\n\n   线程执行完了他的任务，就会被操作系统回收\n\n### 六、线程同步与协作\n\n1. 异步和同步的概念\n\n   **异步**：一个进程内部的多个线程之间默认是异步并发执行的，轮流切换时间片来执行任务，宏观上看同时在进行\n\n   **同步**：因为多线程默认是异步并发执行的，所以如果有多个线程对同一资源(共享变量)进行操作时，就有可能会引发线程并发不安全问题，所以这时候就需要多线程，有先后顺序的来执行，这个就叫线程同步（串发）\n\n2. 如何将线程默认的异步操作改为同步操作\n\n   Java中提供了一种锁机制来支持多线程同步，保证共享资源的安全性\n\n   1. Synchronized同步锁\n      1. 同步代码块\n      \n         若干个线程过来之后，只会有一个线程先获得同步锁对象，然后进入同步代码块中执行代码，同时将这一块代码锁死在该线程执行期间，其他线程均处于阻塞状态，无法获得CPU，只要等当前线程执行完了同步代码块中所有代码之后，才会释放同步锁，其他处于阻塞状态的状态进入到就绪状态从而来枪已经释放的同步锁，进入同步代码块中执行任务，未抢到的锁的线程依然处于阻塞状态，依次类推，多线程就可以按顺序先后执行\n      \n         ```java\n         synchronized(同步锁对象){\n         \t//需要进行同步的代码\n         }\n         ```\n      \n      2. 同步方法\n      \n         多线程在调用这个方法时，只有一个线程会先获得同步锁对象，获得同步锁的线程会先来调用该方法，在调用期间其他线程也是处于阻塞状态，等该线程调用完方法释放同步锁后，其他线程才能获得同步锁来调用方法\n      \n         ```java\n         修饰符 synchronized 返回值类型 方法名(参数列表){\n         \t//需要进行同步的代码\n         }\n         ```\n      \n      3. 同步锁对象的选择\n      \n         任意引用类型对象都可以来当做同步锁，但是必须保证多个线程看到的是同一个锁对象\n      \n         实例方法同步锁对象默认为this\n      \n         静态方法同步锁对象默认为当前类(类名.class)\n         \n      4. synchronized的可重入性\n      \n         可重入锁，也叫递归锁\n      \n         如果一个线程在外部已经获得改锁，那么进入到线程内部的后可以继续获得该锁，而不会因为之前的锁没有释放无法获得这把锁，可重入锁可以在一定程度上避免线程死锁\n      \n   2. ReentrantLock可重入锁\n   \n      1. ReentrantLock实现线程重入锁实现线程同步\n      \n         1. lock（)获得锁，获取不到会阻塞\n         2. unlock()释放锁\n         3. trylock()尝试获得锁，获得True，未获得False,不会阻塞\n         4. lockInterruptibly（）获得锁，获取不到会阻塞，但是阻塞会被打断\n      \n         ```java\n         为了确保无论如何都会被释放：\n         try{\n         \t//获得锁\n         \t//需要进行同步的代码\n         }finally{\n         \t//释放锁\n         }\n         ```\n      \n      2. ReentrantLock实现锁的可重入性\n      \n         synchronized锁和ReentrantLock锁都是可重入锁\n      \n      3. ReentrantLock获得锁的过程\n      \n         1. 当多个线程来获得同一个锁对象时，只有一个线程能获得锁对象，其他未获得所得线程会被添加到等待队列中，先就绪的线程就会被添加到列的头部，等上一个获得锁的线程执行完成任务释放锁之后，就会从队列的取出，一个线程再来获取锁\n      \n            > 注意：线程只有调用Starrt()方法会处于就绪状态，但是先调用start（）方法的线程不一定就会先就绪\n      \n            **非公平锁**：创建对象不带参数或参数为false，创建的就是非公平锁，持有锁的线程再执行完任务释放的一瞬间，如果有非队列中的线程过来获取锁，那么该线程就能立即获得锁，所以如果一直非队列线程过来获得锁，就会造成队列中的线程一直处于等待状态（饥饿等待），但是非公平锁效率高，因为不需要频繁的往等待的队列中添加和取出线程\n      \n            **公平锁**：创建对象时带的参数为true，则代表创建的时公平锁，严格按照FIFO先进先出原则，从队列中依次取出线程来获得锁执行任务，即使再持有锁的线程执行完任务释放锁的一瞬间，有非队列线程过来也依然会被加入到队列的末尾中，不会造成饥饿等待，效率比较低，因为需要频繁的往队列添加和取出线程\n      \n      4. 读写锁\n      \n         多线程在对同一资源进行操作时，可以使用读写锁\n      \n         1. 读锁和读锁之间是线程共享的\n         2. 写锁和写锁之间是线程互斥的\n         3. 读锁和写锁之间是线程互斥的\n   \n3. 线程间协作(等待)的概念\n\n   1. 多线程在同步了的基础上，必须按照一个排好的顺序来获取CPU执行任务\n\n   2. 怎样实现线程间协作\n\n      1. 使用synchronized同步锁，可以借助Object类中wait()/notify()/notifyAll()三个方法来实现线程间协作\n\n      2. wait()\n\n         调用该方法的线程会释放已经获得的锁然后进入等待状态，一直等到其他具备相同锁的线程调用notify()或notifyAll()方法后才会结束等待进入就绪状态\n\n      3. notify()\n\n         调用该方法的线程会通知其他具备相同锁的线程结束等待，从而进入就绪状态，等到执行完同步代码块后才会释放同步锁，notify()方法本身是不会释放同步锁的，该方法一般写同步代码块最后面\n\n      4. 使用ReentrantLock可重入锁实现线程间协作\n\n         通过ReentrantLock来获取一个Condition对象，然后借助Condition对象中的await()/signal()/signalAll()三个方法\n\n      > 注意：\n      >\n      > 1. 以上三个方法必须在lock()和unlock()两个方法之间\n      > 2. 方法必须有condition对象来进行调用\n      > 3. 多线程间的condition对象必须是同一个\n\n### 七、线程池\n\n​\t线程池(ThreadPool线程的第三种创建方式)\n\n1. **线程池的概念**\n\n   用于创建和管理多个线程的容器对象，当我们的程序需要线程时可以直接从池中取出，当执行完任务后，将线程返回到池中，让线程得到复用，避免频繁的创建和销毁，从而节省系统的开销\n\n2. **线程池的创建**\n\n   ```java\n   ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                   int corePoolSize   核心线程数,\n                   int maximumPoolSize 最大线程数,\n                   long keepAliveTime 超时(空闲，活跃)时间,\n                   TimeUnit unit 时间单位,\n                   BlockingQueue<Runnable> workQueue 任务队列,\n                   ThreadFactory threadFactory 线程工厂,\n       \t\t\tRejectedExecutionHandler handler 拒绝执行处理;\n   )\n   ```\n\n3. **拒绝策略**\n\n   1、**AbortPolicy**\n      拒绝执行新的任务，并抛出RejectedExecutionException异常\n   2、**CallerRunPolicy**\n      如果线程池已关闭，直接丢弃该任务，\n      如果线程池没有关闭，不会使用线程池中的线程，\n      也不会将其加入到任务队列中，而是让当前线程直接来调用run()方法，\n      相当于没有创建额外的线程\n   3、**DiscardOldestPolicy**\n      如果线程池已关闭，直接丢掉该任务\n      入宫线程没有关闭，将任务队列存在最久的任务丢掉，\n      并将新的任务加入到任务队列中\n   4、**DiscardPolicy**\n      直接丢掉新的任务，但是不会抛出异常\n\n4. Java**自带的线程池**\n\n   1. 创建单线程的线程池\n\n      只有一个线程，不允许创建非核心线程      \n\n      ```java\n      ExecutorService es = Executors.newSingleThreadExecutor();\n      ```\n\n   2. 创建固定数量线程的线程池\n\n      传入的参数既是核心线程数也是最大线程数，不允许创建非核心线程\n\n      ```java\n      ExecutorService es = Executors.newFixedThreadPool(3);\n      ```\n\n   3. 创建可缓存线程池\n\n      内部没有核心线程，所有的线程都是非核心线程\n      所有的非核心线程都是超过60s处于空闲状态就会被回收\n\n      ```java\n      ExecutorService es = Executors.newCachedThreadPool();\n      ```\n\n   4. 创建周期性线程池\n\n      传入的参数为核心线程数，队列为延迟队列\n\n      ```java\n      ScheduledExecutorService es =Executors.newScheduledThreadPool(3);\n      ```\n\n      线程池主要方法\n\n      1. **execute**(Ruunable task)\n\n         将任务交给线程池来执行\n\n         线程池会自动获取出空闲的线程来执行该任务\n\n      2. **allowCoreThreadTimeOut**()\n\n         允许核心线程超时\n\n      3. **es.shutdownNow**();\n\n         立即关闭，可能会导致线程池中还没有执行完毕\n\n      4. **es.shutdown**();\n\n         安全关闭，必须等待线程池中所有线程都执行完成任务后才会关闭\n\n      5. **es.schedule**(Runnable command,long delay, TimeUnit unit);\n\n         周期性线程池执行周期任务\n\n      6. **es.scheduleAtFixedRate**\n\n         Runnable command, 要执行的任务\n         long initialDelay, 第一次执行任务的延迟时间\n         long period, 两次执行之间的间隔时间\n         TimeUnit unit 时间单位\n         任务的执行时间超过了间隔时间，那么在一次任务，执行完成后就会立即执行下一次任务如果没有超过间隔时间那么就会在指定间隔之后才会执行下一个任务\n\n      7. **es.scheduleWithFixedDelay**\n\n         不管任务的执行时间是否超过间隔时间,必须等待本次任务执行完成后,再间隔指定时间才会去执行下一次的任务\n      \n   5. **Callable**\n   \n      实现Callable接口的实现类为线程要执行的任务\n   \n      Callable使用步骤\n   \n      1. 写一个类实现Callable接口，并指定泛型，泛型为任务执行完成后需要得到的结果类型\n      2. 重写Call()方法，该方法所要执行的任务，相当于是Runnable中的run()方法\n      3. 通过线程来执行任务\n         1. 创建Callable实现实例，并通过FutureTask来封装该实例\n         2. 创建线程来执行FutureTask来执行实例\n         3. 调用FutureTask的get()方法 来获取任务执行结果\n      4. 通过线程池来执行任务\n         1. 创建Callable实现实例，创建线程池\n         2. 调用线程池的submit()方法执行Callable任务实例，返回一个Future()\n         3. 调用Future类的get()方法来获取任务执行结果\n\n### 八、线程内存模型\n\n##### JMM:Java Memory Model\n\n主要用于描述和定义Java程序中各种变量的访问和操作规则，以及在JVM中如何将变量存储到内存以及从内存读出的过程\n\n1. 多线程访问共享变量的规则\n   1. JVM会给每个线程更配一个自己独立的内存空间，同时也会有一个自己的主内存空间\n   2. 多线程间的共享变量会存在主内存空间\n   \n2. 线程的特性\n   1. 原子性\n   2. 可见性\n   \n   JMM:Java Memory Model\n         主要用于描述和定义Java程序中各种变量的访问和操作规则,\n         以及在Jvm中如何将变量存储到内存以及从内存读出的过程\n   \n         1、多线程访问共享变量的规则\n            1>Jvm会给每个线程分配一个自己独立的内存空间,\n              同时也会有一个自己的主内存空间\n            2>多线程间的共享变量会存储在主内存空间\n            3>线程对共享变量的操作,需要从\n              主内存中拷贝一份该变量的副本到自己独立的工作\n              内存中进行,修改完成后将该变量的值再重新拷贝到主内存中,\n              线程不能直接操作主内存的共享变量值\n            4>不同线程之间无法直接访问其他线程工作内存中的变量,\n              线程间变量值的传递必须通过主内存来进行完成\n   \n   \n   ​     \n   ​       2、线程的特性:\n   ​           1>原子性(不可分割)\n   ​             一系列的操作要么都执行,要么都不执行,不可再分割,\n   ​             比如从主内存中读取共享变量的值,在工作内存中修改后,\n   ​             再刷新回主内存,这些操作不可分割,\n   ​             线程与线程之间相互独立,在一个时间段内\n   ​    只允许一个线程进入cpu执行任务操作共享变量,\n   ​    synchronized同步锁和ReentrantLock可重入锁\n   ​    都可以实现线程原子性\n   ​    \n   ​           2>可见性\n   ​             1)一个线程对共享变量的操作,能够及时的被其他线程所看到\n   ​             2)可见性实现原理\n   ​                1)每次操作该变量时都会将主内存中\n   ​      共享变量拷贝到工作内存\n   ​    2)每次在工作内存中操作完该变量时,\n   ​      都会把值同步到主内存中\n   ​       3)Synchronized,ReentrantLock以及\n   ​      volatile都可以实现线程可见性\n   ​    \n   ​             3)synchronize实现可见性原理\n   ​                1>获取同步锁\n   ​                2>清空工作内存中的副本值\n   ​                3>从主内中拷贝共享变量的最新值到自己的工作内存中\n   ​                4>在工作内存中执行代码\n   ​                5>将更改之后共享变量的值刷新到主内存\n   ​                6>释放同步锁\n   ​                7>synchronized既能保证原子性也能保证可见性\n   ​    \n   ​             4)volatile实现可见性原理\n   ​                volatile只能保证共享变量的可见性,但不能保证原子性\n   ​                当线程需要去修改volatile变量值:\n   ​                1>先从主内存中读取volatile共享变量的最新值到工作内存\n   ​                2>再操作工作内存volatile变量的副本值\n   ​                3>再将改变之后的副本值从工作内存刷新到主内存\n   ​    \n   ​                 volatile使用场景:线程多次修改的共享值之间不存在依赖关系\n   ​    \n   ​              5)synchronized和volatile区别\n   ​                1>volatile不需要加锁,比synchronized更加轻量级,\n   ​                  不会阻塞线程\n   ​                2>synchronized既保证可见性又保证原子性,\n   ​                  而volatile只保证了可见性,不保证原子性\n   ​                3>synchronized比validate使用场景更多,范围更广\n   ​    \n              3>有序性(非指令重排性):让JVM在解释执行字节码文件时,\n          严格按照字节码中的顺序来执行指令,不要进行重排序\n   \n   \n     4、指令重排序\n      1>重排序概念\n        代码的编写顺序和最终执行顺序不一致\n        \n      2>重排序目的\n        编译器或处理器做优化,提高程序的执行性能,哪个指令先来,\n        先执行哪个\n   \n      2.1>编译器优化重排序\n        2.2>处理器指令级并行重排序或内存系统的重排序\n            源代\n   \n   2.1>编译器优化重排序\n        2.2>处理器指令级并行重排序或内存系统的重排序\n            源代码 -> 编译器优化的重排 -> \n         指令并行的重排 -> 内存系统的重排 -> 最终执行指令\n   \n      3>重排序导致后果\n        3.1>单线程重排序会遵循as-if-serial原则,\n          也就是会考虑数据依赖问题,\n          无论如何重排序,程序最终执行结果必须\n          与代码顺序执行结果一致\n   \n      3.2>多线程并发情况下,指令重排序可能会导致\n           最终结果与预期结果不一致\n   \n      3.3>synchronized和volatile都能禁止指令重排序\n          volatile:通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化,\n          volatile的写和读的时候，加入屏障，防止出现指令重排的\n        \n        线程A:\n        int a = 10;\n        int b = 20;\n        \n        线程B:\n        int c = a+b;\n          \n        Object obj = new Object();\n        创建对象过程\n        1>初始化一块内存空间\n        2>给成员变量赋初始值\n        3>将内存空间地址赋值给引用\n       \n        if(obj!=null){\n           //执行代码 \n        }\n\n","slug":"线程","published":1,"updated":"2023-08-10T09:48:41.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwaj002yfswo3w3oblpi","content":"<h1 id=\"线程Thread\"><a href=\"#线程Thread\" class=\"headerlink\" title=\"线程Thread\"></a>线程Thread</h1><h3 id=\"一、什么是进程\"><a href=\"#一、什么是进程\" class=\"headerlink\" title=\"一、什么是进程\"></a>一、什么是进程</h3><p>​\t进程（Process）：操作系统上一个正在运行中的程序，进程会拥有当前程序的所有资源</p>\n<p>​\t线程（Thread）：进程内部的一个执行功能单元，每个线程都会有自己独立的一块内存空间，一个进程内部会有一到多个线程组成，进程只是拥有程序的资源，而线程是负责获取资源来执行具体任务的，进程内部的资源会被当前进程内所有线程共享</p>\n<h3 id=\"二、多线程的执行方式\"><a href=\"#二、多线程的执行方式\" class=\"headerlink\" title=\"二、多线程的执行方式\"></a>二、多线程的执行方式</h3><h5 id=\"并发（concurrent）\"><a href=\"#并发（concurrent）\" class=\"headerlink\" title=\"并发（concurrent）\"></a><strong>并发（concurrent）</strong></h5><p>​\t多线程默认是并发执行</p>\n<p>​\t操作系统会将时间片划分为很多个时间点，在每个时间点上只允许一个线程获取CPU，并进入CPU中执行他的任务，执行一段时间后就退出CPU，下一个线程再获得CPU进入执行，依次类推，因此为时间被划分足够细，切换足够快所以从宏观上看是多个线程同时进行，而微观上看轮流切换执行，这种现象叫并发，并发并不是真正意义上的同时</p>\n<h5 id=\"并行-parlen\"><a href=\"#并行-parlen\" class=\"headerlink\" title=\"并行(parlen)\"></a>并行(parlen)</h5><p>​\t并行只会出现多核CPU，一个CPU再一个时间段内只能干一件事，但是多个CPU就可以再 一个时间段内干多件事，这个就是真正意义上的同时</p>\n<h5 id=\"多线程并发的优点\"><a href=\"#多线程并发的优点\" class=\"headerlink\" title=\"多线程并发的优点\"></a>多线程并发的优点</h5><p>​\t优点：提升系统性能和工作效率</p>\n<p>​\t缺点：多线程对同一资源进行操作时，可能会发生并发问题导致数据不安全，可以通过加锁解决</p>\n<h3 id=\"三、线程的创建方式\"><a href=\"#三、线程的创建方式\" class=\"headerlink\" title=\"三、线程的创建方式\"></a>三、线程的创建方式</h3><h5 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h5><p>​\t继承Thread类</p>\n<pre><code>1. 写一个线程类继承Thread类\n2. 重写run（）方法，代表线程所要执行的具体任务是什么\n3. 创建线程实例\n4. 调用start（）方法启动线程\n</code></pre>\n<h5 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h5><pre><code>1. 写一个任务类实现Runnable接口，该类实例代表线程所要执行的任务对象\n2. 重写run（）方法，代表执行的具体任务是什么\n3. 创建任务实例\n4. 创建一个线程实例，将任务实例作为参数传给线程实例\n5. 调用start（）方法启动线程\n</code></pre>\n<blockquote>\n<p>推介使用：实现Runnable接口方式创建线程</p>\n<ol>\n<li>解决Java中单继承带来的弊端</li>\n<li>可以让多个线程来执行同一个任务</li>\n<li>将线程实例和任务实例解耦合</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：线程调用了start（)方法后，不会立即获得CPU，而是处于一个就绪（准备）状态，等待操作系统为其分配时间片，线程只有获得了时间片才会进入CPU中执行他的任务，也就是执行run（）方法中的代码</p>\n</blockquote>\n<h3 id=\"四、线程的主要方法\"><a href=\"#四、线程的主要方法\" class=\"headerlink\" title=\"四、线程的主要方法\"></a>四、线程的主要方法</h3><ol>\n<li><p>run()</p>\n<p>线程获得CPU之后，执行的任务</p>\n</li>\n<li><p>start()</p>\n<p>启动线程，让线程处于就绪状态</p>\n</li>\n<li><p>Thread static currentThread()</p>\n<p>获取当前线程实例</p>\n</li>\n<li><p>void setName(String name)&#x2F;String getName()</p>\n<p>获取&#x2F;修改线程名称，线程默认名称：主线程：main，其他工作线程：Thread-0&#x2F;Thread-1</p>\n</li>\n<li><p>long getId()</p>\n<p>获取线程Id,主线程id：1，其他工作线程，10，11，12….</p>\n</li>\n<li><p>static int activeCount()</p>\n<p>获取当前线程所属线程组中活动的线程数</p>\n</li>\n<li><p>void setPriority(int priority)&#x2F;getProiority()</p>\n<p>获取&#x2F;修改线程的优先级</p>\n<p>线程默认优先级：5，最高优先级：10，最低优先级：1</p>\n<blockquote>\n<p>优先级是改善线程获取CPU的概率</p>\n</blockquote>\n</li>\n<li><p>setDaemon(True)</p>\n<p>将线程设置后守护线程(后台线程，用户线程，精灵线程)那么其他的线程就会自动变为前台线程，一个进程最多只允许一个守护线程当其他所有前台线程都结束了，守护线程也就结束了必须要再启动线程之前设置</p>\n</li>\n<li><p>Thread.sleep(long millis)</p>\n<p>线程休眠,处于运行状态的线程如果调用了sleep()休眠方式，就会立即退出CPU,处于阻塞状态，在此期间线程是无法再次获得CPU的，休眠结束线程又重写回到就绪状态，等待操作系统重新为其分配时间片，处于休眠状态的线程可以再别的线程中通过调用interrupt（）方法进行唤醒</p>\n</li>\n<li><p>void join（）</p>\n</li>\n</ol>\n<p>   插入式线程</p>\n<p>   将一个线程插入到另外一个线程前面去执行，被插入的线程就会处于阻塞状态，在此期间式无法获得CPU的，必须等待插入的线程在CPU中彻底执行完成任务退出CPU之后，被插入的线程才会结束阻塞状态进入就绪状态</p>\n<h3 id=\"五、线程的状态-生命周期\"><a href=\"#五、线程的状态-生命周期\" class=\"headerlink\" title=\"五、线程的状态(生命周期)\"></a>五、线程的状态(生命周期)</h3><ol>\n<li><p>新建状态</p>\n<p>线程实例刚被创建出来</p>\n</li>\n<li><p>就绪状态</p>\n<p>等待操作系统为其分配时间片</p>\n<ol>\n<li>新建状态的线程调用start()方法</li>\n<li>阻塞状态的线程阻塞结束</li>\n</ol>\n</li>\n<li><p>运行状态</p>\n<p>就绪状态获得了操作系统为其分配的时间片，进入CPU中执行他的任务，也就是调用run（）方法</p>\n</li>\n<li><p>阻塞状态</p>\n<p>运行状态的线程退出CPU处于等待状态，在阻塞期间是无法获得CPU的</p>\n<ol>\n<li>线程休眠</li>\n<li>线程被插入</li>\n<li>线程wait()&#x2F;await()等待</li>\n<li>IO阻塞</li>\n</ol>\n</li>\n<li><p>死亡状态</p>\n<p>线程执行完了他的任务，就会被操作系统回收</p>\n</li>\n</ol>\n<h3 id=\"六、线程同步与协作\"><a href=\"#六、线程同步与协作\" class=\"headerlink\" title=\"六、线程同步与协作\"></a>六、线程同步与协作</h3><ol>\n<li><p>异步和同步的概念</p>\n<p><strong>异步</strong>：一个进程内部的多个线程之间默认是异步并发执行的，轮流切换时间片来执行任务，宏观上看同时在进行</p>\n<p><strong>同步</strong>：因为多线程默认是异步并发执行的，所以如果有多个线程对同一资源(共享变量)进行操作时，就有可能会引发线程并发不安全问题，所以这时候就需要多线程，有先后顺序的来执行，这个就叫线程同步（串发）</p>\n</li>\n<li><p>如何将线程默认的异步操作改为同步操作</p>\n<p>Java中提供了一种锁机制来支持多线程同步，保证共享资源的安全性</p>\n<ol>\n<li><p>Synchronized同步锁</p>\n<ol>\n<li><p>同步代码块</p>\n<p>若干个线程过来之后，只会有一个线程先获得同步锁对象，然后进入同步代码块中执行代码，同时将这一块代码锁死在该线程执行期间，其他线程均处于阻塞状态，无法获得CPU，只要等当前线程执行完了同步代码块中所有代码之后，才会释放同步锁，其他处于阻塞状态的状态进入到就绪状态从而来枪已经释放的同步锁，进入同步代码块中执行任务，未抢到的锁的线程依然处于阻塞状态，依次类推，多线程就可以按顺序先后执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(同步锁对象)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步方法</p>\n<p>多线程在调用这个方法时，只有一个线程会先获得同步锁对象，获得同步锁的线程会先来调用该方法，在调用期间其他线程也是处于阻塞状态，等该线程调用完方法释放同步锁后，其他线程才能获得同步锁来调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 <span class=\"keyword\">synchronized</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步锁对象的选择</p>\n<p>任意引用类型对象都可以来当做同步锁，但是必须保证多个线程看到的是同一个锁对象</p>\n<p>实例方法同步锁对象默认为this</p>\n<p>静态方法同步锁对象默认为当前类(类名.class)</p>\n</li>\n<li><p>synchronized的可重入性</p>\n<p>可重入锁，也叫递归锁</p>\n<p>如果一个线程在外部已经获得改锁，那么进入到线程内部的后可以继续获得该锁，而不会因为之前的锁没有释放无法获得这把锁，可重入锁可以在一定程度上避免线程死锁</p>\n</li>\n</ol>\n</li>\n<li><p>ReentrantLock可重入锁</p>\n<ol>\n<li><p>ReentrantLock实现线程重入锁实现线程同步</p>\n<ol>\n<li>lock（)获得锁，获取不到会阻塞</li>\n<li>unlock()释放锁</li>\n<li>trylock()尝试获得锁，获得True，未获得False,不会阻塞</li>\n<li>lockInterruptibly（）获得锁，获取不到会阻塞，但是阻塞会被打断</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了确保无论如何都会被释放：</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得锁</span></span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ReentrantLock实现锁的可重入性</p>\n<p>synchronized锁和ReentrantLock锁都是可重入锁</p>\n</li>\n<li><p>ReentrantLock获得锁的过程</p>\n<ol>\n<li><p>当多个线程来获得同一个锁对象时，只有一个线程能获得锁对象，其他未获得所得线程会被添加到等待队列中，先就绪的线程就会被添加到列的头部，等上一个获得锁的线程执行完成任务释放锁之后，就会从队列的取出，一个线程再来获取锁</p>\n<blockquote>\n<p>注意：线程只有调用Starrt()方法会处于就绪状态，但是先调用start（）方法的线程不一定就会先就绪</p>\n</blockquote>\n<p><strong>非公平锁</strong>：创建对象不带参数或参数为false，创建的就是非公平锁，持有锁的线程再执行完任务释放的一瞬间，如果有非队列中的线程过来获取锁，那么该线程就能立即获得锁，所以如果一直非队列线程过来获得锁，就会造成队列中的线程一直处于等待状态（饥饿等待），但是非公平锁效率高，因为不需要频繁的往等待的队列中添加和取出线程</p>\n<p><strong>公平锁</strong>：创建对象时带的参数为true，则代表创建的时公平锁，严格按照FIFO先进先出原则，从队列中依次取出线程来获得锁执行任务，即使再持有锁的线程执行完任务释放锁的一瞬间，有非队列线程过来也依然会被加入到队列的末尾中，不会造成饥饿等待，效率比较低，因为需要频繁的往队列添加和取出线程</p>\n</li>\n</ol>\n</li>\n<li><p>读写锁</p>\n<p>多线程在对同一资源进行操作时，可以使用读写锁</p>\n<ol>\n<li>读锁和读锁之间是线程共享的</li>\n<li>写锁和写锁之间是线程互斥的</li>\n<li>读锁和写锁之间是线程互斥的</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>线程间协作(等待)的概念</p>\n<ol>\n<li><p>多线程在同步了的基础上，必须按照一个排好的顺序来获取CPU执行任务</p>\n</li>\n<li><p>怎样实现线程间协作</p>\n<ol>\n<li><p>使用synchronized同步锁，可以借助Object类中wait()&#x2F;notify()&#x2F;notifyAll()三个方法来实现线程间协作</p>\n</li>\n<li><p>wait()</p>\n<p>调用该方法的线程会释放已经获得的锁然后进入等待状态，一直等到其他具备相同锁的线程调用notify()或notifyAll()方法后才会结束等待进入就绪状态</p>\n</li>\n<li><p>notify()</p>\n<p>调用该方法的线程会通知其他具备相同锁的线程结束等待，从而进入就绪状态，等到执行完同步代码块后才会释放同步锁，notify()方法本身是不会释放同步锁的，该方法一般写同步代码块最后面</p>\n</li>\n<li><p>使用ReentrantLock可重入锁实现线程间协作</p>\n<p>通过ReentrantLock来获取一个Condition对象，然后借助Condition对象中的await()&#x2F;signal()&#x2F;signalAll()三个方法</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>以上三个方法必须在lock()和unlock()两个方法之间</li>\n<li>方法必须有condition对象来进行调用</li>\n<li>多线程间的condition对象必须是同一个</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"七、线程池\"><a href=\"#七、线程池\" class=\"headerlink\" title=\"七、线程池\"></a>七、线程池</h3><p>​\t线程池(ThreadPool线程的第三种创建方式)</p>\n<ol>\n<li><p><strong>线程池的概念</strong></p>\n<p>用于创建和管理多个线程的容器对象，当我们的程序需要线程时可以直接从池中取出，当执行完任务后，将线程返回到池中，让线程得到复用，避免频繁的创建和销毁，从而节省系统的开销</p>\n</li>\n<li><p><strong>线程池的创建</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"type\">int</span> corePoolSize   核心线程数,</span><br><span class=\"line\">                <span class=\"type\">int</span> maximumPoolSize 最大线程数,</span><br><span class=\"line\">                <span class=\"type\">long</span> keepAliveTime 超时(空闲，活跃)时间,</span><br><span class=\"line\">                TimeUnit unit 时间单位,</span><br><span class=\"line\">                BlockingQueue&lt;Runnable&gt; workQueue 任务队列,</span><br><span class=\"line\">                ThreadFactory threadFactory 线程工厂,</span><br><span class=\"line\">    \t\t\tRejectedExecutionHandler handler 拒绝执行处理;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>拒绝策略</strong></p>\n<p>1、<strong>AbortPolicy</strong><br>   拒绝执行新的任务，并抛出RejectedExecutionException异常<br>2、<strong>CallerRunPolicy</strong><br>   如果线程池已关闭，直接丢弃该任务，<br>   如果线程池没有关闭，不会使用线程池中的线程，<br>   也不会将其加入到任务队列中，而是让当前线程直接来调用run()方法，<br>   相当于没有创建额外的线程<br>3、<strong>DiscardOldestPolicy</strong><br>   如果线程池已关闭，直接丢掉该任务<br>   入宫线程没有关闭，将任务队列存在最久的任务丢掉，<br>   并将新的任务加入到任务队列中<br>4、<strong>DiscardPolicy</strong><br>   直接丢掉新的任务，但是不会抛出异常</p>\n</li>\n<li><p>Java<strong>自带的线程池</strong></p>\n<ol>\n<li><p>创建单线程的线程池</p>\n<p>只有一个线程，不允许创建非核心线程      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建固定数量线程的线程池</p>\n<p>传入的参数既是核心线程数也是最大线程数，不允许创建非核心线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建可缓存线程池</p>\n<p>内部没有核心线程，所有的线程都是非核心线程<br>所有的非核心线程都是超过60s处于空闲状态就会被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建周期性线程池</p>\n<p>传入的参数为核心线程数，队列为延迟队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span>Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>线程池主要方法</p>\n<ol>\n<li><p><strong>execute</strong>(Ruunable task)</p>\n<p>将任务交给线程池来执行</p>\n<p>线程池会自动获取出空闲的线程来执行该任务</p>\n</li>\n<li><p><strong>allowCoreThreadTimeOut</strong>()</p>\n<p>允许核心线程超时</p>\n</li>\n<li><p><strong>es.shutdownNow</strong>();</p>\n<p>立即关闭，可能会导致线程池中还没有执行完毕</p>\n</li>\n<li><p><strong>es.shutdown</strong>();</p>\n<p>安全关闭，必须等待线程池中所有线程都执行完成任务后才会关闭</p>\n</li>\n<li><p><strong>es.schedule</strong>(Runnable command,long delay, TimeUnit unit);</p>\n<p>周期性线程池执行周期任务</p>\n</li>\n<li><p><strong>es.scheduleAtFixedRate</strong></p>\n<p>Runnable command, 要执行的任务<br>long initialDelay, 第一次执行任务的延迟时间<br>long period, 两次执行之间的间隔时间<br>TimeUnit unit 时间单位<br>任务的执行时间超过了间隔时间，那么在一次任务，执行完成后就会立即执行下一次任务如果没有超过间隔时间那么就会在指定间隔之后才会执行下一个任务</p>\n</li>\n<li><p><strong>es.scheduleWithFixedDelay</strong></p>\n<p>不管任务的执行时间是否超过间隔时间,必须等待本次任务执行完成后,再间隔指定时间才会去执行下一次的任务</p>\n</li>\n</ol>\n</li>\n<li><p><strong>Callable</strong></p>\n<p>实现Callable接口的实现类为线程要执行的任务</p>\n<p>Callable使用步骤</p>\n<ol>\n<li>写一个类实现Callable接口，并指定泛型，泛型为任务执行完成后需要得到的结果类型</li>\n<li>重写Call()方法，该方法所要执行的任务，相当于是Runnable中的run()方法</li>\n<li>通过线程来执行任务<ol>\n<li>创建Callable实现实例，并通过FutureTask来封装该实例</li>\n<li>创建线程来执行FutureTask来执行实例</li>\n<li>调用FutureTask的get()方法 来获取任务执行结果</li>\n</ol>\n</li>\n<li>通过线程池来执行任务<ol>\n<li>创建Callable实现实例，创建线程池</li>\n<li>调用线程池的submit()方法执行Callable任务实例，返回一个Future()</li>\n<li>调用Future类的get()方法来获取任务执行结果</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"八、线程内存模型\"><a href=\"#八、线程内存模型\" class=\"headerlink\" title=\"八、线程内存模型\"></a>八、线程内存模型</h3><h5 id=\"JMM-Java-Memory-Model\"><a href=\"#JMM-Java-Memory-Model\" class=\"headerlink\" title=\"JMM:Java Memory Model\"></a>JMM:Java Memory Model</h5><p>主要用于描述和定义Java程序中各种变量的访问和操作规则，以及在JVM中如何将变量存储到内存以及从内存读出的过程</p>\n<ol>\n<li><p>多线程访问共享变量的规则</p>\n<ol>\n<li>JVM会给每个线程更配一个自己独立的内存空间，同时也会有一个自己的主内存空间</li>\n<li>多线程间的共享变量会存在主内存空间</li>\n</ol>\n</li>\n<li><p>线程的特性</p>\n<ol>\n<li>原子性</li>\n<li>可见性</li>\n</ol>\n<p>JMM:Java Memory Model<br>      主要用于描述和定义Java程序中各种变量的访问和操作规则,<br>      以及在Jvm中如何将变量存储到内存以及从内存读出的过程</p>\n<pre><code>  1、多线程访问共享变量的规则\n     1&gt;Jvm会给每个线程分配一个自己独立的内存空间,\n       同时也会有一个自己的主内存空间\n     2&gt;多线程间的共享变量会存储在主内存空间\n     3&gt;线程对共享变量的操作,需要从\n       主内存中拷贝一份该变量的副本到自己独立的工作\n       内存中进行,修改完成后将该变量的值再重新拷贝到主内存中,\n       线程不能直接操作主内存的共享变量值\n     4&gt;不同线程之间无法直接访问其他线程工作内存中的变量,\n       线程间变量值的传递必须通过主内存来进行完成\n</code></pre>\n<p>​<br>​       2、线程的特性:<br>​           1&gt;原子性(不可分割)<br>​             一系列的操作要么都执行,要么都不执行,不可再分割,<br>​             比如从主内存中读取共享变量的值,在工作内存中修改后,<br>​             再刷新回主内存,这些操作不可分割,<br>​             线程与线程之间相互独立,在一个时间段内<br>​    只允许一个线程进入cpu执行任务操作共享变量,<br>​    synchronized同步锁和ReentrantLock可重入锁<br>​    都可以实现线程原子性<br>​<br>​           2&gt;可见性<br>​             1)一个线程对共享变量的操作,能够及时的被其他线程所看到<br>​             2)可见性实现原理<br>​                1)每次操作该变量时都会将主内存中<br>​      共享变量拷贝到工作内存<br>​    2)每次在工作内存中操作完该变量时,<br>​      都会把值同步到主内存中<br>​       3)Synchronized,ReentrantLock以及<br>​      volatile都可以实现线程可见性<br>​<br>​             3)synchronize实现可见性原理<br>​                1&gt;获取同步锁<br>​                2&gt;清空工作内存中的副本值<br>​                3&gt;从主内中拷贝共享变量的最新值到自己的工作内存中<br>​                4&gt;在工作内存中执行代码<br>​                5&gt;将更改之后共享变量的值刷新到主内存<br>​                6&gt;释放同步锁<br>​                7&gt;synchronized既能保证原子性也能保证可见性<br>​<br>​             4)volatile实现可见性原理<br>​                volatile只能保证共享变量的可见性,但不能保证原子性<br>​                当线程需要去修改volatile变量值:<br>​                1&gt;先从主内存中读取volatile共享变量的最新值到工作内存<br>​                2&gt;再操作工作内存volatile变量的副本值<br>​                3&gt;再将改变之后的副本值从工作内存刷新到主内存<br>​<br>​                 volatile使用场景:线程多次修改的共享值之间不存在依赖关系<br>​<br>​              5)synchronized和volatile区别<br>​                1&gt;volatile不需要加锁,比synchronized更加轻量级,<br>​                  不会阻塞线程<br>​                2&gt;synchronized既保证可见性又保证原子性,<br>​                  而volatile只保证了可见性,不保证原子性<br>​                3&gt;synchronized比validate使用场景更多,范围更广<br>​<br>           3&gt;有序性(非指令重排性):让JVM在解释执行字节码文件时,<br>       严格按照字节码中的顺序来执行指令,不要进行重排序</p>\n<p>  4、指令重排序<br>   1&gt;重排序概念<br>     代码的编写顺序和最终执行顺序不一致</p>\n<p>   2&gt;重排序目的<br>     编译器或处理器做优化,提高程序的执行性能,哪个指令先来,<br>     先执行哪个</p>\n<p>   2.1&gt;编译器优化重排序<br>     2.2&gt;处理器指令级并行重排序或内存系统的重排序<br>         源代</p>\n<p>2.1&gt;编译器优化重排序<br>     2.2&gt;处理器指令级并行重排序或内存系统的重排序<br>         源代码 -&gt; 编译器优化的重排 -&gt;<br>      指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p>\n<p>   3&gt;重排序导致后果<br>     3.1&gt;单线程重排序会遵循as-if-serial原则,<br>       也就是会考虑数据依赖问题,<br>       无论如何重排序,程序最终执行结果必须<br>       与代码顺序执行结果一致</p>\n<p>   3.2&gt;多线程并发情况下,指令重排序可能会导致<br>        最终结果与预期结果不一致</p>\n<p>   3.3&gt;synchronized和volatile都能禁止指令重排序<br>       volatile:通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化,<br>       volatile的写和读的时候，加入屏障，防止出现指令重排的</p>\n<pre><code> 线程A:\n int a = 10;\n int b = 20;\n \n 线程B:\n int c = a+b;\n   \n Object obj = new Object();\n 创建对象过程\n 1&gt;初始化一块内存空间\n 2&gt;给成员变量赋初始值\n 3&gt;将内存空间地址赋值给引用\n\n if(obj!=null)&#123;\n    //执行代码 \n &#125;\n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h1 id=\"线程Thread\"><a href=\"#线程Thread\" class=\"headerlink\" title=\"线程Thread\"></a>线程Thread</h1><h3 id=\"一、什么是进程\"><a href=\"#一、什么是进程\" class=\"headerlink\" title=\"一、什么是进程\"></a>一、什么是进程</h3><p>​\t进程（Process）：操作系统上一个正在运行中的程序，进程会拥有当前程序的所有资源</p>\n<p>​\t线程（Thread）：进程内部的一个执行功能单元，每个线程都会有自己独立的一块内存空间，一个进程内部会有一到多个线程组成，进程只是拥有程序的资源，而线程是负责获取资源来执行具体任务的，进程内部的资源会被当前进程内所有线程共享</p>\n<h3 id=\"二、多线程的执行方式\"><a href=\"#二、多线程的执行方式\" class=\"headerlink\" title=\"二、多线程的执行方式\"></a>二、多线程的执行方式</h3><h5 id=\"并发（concurrent）\"><a href=\"#并发（concurrent）\" class=\"headerlink\" title=\"并发（concurrent）\"></a><strong>并发（concurrent）</strong></h5><p>​\t多线程默认是并发执行</p>\n<p>​\t操作系统会将时间片划分为很多个时间点，在每个时间点上只允许一个线程获取CPU，并进入CPU中执行他的任务，执行一段时间后就退出CPU，下一个线程再获得CPU进入执行，依次类推，因此为时间被划分足够细，切换足够快所以从宏观上看是多个线程同时进行，而微观上看轮流切换执行，这种现象叫并发，并发并不是真正意义上的同时</p>\n<h5 id=\"并行-parlen\"><a href=\"#并行-parlen\" class=\"headerlink\" title=\"并行(parlen)\"></a>并行(parlen)</h5><p>​\t并行只会出现多核CPU，一个CPU再一个时间段内只能干一件事，但是多个CPU就可以再 一个时间段内干多件事，这个就是真正意义上的同时</p>\n<h5 id=\"多线程并发的优点\"><a href=\"#多线程并发的优点\" class=\"headerlink\" title=\"多线程并发的优点\"></a>多线程并发的优点</h5><p>​\t优点：提升系统性能和工作效率</p>\n<p>​\t缺点：多线程对同一资源进行操作时，可能会发生并发问题导致数据不安全，可以通过加锁解决</p>\n<h3 id=\"三、线程的创建方式\"><a href=\"#三、线程的创建方式\" class=\"headerlink\" title=\"三、线程的创建方式\"></a>三、线程的创建方式</h3><h5 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h5><p>​\t继承Thread类</p>\n<pre><code>1. 写一个线程类继承Thread类\n2. 重写run（）方法，代表线程所要执行的具体任务是什么\n3. 创建线程实例\n4. 调用start（）方法启动线程\n</code></pre>\n<h5 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h5><pre><code>1. 写一个任务类实现Runnable接口，该类实例代表线程所要执行的任务对象\n2. 重写run（）方法，代表执行的具体任务是什么\n3. 创建任务实例\n4. 创建一个线程实例，将任务实例作为参数传给线程实例\n5. 调用start（）方法启动线程\n</code></pre>\n<blockquote>\n<p>推介使用：实现Runnable接口方式创建线程</p>\n<ol>\n<li>解决Java中单继承带来的弊端</li>\n<li>可以让多个线程来执行同一个任务</li>\n<li>将线程实例和任务实例解耦合</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：线程调用了start（)方法后，不会立即获得CPU，而是处于一个就绪（准备）状态，等待操作系统为其分配时间片，线程只有获得了时间片才会进入CPU中执行他的任务，也就是执行run（）方法中的代码</p>\n</blockquote>\n<h3 id=\"四、线程的主要方法\"><a href=\"#四、线程的主要方法\" class=\"headerlink\" title=\"四、线程的主要方法\"></a>四、线程的主要方法</h3><ol>\n<li><p>run()</p>\n<p>线程获得CPU之后，执行的任务</p>\n</li>\n<li><p>start()</p>\n<p>启动线程，让线程处于就绪状态</p>\n</li>\n<li><p>Thread static currentThread()</p>\n<p>获取当前线程实例</p>\n</li>\n<li><p>void setName(String name)&#x2F;String getName()</p>\n<p>获取&#x2F;修改线程名称，线程默认名称：主线程：main，其他工作线程：Thread-0&#x2F;Thread-1</p>\n</li>\n<li><p>long getId()</p>\n<p>获取线程Id,主线程id：1，其他工作线程，10，11，12….</p>\n</li>\n<li><p>static int activeCount()</p>\n<p>获取当前线程所属线程组中活动的线程数</p>\n</li>\n<li><p>void setPriority(int priority)&#x2F;getProiority()</p>\n<p>获取&#x2F;修改线程的优先级</p>\n<p>线程默认优先级：5，最高优先级：10，最低优先级：1</p>\n<blockquote>\n<p>优先级是改善线程获取CPU的概率</p>\n</blockquote>\n</li>\n<li><p>setDaemon(True)</p>\n<p>将线程设置后守护线程(后台线程，用户线程，精灵线程)那么其他的线程就会自动变为前台线程，一个进程最多只允许一个守护线程当其他所有前台线程都结束了，守护线程也就结束了必须要再启动线程之前设置</p>\n</li>\n<li><p>Thread.sleep(long millis)</p>\n<p>线程休眠,处于运行状态的线程如果调用了sleep()休眠方式，就会立即退出CPU,处于阻塞状态，在此期间线程是无法再次获得CPU的，休眠结束线程又重写回到就绪状态，等待操作系统重新为其分配时间片，处于休眠状态的线程可以再别的线程中通过调用interrupt（）方法进行唤醒</p>\n</li>\n<li><p>void join（）</p>\n</li>\n</ol>\n<p>   插入式线程</p>\n<p>   将一个线程插入到另外一个线程前面去执行，被插入的线程就会处于阻塞状态，在此期间式无法获得CPU的，必须等待插入的线程在CPU中彻底执行完成任务退出CPU之后，被插入的线程才会结束阻塞状态进入就绪状态</p>\n<h3 id=\"五、线程的状态-生命周期\"><a href=\"#五、线程的状态-生命周期\" class=\"headerlink\" title=\"五、线程的状态(生命周期)\"></a>五、线程的状态(生命周期)</h3><ol>\n<li><p>新建状态</p>\n<p>线程实例刚被创建出来</p>\n</li>\n<li><p>就绪状态</p>\n<p>等待操作系统为其分配时间片</p>\n<ol>\n<li>新建状态的线程调用start()方法</li>\n<li>阻塞状态的线程阻塞结束</li>\n</ol>\n</li>\n<li><p>运行状态</p>\n<p>就绪状态获得了操作系统为其分配的时间片，进入CPU中执行他的任务，也就是调用run（）方法</p>\n</li>\n<li><p>阻塞状态</p>\n<p>运行状态的线程退出CPU处于等待状态，在阻塞期间是无法获得CPU的</p>\n<ol>\n<li>线程休眠</li>\n<li>线程被插入</li>\n<li>线程wait()&#x2F;await()等待</li>\n<li>IO阻塞</li>\n</ol>\n</li>\n<li><p>死亡状态</p>\n<p>线程执行完了他的任务，就会被操作系统回收</p>\n</li>\n</ol>\n<h3 id=\"六、线程同步与协作\"><a href=\"#六、线程同步与协作\" class=\"headerlink\" title=\"六、线程同步与协作\"></a>六、线程同步与协作</h3><ol>\n<li><p>异步和同步的概念</p>\n<p><strong>异步</strong>：一个进程内部的多个线程之间默认是异步并发执行的，轮流切换时间片来执行任务，宏观上看同时在进行</p>\n<p><strong>同步</strong>：因为多线程默认是异步并发执行的，所以如果有多个线程对同一资源(共享变量)进行操作时，就有可能会引发线程并发不安全问题，所以这时候就需要多线程，有先后顺序的来执行，这个就叫线程同步（串发）</p>\n</li>\n<li><p>如何将线程默认的异步操作改为同步操作</p>\n<p>Java中提供了一种锁机制来支持多线程同步，保证共享资源的安全性</p>\n<ol>\n<li><p>Synchronized同步锁</p>\n<ol>\n<li><p>同步代码块</p>\n<p>若干个线程过来之后，只会有一个线程先获得同步锁对象，然后进入同步代码块中执行代码，同时将这一块代码锁死在该线程执行期间，其他线程均处于阻塞状态，无法获得CPU，只要等当前线程执行完了同步代码块中所有代码之后，才会释放同步锁，其他处于阻塞状态的状态进入到就绪状态从而来枪已经释放的同步锁，进入同步代码块中执行任务，未抢到的锁的线程依然处于阻塞状态，依次类推，多线程就可以按顺序先后执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(同步锁对象)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步方法</p>\n<p>多线程在调用这个方法时，只有一个线程会先获得同步锁对象，获得同步锁的线程会先来调用该方法，在调用期间其他线程也是处于阻塞状态，等该线程调用完方法释放同步锁后，其他线程才能获得同步锁来调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 <span class=\"keyword\">synchronized</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同步锁对象的选择</p>\n<p>任意引用类型对象都可以来当做同步锁，但是必须保证多个线程看到的是同一个锁对象</p>\n<p>实例方法同步锁对象默认为this</p>\n<p>静态方法同步锁对象默认为当前类(类名.class)</p>\n</li>\n<li><p>synchronized的可重入性</p>\n<p>可重入锁，也叫递归锁</p>\n<p>如果一个线程在外部已经获得改锁，那么进入到线程内部的后可以继续获得该锁，而不会因为之前的锁没有释放无法获得这把锁，可重入锁可以在一定程度上避免线程死锁</p>\n</li>\n</ol>\n</li>\n<li><p>ReentrantLock可重入锁</p>\n<ol>\n<li><p>ReentrantLock实现线程重入锁实现线程同步</p>\n<ol>\n<li>lock（)获得锁，获取不到会阻塞</li>\n<li>unlock()释放锁</li>\n<li>trylock()尝试获得锁，获得True，未获得False,不会阻塞</li>\n<li>lockInterruptibly（）获得锁，获取不到会阻塞，但是阻塞会被打断</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了确保无论如何都会被释放：</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得锁</span></span><br><span class=\"line\">\t<span class=\"comment\">//需要进行同步的代码</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ReentrantLock实现锁的可重入性</p>\n<p>synchronized锁和ReentrantLock锁都是可重入锁</p>\n</li>\n<li><p>ReentrantLock获得锁的过程</p>\n<ol>\n<li><p>当多个线程来获得同一个锁对象时，只有一个线程能获得锁对象，其他未获得所得线程会被添加到等待队列中，先就绪的线程就会被添加到列的头部，等上一个获得锁的线程执行完成任务释放锁之后，就会从队列的取出，一个线程再来获取锁</p>\n<blockquote>\n<p>注意：线程只有调用Starrt()方法会处于就绪状态，但是先调用start（）方法的线程不一定就会先就绪</p>\n</blockquote>\n<p><strong>非公平锁</strong>：创建对象不带参数或参数为false，创建的就是非公平锁，持有锁的线程再执行完任务释放的一瞬间，如果有非队列中的线程过来获取锁，那么该线程就能立即获得锁，所以如果一直非队列线程过来获得锁，就会造成队列中的线程一直处于等待状态（饥饿等待），但是非公平锁效率高，因为不需要频繁的往等待的队列中添加和取出线程</p>\n<p><strong>公平锁</strong>：创建对象时带的参数为true，则代表创建的时公平锁，严格按照FIFO先进先出原则，从队列中依次取出线程来获得锁执行任务，即使再持有锁的线程执行完任务释放锁的一瞬间，有非队列线程过来也依然会被加入到队列的末尾中，不会造成饥饿等待，效率比较低，因为需要频繁的往队列添加和取出线程</p>\n</li>\n</ol>\n</li>\n<li><p>读写锁</p>\n<p>多线程在对同一资源进行操作时，可以使用读写锁</p>\n<ol>\n<li>读锁和读锁之间是线程共享的</li>\n<li>写锁和写锁之间是线程互斥的</li>\n<li>读锁和写锁之间是线程互斥的</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>线程间协作(等待)的概念</p>\n<ol>\n<li><p>多线程在同步了的基础上，必须按照一个排好的顺序来获取CPU执行任务</p>\n</li>\n<li><p>怎样实现线程间协作</p>\n<ol>\n<li><p>使用synchronized同步锁，可以借助Object类中wait()&#x2F;notify()&#x2F;notifyAll()三个方法来实现线程间协作</p>\n</li>\n<li><p>wait()</p>\n<p>调用该方法的线程会释放已经获得的锁然后进入等待状态，一直等到其他具备相同锁的线程调用notify()或notifyAll()方法后才会结束等待进入就绪状态</p>\n</li>\n<li><p>notify()</p>\n<p>调用该方法的线程会通知其他具备相同锁的线程结束等待，从而进入就绪状态，等到执行完同步代码块后才会释放同步锁，notify()方法本身是不会释放同步锁的，该方法一般写同步代码块最后面</p>\n</li>\n<li><p>使用ReentrantLock可重入锁实现线程间协作</p>\n<p>通过ReentrantLock来获取一个Condition对象，然后借助Condition对象中的await()&#x2F;signal()&#x2F;signalAll()三个方法</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>以上三个方法必须在lock()和unlock()两个方法之间</li>\n<li>方法必须有condition对象来进行调用</li>\n<li>多线程间的condition对象必须是同一个</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"七、线程池\"><a href=\"#七、线程池\" class=\"headerlink\" title=\"七、线程池\"></a>七、线程池</h3><p>​\t线程池(ThreadPool线程的第三种创建方式)</p>\n<ol>\n<li><p><strong>线程池的概念</strong></p>\n<p>用于创建和管理多个线程的容器对象，当我们的程序需要线程时可以直接从池中取出，当执行完任务后，将线程返回到池中，让线程得到复用，避免频繁的创建和销毁，从而节省系统的开销</p>\n</li>\n<li><p><strong>线程池的创建</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"type\">int</span> corePoolSize   核心线程数,</span><br><span class=\"line\">                <span class=\"type\">int</span> maximumPoolSize 最大线程数,</span><br><span class=\"line\">                <span class=\"type\">long</span> keepAliveTime 超时(空闲，活跃)时间,</span><br><span class=\"line\">                TimeUnit unit 时间单位,</span><br><span class=\"line\">                BlockingQueue&lt;Runnable&gt; workQueue 任务队列,</span><br><span class=\"line\">                ThreadFactory threadFactory 线程工厂,</span><br><span class=\"line\">    \t\t\tRejectedExecutionHandler handler 拒绝执行处理;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>拒绝策略</strong></p>\n<p>1、<strong>AbortPolicy</strong><br>   拒绝执行新的任务，并抛出RejectedExecutionException异常<br>2、<strong>CallerRunPolicy</strong><br>   如果线程池已关闭，直接丢弃该任务，<br>   如果线程池没有关闭，不会使用线程池中的线程，<br>   也不会将其加入到任务队列中，而是让当前线程直接来调用run()方法，<br>   相当于没有创建额外的线程<br>3、<strong>DiscardOldestPolicy</strong><br>   如果线程池已关闭，直接丢掉该任务<br>   入宫线程没有关闭，将任务队列存在最久的任务丢掉，<br>   并将新的任务加入到任务队列中<br>4、<strong>DiscardPolicy</strong><br>   直接丢掉新的任务，但是不会抛出异常</p>\n</li>\n<li><p>Java<strong>自带的线程池</strong></p>\n<ol>\n<li><p>创建单线程的线程池</p>\n<p>只有一个线程，不允许创建非核心线程      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建固定数量线程的线程池</p>\n<p>传入的参数既是核心线程数也是最大线程数，不允许创建非核心线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建可缓存线程池</p>\n<p>内部没有核心线程，所有的线程都是非核心线程<br>所有的非核心线程都是超过60s处于空闲状态就会被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建周期性线程池</p>\n<p>传入的参数为核心线程数，队列为延迟队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span>Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>线程池主要方法</p>\n<ol>\n<li><p><strong>execute</strong>(Ruunable task)</p>\n<p>将任务交给线程池来执行</p>\n<p>线程池会自动获取出空闲的线程来执行该任务</p>\n</li>\n<li><p><strong>allowCoreThreadTimeOut</strong>()</p>\n<p>允许核心线程超时</p>\n</li>\n<li><p><strong>es.shutdownNow</strong>();</p>\n<p>立即关闭，可能会导致线程池中还没有执行完毕</p>\n</li>\n<li><p><strong>es.shutdown</strong>();</p>\n<p>安全关闭，必须等待线程池中所有线程都执行完成任务后才会关闭</p>\n</li>\n<li><p><strong>es.schedule</strong>(Runnable command,long delay, TimeUnit unit);</p>\n<p>周期性线程池执行周期任务</p>\n</li>\n<li><p><strong>es.scheduleAtFixedRate</strong></p>\n<p>Runnable command, 要执行的任务<br>long initialDelay, 第一次执行任务的延迟时间<br>long period, 两次执行之间的间隔时间<br>TimeUnit unit 时间单位<br>任务的执行时间超过了间隔时间，那么在一次任务，执行完成后就会立即执行下一次任务如果没有超过间隔时间那么就会在指定间隔之后才会执行下一个任务</p>\n</li>\n<li><p><strong>es.scheduleWithFixedDelay</strong></p>\n<p>不管任务的执行时间是否超过间隔时间,必须等待本次任务执行完成后,再间隔指定时间才会去执行下一次的任务</p>\n</li>\n</ol>\n</li>\n<li><p><strong>Callable</strong></p>\n<p>实现Callable接口的实现类为线程要执行的任务</p>\n<p>Callable使用步骤</p>\n<ol>\n<li>写一个类实现Callable接口，并指定泛型，泛型为任务执行完成后需要得到的结果类型</li>\n<li>重写Call()方法，该方法所要执行的任务，相当于是Runnable中的run()方法</li>\n<li>通过线程来执行任务<ol>\n<li>创建Callable实现实例，并通过FutureTask来封装该实例</li>\n<li>创建线程来执行FutureTask来执行实例</li>\n<li>调用FutureTask的get()方法 来获取任务执行结果</li>\n</ol>\n</li>\n<li>通过线程池来执行任务<ol>\n<li>创建Callable实现实例，创建线程池</li>\n<li>调用线程池的submit()方法执行Callable任务实例，返回一个Future()</li>\n<li>调用Future类的get()方法来获取任务执行结果</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"八、线程内存模型\"><a href=\"#八、线程内存模型\" class=\"headerlink\" title=\"八、线程内存模型\"></a>八、线程内存模型</h3><h5 id=\"JMM-Java-Memory-Model\"><a href=\"#JMM-Java-Memory-Model\" class=\"headerlink\" title=\"JMM:Java Memory Model\"></a>JMM:Java Memory Model</h5><p>主要用于描述和定义Java程序中各种变量的访问和操作规则，以及在JVM中如何将变量存储到内存以及从内存读出的过程</p>\n<ol>\n<li><p>多线程访问共享变量的规则</p>\n<ol>\n<li>JVM会给每个线程更配一个自己独立的内存空间，同时也会有一个自己的主内存空间</li>\n<li>多线程间的共享变量会存在主内存空间</li>\n</ol>\n</li>\n<li><p>线程的特性</p>\n<ol>\n<li>原子性</li>\n<li>可见性</li>\n</ol>\n<p>JMM:Java Memory Model<br>      主要用于描述和定义Java程序中各种变量的访问和操作规则,<br>      以及在Jvm中如何将变量存储到内存以及从内存读出的过程</p>\n<pre><code>  1、多线程访问共享变量的规则\n     1&gt;Jvm会给每个线程分配一个自己独立的内存空间,\n       同时也会有一个自己的主内存空间\n     2&gt;多线程间的共享变量会存储在主内存空间\n     3&gt;线程对共享变量的操作,需要从\n       主内存中拷贝一份该变量的副本到自己独立的工作\n       内存中进行,修改完成后将该变量的值再重新拷贝到主内存中,\n       线程不能直接操作主内存的共享变量值\n     4&gt;不同线程之间无法直接访问其他线程工作内存中的变量,\n       线程间变量值的传递必须通过主内存来进行完成\n</code></pre>\n<p>​<br>​       2、线程的特性:<br>​           1&gt;原子性(不可分割)<br>​             一系列的操作要么都执行,要么都不执行,不可再分割,<br>​             比如从主内存中读取共享变量的值,在工作内存中修改后,<br>​             再刷新回主内存,这些操作不可分割,<br>​             线程与线程之间相互独立,在一个时间段内<br>​    只允许一个线程进入cpu执行任务操作共享变量,<br>​    synchronized同步锁和ReentrantLock可重入锁<br>​    都可以实现线程原子性<br>​<br>​           2&gt;可见性<br>​             1)一个线程对共享变量的操作,能够及时的被其他线程所看到<br>​             2)可见性实现原理<br>​                1)每次操作该变量时都会将主内存中<br>​      共享变量拷贝到工作内存<br>​    2)每次在工作内存中操作完该变量时,<br>​      都会把值同步到主内存中<br>​       3)Synchronized,ReentrantLock以及<br>​      volatile都可以实现线程可见性<br>​<br>​             3)synchronize实现可见性原理<br>​                1&gt;获取同步锁<br>​                2&gt;清空工作内存中的副本值<br>​                3&gt;从主内中拷贝共享变量的最新值到自己的工作内存中<br>​                4&gt;在工作内存中执行代码<br>​                5&gt;将更改之后共享变量的值刷新到主内存<br>​                6&gt;释放同步锁<br>​                7&gt;synchronized既能保证原子性也能保证可见性<br>​<br>​             4)volatile实现可见性原理<br>​                volatile只能保证共享变量的可见性,但不能保证原子性<br>​                当线程需要去修改volatile变量值:<br>​                1&gt;先从主内存中读取volatile共享变量的最新值到工作内存<br>​                2&gt;再操作工作内存volatile变量的副本值<br>​                3&gt;再将改变之后的副本值从工作内存刷新到主内存<br>​<br>​                 volatile使用场景:线程多次修改的共享值之间不存在依赖关系<br>​<br>​              5)synchronized和volatile区别<br>​                1&gt;volatile不需要加锁,比synchronized更加轻量级,<br>​                  不会阻塞线程<br>​                2&gt;synchronized既保证可见性又保证原子性,<br>​                  而volatile只保证了可见性,不保证原子性<br>​                3&gt;synchronized比validate使用场景更多,范围更广<br>​<br>           3&gt;有序性(非指令重排性):让JVM在解释执行字节码文件时,<br>       严格按照字节码中的顺序来执行指令,不要进行重排序</p>\n<p>  4、指令重排序<br>   1&gt;重排序概念<br>     代码的编写顺序和最终执行顺序不一致</p>\n<p>   2&gt;重排序目的<br>     编译器或处理器做优化,提高程序的执行性能,哪个指令先来,<br>     先执行哪个</p>\n<p>   2.1&gt;编译器优化重排序<br>     2.2&gt;处理器指令级并行重排序或内存系统的重排序<br>         源代</p>\n<p>2.1&gt;编译器优化重排序<br>     2.2&gt;处理器指令级并行重排序或内存系统的重排序<br>         源代码 -&gt; 编译器优化的重排 -&gt;<br>      指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p>\n<p>   3&gt;重排序导致后果<br>     3.1&gt;单线程重排序会遵循as-if-serial原则,<br>       也就是会考虑数据依赖问题,<br>       无论如何重排序,程序最终执行结果必须<br>       与代码顺序执行结果一致</p>\n<p>   3.2&gt;多线程并发情况下,指令重排序可能会导致<br>        最终结果与预期结果不一致</p>\n<p>   3.3&gt;synchronized和volatile都能禁止指令重排序<br>       volatile:通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化,<br>       volatile的写和读的时候，加入屏障，防止出现指令重排的</p>\n<pre><code> 线程A:\n int a = 10;\n int b = 20;\n \n 线程B:\n int c = a+b;\n   \n Object obj = new Object();\n 创建对象过程\n 1&gt;初始化一块内存空间\n 2&gt;给成员变量赋初始值\n 3&gt;将内存空间地址赋值给引用\n\n if(obj!=null)&#123;\n    //执行代码 \n &#125;\n</code></pre>\n</li>\n</ol>\n"},{"title":"面向对象","date":"2023-01-07T03:18:57.000Z","cover":"/img/images/computer3.jpg","_content":"\n## 面向对象\n\n#### 面向对象\n\n一、什么是面向对象\n\n​\toop: object oriented programming\n\n​\t人为抽象出来的一种编程模型，其本质是将一个复杂庞大的问题拆分为若干个小的问题，通过完成这些小的问题最终达到解决大问题的一种编程方式（分而治之）\n\n\n\n二、对象\n\n \t1. object对象，东西\n \t2. 一切客观存在的事物都是对象\n \t3. 对象的特点，每一个对象一定是独一无二存在的个体\n\n​\t\n\n三、类 Class\n\n1. 类是具有相同静态特征和相同动态行为的对象的集合\n\n2. 类是对象模板，对象是类的具体实例\n\n   日常生活中：先有对象后有类\n\n   程序代码中：先有类后有对象\n\n四、属性Field（成员属性，实例变量）\n\n1. 类中所有的对象所拥有的相同的静态特征（对象都有什么）\n2. 属性的位置：类的里面，其他方法的外面\n3. 如果在类中没有给属性赋值那么创建出来的对象属性会有默认值\n4. 通过引用名，属性名来对对象的属性值进行访问和修改\n\n\n\n五、方法（Method）函数\n\n1. 类中所有的对象所拥有的相同的动态行为（对象都能干什么）\n2. 对象的方法不能使用static进行修饰\n3. 通过引用名·方法名（参数列表）来对对象的方法进行调用\n\n六、引用\n\n1. 引用类型的变量，存储在栈内存中，用于保存堆内存中对象的地址值（地址哈希值）也就是通过引用可以指向一个对象\n2. 对象必须要通过引用才能进行操作，通过引用操作对象的属性和方法\n3. 可以多个引用指向同一个对象，但是一个引用不能同时指向多个对象\n4. 引用类型特殊值:null（空，不存在），任意类对象类型的引用都可以被赋值为null， 如果一个引用被赋值为null，那么通过该引用访问了对象的属性或调用了对象的方法就会报空指针异常\n\n七、构造方法Constructor（构造函数，构造器）\n\n1. 构造方法是用于创建对象的方法，在创建对象时自动调用\n2. 构造方法的特点\n   1. 构造方法没有返回值类型，也不能写void\n   2. 构造方法的名称必须和类名一致\n3. 如果自己没有在类中定义构造方法，当前类中会偶一个默认的无参构造方法，如果我们自己定义了带参数的构造方法，那么当前类中就不再生成默认无参构造方法，如果此时我们还需要通过无参构造方法创建对象，就需要手动定义\n4. 带参数的构造方法通常可以用于给对象的属性赋值\n5. 一个类中可以定义多个构造方法互为重载关系\n\n八、this.\n\n1. this用于指向当前对象，调用当前方法的对象或者当前正在创建的对象，只能用于构造方法和实例方法中\n\n2. this.属性名操作当前对象的属性\n\n   1. 当局部变量和成员变量属性重名时，以局部变量为优先，此时必须通过this.属性名来进行区分，访问当前对象属性\n   2. 如果在方法中没有和成员变量重名的局部变量，this.可以省略不写，属性前面默认会有this.\n   3. 局部变量\n      1. 方法的形参\n      2. 定义在方法内部的变量范围为当前方法的内部，离开方法就回收了\n\n3. this(参数列表)\n\n   1. 调用本类其他的构造方法，注意此调用只能放在构造方法的第一行具体调用那一个构造方法由参数来决定\n\n4. this.方法名（参数列表）\n\n   在实例方法中调用本类其他的实例方法，默认就是通过this,来进行调用的，this可以省略不写\n\n九、权限访问修饰符\n\n主要用于修饰类，方法（所有的方法），成员变量（属性）用于限制他们在哪个范围内可见\n\n1. public\n\n   公开的，当前项目下任意地方都可以访问\n\n2. protected\n\n   受保护的，只能在当前包或不同包的子类中访问\n\n3. 默认的(不写)\n\n   只能在当前包下面访问\n\n4. private\n\n   私有的，只能在当前类中访问\n\n注意：\n\n1. 权限访问修饰符不能用于修饰局部变量，因为局部变量的范围只在当前方法内部有效\n2. 修饰外部类时，只能使用public或默认修饰修饰\n3. 在一个类文件可以同时定义多个类，但是只能有一个类是public修饰的，其余为默认修饰符，并且public修饰的类必须与源文件类名相同\n\n十、三大特性\n\n1. 封装\n\n   使用类的结构将属性数据和方法行为组织起来（装），可以实现隐藏具体的实现细节，防止外界随意访问和修改类中的数据（封装），增强数据的安全性。在对外界提供一个公开的访问方式\n\n   1. 属性私有化\n   \n      在属性前面加上private修饰符，防止类中的属性数据被外界随意访问修改\n   \n   2. 方法公开\n   \n      提供公开的setXxx方法\n   \n      提供公开的getXxx方法\n   \n2. 继承（extends）\n\n   1. 继承的目的\n\n      继承是为了实现代码的复用，在分类中定义的属性和方法可以直接被子类继承\n      \n   2. 继承原则\n\n      1. 子类使用exrends关键字来继承父类fulei\n      2. 单继承：一个子类只能继承一个父类，但是一个父类可以有多个子类\n      3. 子类会继承父类中所有的属性，私有属性和方法也可以被子类所继承，但是在外界不呢个直接访问或调用，父类在子类的内存地址上\n\n   3. super关键字\n\n   每个子类的每个构造方法第一行默认都会有一个super（）去调用父类中的无参构造方法因此创建子类对象时一定会先去创建父类对象\n\n   如果父类没有无参构造方法，那么在每个子类中的每个构造方法第一行必须显示的通过super参数列表去调用父类中带参数的构造方法从而覆盖默认的super（），就不再去调用父类中的无参构造方法参数值时给创建出来的父类对象属性赋值了，但是子类对象会共用父类对象的属性，所以也相当于是给于类对象的属性赋值\n\n   4. super的三种用法\n\n      1. super参数列表\n\n         调用父类中的构造方法，必须放在子类的构造方法的第一行\n\n      2. super.属性名，访问父类对象的属性\n\n      3. super.方法名，调用父类的实例方法\n\n   5. 重写Override\n\n      1. 重写的目的\n\n         子类从父类中继承的方法不满足子类的需求，需要在子类中对该方法进行改写和扩展\n\n      2. 重写的规则\n\n         1. 重写的方法必须和父类中方法的方法名和参数列表一致： 方法签名：方法名+参数列表\n         2. 重写的方法返回值类型必须和父类中方法一致或者父类中方法返回值类型的子类型、\n         3. 重写的方法修饰符必须和父类中方法一致或者比父类中方法修饰范围更大\n         4. 重写的方法不能比父类中的方法抛出更多更大的异常；\n         5. 重写的方法上面建议加上@Override注解，用于检测该方法是否正确重写了\n\n   6. 重载Overload 和重写Override有什么区别\n\n      1. 重载是发生在同一个类中，多个方法之间同名不同参\n      2. 重写是发生在父类和子类之间，子类对父类中的方法进行改写，要求方法名和参数列表一致\n\n3. 多态\n\n   多态指允许不同类的对象对同一消息做出响应即同一消息可以根据发送对象的不同而采用多种不同的行为方式\n\n   1. 什么是多态\n\n      同一行为会因为执行对象的不同而产生不一样的结果，是对象多种表现形式的体现\n\n   2. 多态存在的三个前提条件\n\n      1. 继承\n\n      2. 方法重写\n\n      3. 父类型引用可以指向子类型的对象\n\n         在编译期间，引用是属于父类型的，在运行期间，会去调用子类中重写的方法。\n\n         在编译期间，子类对象的引用是属于父类类型，只能调用在父类中已经定义过的方法，而不能调用子类中所持有的方法\n\n   3. 类型转换\n\n      1. 子类型转父类型\n\n         向上类型转换，隐式类型转换，自动类型转换\n\n         在编译期间和运行期间都不会报错，但是转成父类型后只能调用父类中已定义的方法\n\n      2. 父类型转子类型\n\n         向下类型转换，显式类型转换，强转类型转换\n\n         在编译期间不会报错，在运行期间有可能会报ClassCastException类型转换异常，所以在强转之前需要通过instanceof关键字来进行判断\n\n   4. instanceof关键字\n\n      判断父类类型引用所指向的对象，是否属于子类类型，而不是判断引用本身的类型\n\n      ```java\n      Animal animal = new Dog();\n      boolean f = animal instanceof Dog;\n      if(f){\n      \tSystem.out.println(\"对象是Dog类型，可以强转\")\n      }else{\n      \tSystem.out.println(\"对象不是Dog类型,不能强转\")\n      }\n      ```\n\n4. static\n\n   静态的，唯一的，属于类的，与类一起加载，被存储在方法区，被类中所有对象所共享的\n\n   1. 修饰类\n\n      只能修饰内部类，不能修饰外部类\n\n   2. 修饰变量\n\n      类加载时初始化，只会初始化一次\n\n      只能修饰静态成员变量，不能修饰局部变量，非静态成员变量创建对象时初始化，每创建一个对象就会初始化一次\n\n      1. 只能用于修饰成员变量静态成员变量，类变量属于类的，被类中所有的对象共享类加载时初始化，只会被初始化一次\n      2. 静态变量可以直接通过类名.变量名的方式来进行访问，在同一个类中如果没有同名的局部变量，那么类名可以省略不写\n      3. 静态变量也可以通过对象来进行访问，但是不建议，一个对象对静态变量的修改会影响到其他对象的访问\n   \n   3. 修饰方法\n   \n      1. 静态方法：属于类的，被类中所有的对象共享，类加载时初始化只会初始化一次\n      2. 静态方法可以直接通过类名来进行调用，在同一个类中调用可以省略不写\n      3. 静态方法也可以通过对象来进行调用，但是不建议\n      4. 在同一个类中，静态方法可以直接访问，静态变量和调用静态方法，默认省略类名\n      5. 静态方法中不能直接访问实例变量和调用实例方法，因为静态方法中不能出现this如果要访问实例变量和调用实例方法必须要先创建对象，然后通过对象来访问和调用\n   \n      在静态方法中不能直接访问实例变量，因为实例变量默认通过this来进行访问，而静态方法中不能出现this，（this是指向当前对象，而静态方法可以通过类名来进行调用可以不通过对象来调用，类加载时机比创建对象要早，静态方法是随着类一起加载的，所以类加载时没有对象，this又必须要指向一个对象）\n   \n      访问实例变量必须要先创建实例对象\n   \n      在实例方法中可以直接调用实例方法和静态方法\n   \n   4. 修饰代码块\n   \n      1. 属于类的，类加载时初始化，只会初始化一次\n      2. 一个类中可以同时定义多个静态代码块，类加载时从上往下依次初始化\n      3. 类什么时候加载\n         1. 访问了类中的静态变量\n         2. 调用了类中静态方法\n         3. 创建了该类对象\n         4. 类中有main（）方法，执行了main()方法\n         5. 反射加载类\n   \n5. **Final修饰符**\n\n   1. final修饰类不可被继承\n   2. final修饰变量，只能被赋一次值，不可再更改，也就是常量，常量名建议全大写\n      1. 修饰成员变量，要么在定义时赋值，要么在定义时赋值，要么在构造方法中赋值，后续不可再更改这个值\n      2. 修饰局部变量，要么再定义时赋值，要么先定义后赋值，但是只能赋一次值，后续不可再更改，如果final修饰形参那么是在方法调用过程中赋值，在方法里面不能再更改该形参值\n      3. 修饰基本类型，值不可变，修饰引用类型地址值不可变，对象属性除去final修饰的属性值可变\n   3. final修饰方法，方法可以被继承，不能被重写\n   \n6. **抽象类**\n\n   1. 什么是抽象类\n\n      当一个类中的实例不是具体存在的个体，没有足够的详细信息来描述这个类的对象时，就把这个类定义为抽象类，抽象类一般用于充当父类\n\n   2. 抽象类的应用\n\n      1. 抽象类使用abstract来进行定义\n      2. 抽象类中可以定义实例变量，静态变量实例方法，静态方法\n      3. 抽象类中可以定义构造方法，但是不能创建对象，构造方法的作用是提供给予子类构造方法进行调用赋值的\n\n   3. 抽象方法\n\n      1. 抽象方法使用abstract关键字来进行定义\n      2. 抽象方法只有方法声明没有方法体（没有后面的大括号）\n      3. 有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法\n      4. 子类继承抽象类后，必须重写抽象类中所有的抽象方法，否则子类也必须为一个抽象类\n\n7. **接口interface**\n\n   1. 接口是什么\n\n      制定一个统一的标准和规范，其目的是为了实现程序解耦合（高内聚，低耦合）\n      \n   2. 接口的使用\n   \n      1. 接口使用interface关键字进行定义\n      2. 接口中不能定义构造方法，也不能创建对象\n      3. JDK1.7之前接口中只能定义静态常量和抽象方法，静态常量默认使用public static final修饰，抽象方法默认使用public abstract修饰\n      4. 一个实现类可以通过implement关键字实现一个接口，继承接口中所有的静态常量，必须要重写接口中所有的抽象方法\n      5. 一个实现类也可以同时实现多个接口，之间使用逗号隔开必须要重写所有接口中的所有抽象方法（多实现）\n      6. 接口和接口之间可以通过extends关键字互相继承，一个子接口可以同时继承多个父接口，拥有所有父接口中的静态常量和抽象方法（多层继承）\n      7. 一个类可以在继承一个父类的同时去实现多个接口\n      8. JDK1.8之后接口新特性\n         1. 静态方法：直接通过接口名来调用，不能被实现类所继承\n         2. 默认方法：在方法前面加上default关键字,实现类可以选择默认继承或重写\n   \n8. **四个内部类**\n\n   1. 实例内部类\n\n      1. 位置：类的里面，其他方法的外面，没有static修饰\n\n      2. 特点：可以直接访问外部类中所有成员变量\n\n      3. 对象创建：必须要先创建外部类对象\n\n         > Outer.Inner inner = new Outer().new Inner();\n\n   2. 静态内部类\n   \n      1. 位置：类的里面，其他方法的外面，有static修饰\n   \n      2. 特点：只能直接访问外部类中静态成员变量\n   \n      3. 对象创建：不依赖于外部类\n   \n         > 导包\n         >\n         > Inner inner = new Inner();\n   \n   3. 局部内部类\n   \n      1. 位置：在方法里面定义的类\n      2. 特点：能访问外部类中定义的所有成员变量，也能访问定义他的方法中的局部变量\n      3. 对象创建：只能在当前方法内部创建对象\n   \n   4. 匿名内部类\n   \n      1. 位置：可以在方法里面定义，也可以在类里面方法外面定义\n   \n      2. 特点：没有类的声明，只有类体\n   \n      3. 对象创建：必须依赖于其父类来创建匿名内部类对象\n   \n         > 语法：父类型 引用  = new 父类型（）{\n         >\n         > ​\t匿名内部类类体，重写方法\n         >\n         > }\n         >\n         > 父类型可以使普通类，抽象类或接口\n   \n         注意：\n   \n         1. 内部类不一定是普通类，也可以是抽象类或接口\n         2. 内部类可以使用任意的权限访问修饰符\n   \n   5. lambda表达式\n   \n      1. JDK1.8之后新增的语法特性，主要用于简化部分匿名内部类的写法\n   \n      2. lambda表达式要求匿名内部类的父类必须是一个接口，而且接口的中的抽象方法有且仅有一个\n   \n      3. 添加注解查看接口是否lambda表达式条件————@Functional Interface\n   \n         ```java\n         lambda表达式的语法：\n             （需要被重写的参数列表） - >  {重写过后的方法体}\n         ```\n   \n9. **类与类之间的关系**\n\n   1. 依赖关系（use a）\n   \n   2. 关联关系（has a）\n   \n      一个类以成员变量的形式出现在另一个类中，这两个类之间平等关系\n   \n      1. 单向关联\n      2. 双向关联\n   \n   3. 聚合关系（has a）\n   \n      一个类以成员变量的形式出现在另外一个类中，但是这两个类之间有整体和局部的关系\n   \n   4. 组合关系（contain a）\n   \n      一个类以成员变量的形式出现在另外一个类中，一个类的存在必须要依赖于另外一个类，这两个类的生命周期是相互关联的\n   \n   5. 继承关系（is a）\n   \n      一个子类继承一个父类\n   \n   6. 实现关系（like a）\n   \n      一个实现类实现一个接口\n\n","source":"_posts/面向对象.md","raw":"---\ntitle: 面向对象\ndate: 2023-01-07 11:18:57\ntags: Java\ncategories: Java\ncover: /img/images/computer3.jpg\n---\n\n## 面向对象\n\n#### 面向对象\n\n一、什么是面向对象\n\n​\toop: object oriented programming\n\n​\t人为抽象出来的一种编程模型，其本质是将一个复杂庞大的问题拆分为若干个小的问题，通过完成这些小的问题最终达到解决大问题的一种编程方式（分而治之）\n\n\n\n二、对象\n\n \t1. object对象，东西\n \t2. 一切客观存在的事物都是对象\n \t3. 对象的特点，每一个对象一定是独一无二存在的个体\n\n​\t\n\n三、类 Class\n\n1. 类是具有相同静态特征和相同动态行为的对象的集合\n\n2. 类是对象模板，对象是类的具体实例\n\n   日常生活中：先有对象后有类\n\n   程序代码中：先有类后有对象\n\n四、属性Field（成员属性，实例变量）\n\n1. 类中所有的对象所拥有的相同的静态特征（对象都有什么）\n2. 属性的位置：类的里面，其他方法的外面\n3. 如果在类中没有给属性赋值那么创建出来的对象属性会有默认值\n4. 通过引用名，属性名来对对象的属性值进行访问和修改\n\n\n\n五、方法（Method）函数\n\n1. 类中所有的对象所拥有的相同的动态行为（对象都能干什么）\n2. 对象的方法不能使用static进行修饰\n3. 通过引用名·方法名（参数列表）来对对象的方法进行调用\n\n六、引用\n\n1. 引用类型的变量，存储在栈内存中，用于保存堆内存中对象的地址值（地址哈希值）也就是通过引用可以指向一个对象\n2. 对象必须要通过引用才能进行操作，通过引用操作对象的属性和方法\n3. 可以多个引用指向同一个对象，但是一个引用不能同时指向多个对象\n4. 引用类型特殊值:null（空，不存在），任意类对象类型的引用都可以被赋值为null， 如果一个引用被赋值为null，那么通过该引用访问了对象的属性或调用了对象的方法就会报空指针异常\n\n七、构造方法Constructor（构造函数，构造器）\n\n1. 构造方法是用于创建对象的方法，在创建对象时自动调用\n2. 构造方法的特点\n   1. 构造方法没有返回值类型，也不能写void\n   2. 构造方法的名称必须和类名一致\n3. 如果自己没有在类中定义构造方法，当前类中会偶一个默认的无参构造方法，如果我们自己定义了带参数的构造方法，那么当前类中就不再生成默认无参构造方法，如果此时我们还需要通过无参构造方法创建对象，就需要手动定义\n4. 带参数的构造方法通常可以用于给对象的属性赋值\n5. 一个类中可以定义多个构造方法互为重载关系\n\n八、this.\n\n1. this用于指向当前对象，调用当前方法的对象或者当前正在创建的对象，只能用于构造方法和实例方法中\n\n2. this.属性名操作当前对象的属性\n\n   1. 当局部变量和成员变量属性重名时，以局部变量为优先，此时必须通过this.属性名来进行区分，访问当前对象属性\n   2. 如果在方法中没有和成员变量重名的局部变量，this.可以省略不写，属性前面默认会有this.\n   3. 局部变量\n      1. 方法的形参\n      2. 定义在方法内部的变量范围为当前方法的内部，离开方法就回收了\n\n3. this(参数列表)\n\n   1. 调用本类其他的构造方法，注意此调用只能放在构造方法的第一行具体调用那一个构造方法由参数来决定\n\n4. this.方法名（参数列表）\n\n   在实例方法中调用本类其他的实例方法，默认就是通过this,来进行调用的，this可以省略不写\n\n九、权限访问修饰符\n\n主要用于修饰类，方法（所有的方法），成员变量（属性）用于限制他们在哪个范围内可见\n\n1. public\n\n   公开的，当前项目下任意地方都可以访问\n\n2. protected\n\n   受保护的，只能在当前包或不同包的子类中访问\n\n3. 默认的(不写)\n\n   只能在当前包下面访问\n\n4. private\n\n   私有的，只能在当前类中访问\n\n注意：\n\n1. 权限访问修饰符不能用于修饰局部变量，因为局部变量的范围只在当前方法内部有效\n2. 修饰外部类时，只能使用public或默认修饰修饰\n3. 在一个类文件可以同时定义多个类，但是只能有一个类是public修饰的，其余为默认修饰符，并且public修饰的类必须与源文件类名相同\n\n十、三大特性\n\n1. 封装\n\n   使用类的结构将属性数据和方法行为组织起来（装），可以实现隐藏具体的实现细节，防止外界随意访问和修改类中的数据（封装），增强数据的安全性。在对外界提供一个公开的访问方式\n\n   1. 属性私有化\n   \n      在属性前面加上private修饰符，防止类中的属性数据被外界随意访问修改\n   \n   2. 方法公开\n   \n      提供公开的setXxx方法\n   \n      提供公开的getXxx方法\n   \n2. 继承（extends）\n\n   1. 继承的目的\n\n      继承是为了实现代码的复用，在分类中定义的属性和方法可以直接被子类继承\n      \n   2. 继承原则\n\n      1. 子类使用exrends关键字来继承父类fulei\n      2. 单继承：一个子类只能继承一个父类，但是一个父类可以有多个子类\n      3. 子类会继承父类中所有的属性，私有属性和方法也可以被子类所继承，但是在外界不呢个直接访问或调用，父类在子类的内存地址上\n\n   3. super关键字\n\n   每个子类的每个构造方法第一行默认都会有一个super（）去调用父类中的无参构造方法因此创建子类对象时一定会先去创建父类对象\n\n   如果父类没有无参构造方法，那么在每个子类中的每个构造方法第一行必须显示的通过super参数列表去调用父类中带参数的构造方法从而覆盖默认的super（），就不再去调用父类中的无参构造方法参数值时给创建出来的父类对象属性赋值了，但是子类对象会共用父类对象的属性，所以也相当于是给于类对象的属性赋值\n\n   4. super的三种用法\n\n      1. super参数列表\n\n         调用父类中的构造方法，必须放在子类的构造方法的第一行\n\n      2. super.属性名，访问父类对象的属性\n\n      3. super.方法名，调用父类的实例方法\n\n   5. 重写Override\n\n      1. 重写的目的\n\n         子类从父类中继承的方法不满足子类的需求，需要在子类中对该方法进行改写和扩展\n\n      2. 重写的规则\n\n         1. 重写的方法必须和父类中方法的方法名和参数列表一致： 方法签名：方法名+参数列表\n         2. 重写的方法返回值类型必须和父类中方法一致或者父类中方法返回值类型的子类型、\n         3. 重写的方法修饰符必须和父类中方法一致或者比父类中方法修饰范围更大\n         4. 重写的方法不能比父类中的方法抛出更多更大的异常；\n         5. 重写的方法上面建议加上@Override注解，用于检测该方法是否正确重写了\n\n   6. 重载Overload 和重写Override有什么区别\n\n      1. 重载是发生在同一个类中，多个方法之间同名不同参\n      2. 重写是发生在父类和子类之间，子类对父类中的方法进行改写，要求方法名和参数列表一致\n\n3. 多态\n\n   多态指允许不同类的对象对同一消息做出响应即同一消息可以根据发送对象的不同而采用多种不同的行为方式\n\n   1. 什么是多态\n\n      同一行为会因为执行对象的不同而产生不一样的结果，是对象多种表现形式的体现\n\n   2. 多态存在的三个前提条件\n\n      1. 继承\n\n      2. 方法重写\n\n      3. 父类型引用可以指向子类型的对象\n\n         在编译期间，引用是属于父类型的，在运行期间，会去调用子类中重写的方法。\n\n         在编译期间，子类对象的引用是属于父类类型，只能调用在父类中已经定义过的方法，而不能调用子类中所持有的方法\n\n   3. 类型转换\n\n      1. 子类型转父类型\n\n         向上类型转换，隐式类型转换，自动类型转换\n\n         在编译期间和运行期间都不会报错，但是转成父类型后只能调用父类中已定义的方法\n\n      2. 父类型转子类型\n\n         向下类型转换，显式类型转换，强转类型转换\n\n         在编译期间不会报错，在运行期间有可能会报ClassCastException类型转换异常，所以在强转之前需要通过instanceof关键字来进行判断\n\n   4. instanceof关键字\n\n      判断父类类型引用所指向的对象，是否属于子类类型，而不是判断引用本身的类型\n\n      ```java\n      Animal animal = new Dog();\n      boolean f = animal instanceof Dog;\n      if(f){\n      \tSystem.out.println(\"对象是Dog类型，可以强转\")\n      }else{\n      \tSystem.out.println(\"对象不是Dog类型,不能强转\")\n      }\n      ```\n\n4. static\n\n   静态的，唯一的，属于类的，与类一起加载，被存储在方法区，被类中所有对象所共享的\n\n   1. 修饰类\n\n      只能修饰内部类，不能修饰外部类\n\n   2. 修饰变量\n\n      类加载时初始化，只会初始化一次\n\n      只能修饰静态成员变量，不能修饰局部变量，非静态成员变量创建对象时初始化，每创建一个对象就会初始化一次\n\n      1. 只能用于修饰成员变量静态成员变量，类变量属于类的，被类中所有的对象共享类加载时初始化，只会被初始化一次\n      2. 静态变量可以直接通过类名.变量名的方式来进行访问，在同一个类中如果没有同名的局部变量，那么类名可以省略不写\n      3. 静态变量也可以通过对象来进行访问，但是不建议，一个对象对静态变量的修改会影响到其他对象的访问\n   \n   3. 修饰方法\n   \n      1. 静态方法：属于类的，被类中所有的对象共享，类加载时初始化只会初始化一次\n      2. 静态方法可以直接通过类名来进行调用，在同一个类中调用可以省略不写\n      3. 静态方法也可以通过对象来进行调用，但是不建议\n      4. 在同一个类中，静态方法可以直接访问，静态变量和调用静态方法，默认省略类名\n      5. 静态方法中不能直接访问实例变量和调用实例方法，因为静态方法中不能出现this如果要访问实例变量和调用实例方法必须要先创建对象，然后通过对象来访问和调用\n   \n      在静态方法中不能直接访问实例变量，因为实例变量默认通过this来进行访问，而静态方法中不能出现this，（this是指向当前对象，而静态方法可以通过类名来进行调用可以不通过对象来调用，类加载时机比创建对象要早，静态方法是随着类一起加载的，所以类加载时没有对象，this又必须要指向一个对象）\n   \n      访问实例变量必须要先创建实例对象\n   \n      在实例方法中可以直接调用实例方法和静态方法\n   \n   4. 修饰代码块\n   \n      1. 属于类的，类加载时初始化，只会初始化一次\n      2. 一个类中可以同时定义多个静态代码块，类加载时从上往下依次初始化\n      3. 类什么时候加载\n         1. 访问了类中的静态变量\n         2. 调用了类中静态方法\n         3. 创建了该类对象\n         4. 类中有main（）方法，执行了main()方法\n         5. 反射加载类\n   \n5. **Final修饰符**\n\n   1. final修饰类不可被继承\n   2. final修饰变量，只能被赋一次值，不可再更改，也就是常量，常量名建议全大写\n      1. 修饰成员变量，要么在定义时赋值，要么在定义时赋值，要么在构造方法中赋值，后续不可再更改这个值\n      2. 修饰局部变量，要么再定义时赋值，要么先定义后赋值，但是只能赋一次值，后续不可再更改，如果final修饰形参那么是在方法调用过程中赋值，在方法里面不能再更改该形参值\n      3. 修饰基本类型，值不可变，修饰引用类型地址值不可变，对象属性除去final修饰的属性值可变\n   3. final修饰方法，方法可以被继承，不能被重写\n   \n6. **抽象类**\n\n   1. 什么是抽象类\n\n      当一个类中的实例不是具体存在的个体，没有足够的详细信息来描述这个类的对象时，就把这个类定义为抽象类，抽象类一般用于充当父类\n\n   2. 抽象类的应用\n\n      1. 抽象类使用abstract来进行定义\n      2. 抽象类中可以定义实例变量，静态变量实例方法，静态方法\n      3. 抽象类中可以定义构造方法，但是不能创建对象，构造方法的作用是提供给予子类构造方法进行调用赋值的\n\n   3. 抽象方法\n\n      1. 抽象方法使用abstract关键字来进行定义\n      2. 抽象方法只有方法声明没有方法体（没有后面的大括号）\n      3. 有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法\n      4. 子类继承抽象类后，必须重写抽象类中所有的抽象方法，否则子类也必须为一个抽象类\n\n7. **接口interface**\n\n   1. 接口是什么\n\n      制定一个统一的标准和规范，其目的是为了实现程序解耦合（高内聚，低耦合）\n      \n   2. 接口的使用\n   \n      1. 接口使用interface关键字进行定义\n      2. 接口中不能定义构造方法，也不能创建对象\n      3. JDK1.7之前接口中只能定义静态常量和抽象方法，静态常量默认使用public static final修饰，抽象方法默认使用public abstract修饰\n      4. 一个实现类可以通过implement关键字实现一个接口，继承接口中所有的静态常量，必须要重写接口中所有的抽象方法\n      5. 一个实现类也可以同时实现多个接口，之间使用逗号隔开必须要重写所有接口中的所有抽象方法（多实现）\n      6. 接口和接口之间可以通过extends关键字互相继承，一个子接口可以同时继承多个父接口，拥有所有父接口中的静态常量和抽象方法（多层继承）\n      7. 一个类可以在继承一个父类的同时去实现多个接口\n      8. JDK1.8之后接口新特性\n         1. 静态方法：直接通过接口名来调用，不能被实现类所继承\n         2. 默认方法：在方法前面加上default关键字,实现类可以选择默认继承或重写\n   \n8. **四个内部类**\n\n   1. 实例内部类\n\n      1. 位置：类的里面，其他方法的外面，没有static修饰\n\n      2. 特点：可以直接访问外部类中所有成员变量\n\n      3. 对象创建：必须要先创建外部类对象\n\n         > Outer.Inner inner = new Outer().new Inner();\n\n   2. 静态内部类\n   \n      1. 位置：类的里面，其他方法的外面，有static修饰\n   \n      2. 特点：只能直接访问外部类中静态成员变量\n   \n      3. 对象创建：不依赖于外部类\n   \n         > 导包\n         >\n         > Inner inner = new Inner();\n   \n   3. 局部内部类\n   \n      1. 位置：在方法里面定义的类\n      2. 特点：能访问外部类中定义的所有成员变量，也能访问定义他的方法中的局部变量\n      3. 对象创建：只能在当前方法内部创建对象\n   \n   4. 匿名内部类\n   \n      1. 位置：可以在方法里面定义，也可以在类里面方法外面定义\n   \n      2. 特点：没有类的声明，只有类体\n   \n      3. 对象创建：必须依赖于其父类来创建匿名内部类对象\n   \n         > 语法：父类型 引用  = new 父类型（）{\n         >\n         > ​\t匿名内部类类体，重写方法\n         >\n         > }\n         >\n         > 父类型可以使普通类，抽象类或接口\n   \n         注意：\n   \n         1. 内部类不一定是普通类，也可以是抽象类或接口\n         2. 内部类可以使用任意的权限访问修饰符\n   \n   5. lambda表达式\n   \n      1. JDK1.8之后新增的语法特性，主要用于简化部分匿名内部类的写法\n   \n      2. lambda表达式要求匿名内部类的父类必须是一个接口，而且接口的中的抽象方法有且仅有一个\n   \n      3. 添加注解查看接口是否lambda表达式条件————@Functional Interface\n   \n         ```java\n         lambda表达式的语法：\n             （需要被重写的参数列表） - >  {重写过后的方法体}\n         ```\n   \n9. **类与类之间的关系**\n\n   1. 依赖关系（use a）\n   \n   2. 关联关系（has a）\n   \n      一个类以成员变量的形式出现在另一个类中，这两个类之间平等关系\n   \n      1. 单向关联\n      2. 双向关联\n   \n   3. 聚合关系（has a）\n   \n      一个类以成员变量的形式出现在另外一个类中，但是这两个类之间有整体和局部的关系\n   \n   4. 组合关系（contain a）\n   \n      一个类以成员变量的形式出现在另外一个类中，一个类的存在必须要依赖于另外一个类，这两个类的生命周期是相互关联的\n   \n   5. 继承关系（is a）\n   \n      一个子类继承一个父类\n   \n   6. 实现关系（like a）\n   \n      一个实现类实现一个接口\n\n","slug":"面向对象","published":1,"updated":"2023-08-10T09:48:22.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll54pwak0030fswo4blq2uq9","content":"<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h4 id=\"面向对象-1\"><a href=\"#面向对象-1\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、什么是面向对象</p>\n<p>​\toop: object oriented programming</p>\n<p>​\t人为抽象出来的一种编程模型，其本质是将一个复杂庞大的问题拆分为若干个小的问题，通过完成这些小的问题最终达到解决大问题的一种编程方式（分而治之）</p>\n<p>二、对象</p>\n<pre><code> 1. object对象，东西\n 2. 一切客观存在的事物都是对象\n 3. 对象的特点，每一个对象一定是独一无二存在的个体\n</code></pre>\n<p>​\t</p>\n<p>三、类 Class</p>\n<ol>\n<li><p>类是具有相同静态特征和相同动态行为的对象的集合</p>\n</li>\n<li><p>类是对象模板，对象是类的具体实例</p>\n<p>日常生活中：先有对象后有类</p>\n<p>程序代码中：先有类后有对象</p>\n</li>\n</ol>\n<p>四、属性Field（成员属性，实例变量）</p>\n<ol>\n<li>类中所有的对象所拥有的相同的静态特征（对象都有什么）</li>\n<li>属性的位置：类的里面，其他方法的外面</li>\n<li>如果在类中没有给属性赋值那么创建出来的对象属性会有默认值</li>\n<li>通过引用名，属性名来对对象的属性值进行访问和修改</li>\n</ol>\n<p>五、方法（Method）函数</p>\n<ol>\n<li>类中所有的对象所拥有的相同的动态行为（对象都能干什么）</li>\n<li>对象的方法不能使用static进行修饰</li>\n<li>通过引用名·方法名（参数列表）来对对象的方法进行调用</li>\n</ol>\n<p>六、引用</p>\n<ol>\n<li>引用类型的变量，存储在栈内存中，用于保存堆内存中对象的地址值（地址哈希值）也就是通过引用可以指向一个对象</li>\n<li>对象必须要通过引用才能进行操作，通过引用操作对象的属性和方法</li>\n<li>可以多个引用指向同一个对象，但是一个引用不能同时指向多个对象</li>\n<li>引用类型特殊值:null（空，不存在），任意类对象类型的引用都可以被赋值为null， 如果一个引用被赋值为null，那么通过该引用访问了对象的属性或调用了对象的方法就会报空指针异常</li>\n</ol>\n<p>七、构造方法Constructor（构造函数，构造器）</p>\n<ol>\n<li>构造方法是用于创建对象的方法，在创建对象时自动调用</li>\n<li>构造方法的特点<ol>\n<li>构造方法没有返回值类型，也不能写void</li>\n<li>构造方法的名称必须和类名一致</li>\n</ol>\n</li>\n<li>如果自己没有在类中定义构造方法，当前类中会偶一个默认的无参构造方法，如果我们自己定义了带参数的构造方法，那么当前类中就不再生成默认无参构造方法，如果此时我们还需要通过无参构造方法创建对象，就需要手动定义</li>\n<li>带参数的构造方法通常可以用于给对象的属性赋值</li>\n<li>一个类中可以定义多个构造方法互为重载关系</li>\n</ol>\n<p>八、this.</p>\n<ol>\n<li><p>this用于指向当前对象，调用当前方法的对象或者当前正在创建的对象，只能用于构造方法和实例方法中</p>\n</li>\n<li><p>this.属性名操作当前对象的属性</p>\n<ol>\n<li>当局部变量和成员变量属性重名时，以局部变量为优先，此时必须通过this.属性名来进行区分，访问当前对象属性</li>\n<li>如果在方法中没有和成员变量重名的局部变量，this.可以省略不写，属性前面默认会有this.</li>\n<li>局部变量<ol>\n<li>方法的形参</li>\n<li>定义在方法内部的变量范围为当前方法的内部，离开方法就回收了</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>this(参数列表)</p>\n<ol>\n<li>调用本类其他的构造方法，注意此调用只能放在构造方法的第一行具体调用那一个构造方法由参数来决定</li>\n</ol>\n</li>\n<li><p>this.方法名（参数列表）</p>\n<p>在实例方法中调用本类其他的实例方法，默认就是通过this,来进行调用的，this可以省略不写</p>\n</li>\n</ol>\n<p>九、权限访问修饰符</p>\n<p>主要用于修饰类，方法（所有的方法），成员变量（属性）用于限制他们在哪个范围内可见</p>\n<ol>\n<li><p>public</p>\n<p>公开的，当前项目下任意地方都可以访问</p>\n</li>\n<li><p>protected</p>\n<p>受保护的，只能在当前包或不同包的子类中访问</p>\n</li>\n<li><p>默认的(不写)</p>\n<p>只能在当前包下面访问</p>\n</li>\n<li><p>private</p>\n<p>私有的，只能在当前类中访问</p>\n</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>权限访问修饰符不能用于修饰局部变量，因为局部变量的范围只在当前方法内部有效</li>\n<li>修饰外部类时，只能使用public或默认修饰修饰</li>\n<li>在一个类文件可以同时定义多个类，但是只能有一个类是public修饰的，其余为默认修饰符，并且public修饰的类必须与源文件类名相同</li>\n</ol>\n<p>十、三大特性</p>\n<ol>\n<li><p>封装</p>\n<p>使用类的结构将属性数据和方法行为组织起来（装），可以实现隐藏具体的实现细节，防止外界随意访问和修改类中的数据（封装），增强数据的安全性。在对外界提供一个公开的访问方式</p>\n<ol>\n<li><p>属性私有化</p>\n<p>在属性前面加上private修饰符，防止类中的属性数据被外界随意访问修改</p>\n</li>\n<li><p>方法公开</p>\n<p>提供公开的setXxx方法</p>\n<p>提供公开的getXxx方法</p>\n</li>\n</ol>\n</li>\n<li><p>继承（extends）</p>\n<ol>\n<li><p>继承的目的</p>\n<p>继承是为了实现代码的复用，在分类中定义的属性和方法可以直接被子类继承</p>\n</li>\n<li><p>继承原则</p>\n<ol>\n<li>子类使用exrends关键字来继承父类fulei</li>\n<li>单继承：一个子类只能继承一个父类，但是一个父类可以有多个子类</li>\n<li>子类会继承父类中所有的属性，私有属性和方法也可以被子类所继承，但是在外界不呢个直接访问或调用，父类在子类的内存地址上</li>\n</ol>\n</li>\n<li><p>super关键字</p>\n</li>\n</ol>\n<p>每个子类的每个构造方法第一行默认都会有一个super（）去调用父类中的无参构造方法因此创建子类对象时一定会先去创建父类对象</p>\n<p>如果父类没有无参构造方法，那么在每个子类中的每个构造方法第一行必须显示的通过super参数列表去调用父类中带参数的构造方法从而覆盖默认的super（），就不再去调用父类中的无参构造方法参数值时给创建出来的父类对象属性赋值了，但是子类对象会共用父类对象的属性，所以也相当于是给于类对象的属性赋值</p>\n<ol start=\"4\">\n<li><p>super的三种用法</p>\n<ol>\n<li><p>super参数列表</p>\n<p>调用父类中的构造方法，必须放在子类的构造方法的第一行</p>\n</li>\n<li><p>super.属性名，访问父类对象的属性</p>\n</li>\n<li><p>super.方法名，调用父类的实例方法</p>\n</li>\n</ol>\n</li>\n<li><p>重写Override</p>\n<ol>\n<li><p>重写的目的</p>\n<p>子类从父类中继承的方法不满足子类的需求，需要在子类中对该方法进行改写和扩展</p>\n</li>\n<li><p>重写的规则</p>\n<ol>\n<li>重写的方法必须和父类中方法的方法名和参数列表一致： 方法签名：方法名+参数列表</li>\n<li>重写的方法返回值类型必须和父类中方法一致或者父类中方法返回值类型的子类型、</li>\n<li>重写的方法修饰符必须和父类中方法一致或者比父类中方法修饰范围更大</li>\n<li>重写的方法不能比父类中的方法抛出更多更大的异常；</li>\n<li>重写的方法上面建议加上@Override注解，用于检测该方法是否正确重写了</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>重载Overload 和重写Override有什么区别</p>\n<ol>\n<li>重载是发生在同一个类中，多个方法之间同名不同参</li>\n<li>重写是发生在父类和子类之间，子类对父类中的方法进行改写，要求方法名和参数列表一致</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>多态</p>\n<p>多态指允许不同类的对象对同一消息做出响应即同一消息可以根据发送对象的不同而采用多种不同的行为方式</p>\n<ol>\n<li><p>什么是多态</p>\n<p>同一行为会因为执行对象的不同而产生不一样的结果，是对象多种表现形式的体现</p>\n</li>\n<li><p>多态存在的三个前提条件</p>\n<ol>\n<li><p>继承</p>\n</li>\n<li><p>方法重写</p>\n</li>\n<li><p>父类型引用可以指向子类型的对象</p>\n<p>在编译期间，引用是属于父类型的，在运行期间，会去调用子类中重写的方法。</p>\n<p>在编译期间，子类对象的引用是属于父类类型，只能调用在父类中已经定义过的方法，而不能调用子类中所持有的方法</p>\n</li>\n</ol>\n</li>\n<li><p>类型转换</p>\n<ol>\n<li><p>子类型转父类型</p>\n<p>向上类型转换，隐式类型转换，自动类型转换</p>\n<p>在编译期间和运行期间都不会报错，但是转成父类型后只能调用父类中已定义的方法</p>\n</li>\n<li><p>父类型转子类型</p>\n<p>向下类型转换，显式类型转换，强转类型转换</p>\n<p>在编译期间不会报错，在运行期间有可能会报ClassCastException类型转换异常，所以在强转之前需要通过instanceof关键字来进行判断</p>\n</li>\n</ol>\n</li>\n<li><p>instanceof关键字</p>\n<p>判断父类类型引用所指向的对象，是否属于子类类型，而不是判断引用本身的类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> animal <span class=\"keyword\">instanceof</span> Dog;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(f)&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;对象是Dog类型，可以强转&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;对象不是Dog类型,不能强转&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>static</p>\n<p>静态的，唯一的，属于类的，与类一起加载，被存储在方法区，被类中所有对象所共享的</p>\n<ol>\n<li><p>修饰类</p>\n<p>只能修饰内部类，不能修饰外部类</p>\n</li>\n<li><p>修饰变量</p>\n<p>类加载时初始化，只会初始化一次</p>\n<p>只能修饰静态成员变量，不能修饰局部变量，非静态成员变量创建对象时初始化，每创建一个对象就会初始化一次</p>\n<ol>\n<li>只能用于修饰成员变量静态成员变量，类变量属于类的，被类中所有的对象共享类加载时初始化，只会被初始化一次</li>\n<li>静态变量可以直接通过类名.变量名的方式来进行访问，在同一个类中如果没有同名的局部变量，那么类名可以省略不写</li>\n<li>静态变量也可以通过对象来进行访问，但是不建议，一个对象对静态变量的修改会影响到其他对象的访问</li>\n</ol>\n</li>\n<li><p>修饰方法</p>\n<ol>\n<li>静态方法：属于类的，被类中所有的对象共享，类加载时初始化只会初始化一次</li>\n<li>静态方法可以直接通过类名来进行调用，在同一个类中调用可以省略不写</li>\n<li>静态方法也可以通过对象来进行调用，但是不建议</li>\n<li>在同一个类中，静态方法可以直接访问，静态变量和调用静态方法，默认省略类名</li>\n<li>静态方法中不能直接访问实例变量和调用实例方法，因为静态方法中不能出现this如果要访问实例变量和调用实例方法必须要先创建对象，然后通过对象来访问和调用</li>\n</ol>\n<p>在静态方法中不能直接访问实例变量，因为实例变量默认通过this来进行访问，而静态方法中不能出现this，（this是指向当前对象，而静态方法可以通过类名来进行调用可以不通过对象来调用，类加载时机比创建对象要早，静态方法是随着类一起加载的，所以类加载时没有对象，this又必须要指向一个对象）</p>\n<p>访问实例变量必须要先创建实例对象</p>\n<p>在实例方法中可以直接调用实例方法和静态方法</p>\n</li>\n<li><p>修饰代码块</p>\n<ol>\n<li>属于类的，类加载时初始化，只会初始化一次</li>\n<li>一个类中可以同时定义多个静态代码块，类加载时从上往下依次初始化</li>\n<li>类什么时候加载<ol>\n<li>访问了类中的静态变量</li>\n<li>调用了类中静态方法</li>\n<li>创建了该类对象</li>\n<li>类中有main（）方法，执行了main()方法</li>\n<li>反射加载类</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>Final修饰符</strong></p>\n<ol>\n<li>final修饰类不可被继承</li>\n<li>final修饰变量，只能被赋一次值，不可再更改，也就是常量，常量名建议全大写<ol>\n<li>修饰成员变量，要么在定义时赋值，要么在定义时赋值，要么在构造方法中赋值，后续不可再更改这个值</li>\n<li>修饰局部变量，要么再定义时赋值，要么先定义后赋值，但是只能赋一次值，后续不可再更改，如果final修饰形参那么是在方法调用过程中赋值，在方法里面不能再更改该形参值</li>\n<li>修饰基本类型，值不可变，修饰引用类型地址值不可变，对象属性除去final修饰的属性值可变</li>\n</ol>\n</li>\n<li>final修饰方法，方法可以被继承，不能被重写</li>\n</ol>\n</li>\n<li><p><strong>抽象类</strong></p>\n<ol>\n<li><p>什么是抽象类</p>\n<p>当一个类中的实例不是具体存在的个体，没有足够的详细信息来描述这个类的对象时，就把这个类定义为抽象类，抽象类一般用于充当父类</p>\n</li>\n<li><p>抽象类的应用</p>\n<ol>\n<li>抽象类使用abstract来进行定义</li>\n<li>抽象类中可以定义实例变量，静态变量实例方法，静态方法</li>\n<li>抽象类中可以定义构造方法，但是不能创建对象，构造方法的作用是提供给予子类构造方法进行调用赋值的</li>\n</ol>\n</li>\n<li><p>抽象方法</p>\n<ol>\n<li>抽象方法使用abstract关键字来进行定义</li>\n<li>抽象方法只有方法声明没有方法体（没有后面的大括号）</li>\n<li>有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法</li>\n<li>子类继承抽象类后，必须重写抽象类中所有的抽象方法，否则子类也必须为一个抽象类</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>接口interface</strong></p>\n<ol>\n<li><p>接口是什么</p>\n<p>制定一个统一的标准和规范，其目的是为了实现程序解耦合（高内聚，低耦合）</p>\n</li>\n<li><p>接口的使用</p>\n<ol>\n<li>接口使用interface关键字进行定义</li>\n<li>接口中不能定义构造方法，也不能创建对象</li>\n<li>JDK1.7之前接口中只能定义静态常量和抽象方法，静态常量默认使用public static final修饰，抽象方法默认使用public abstract修饰</li>\n<li>一个实现类可以通过implement关键字实现一个接口，继承接口中所有的静态常量，必须要重写接口中所有的抽象方法</li>\n<li>一个实现类也可以同时实现多个接口，之间使用逗号隔开必须要重写所有接口中的所有抽象方法（多实现）</li>\n<li>接口和接口之间可以通过extends关键字互相继承，一个子接口可以同时继承多个父接口，拥有所有父接口中的静态常量和抽象方法（多层继承）</li>\n<li>一个类可以在继承一个父类的同时去实现多个接口</li>\n<li>JDK1.8之后接口新特性<ol>\n<li>静态方法：直接通过接口名来调用，不能被实现类所继承</li>\n<li>默认方法：在方法前面加上default关键字,实现类可以选择默认继承或重写</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>四个内部类</strong></p>\n<ol>\n<li><p>实例内部类</p>\n<ol>\n<li><p>位置：类的里面，其他方法的外面，没有static修饰</p>\n</li>\n<li><p>特点：可以直接访问外部类中所有成员变量</p>\n</li>\n<li><p>对象创建：必须要先创建外部类对象</p>\n<blockquote>\n<p>Outer.Inner inner &#x3D; new Outer().new Inner();</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>静态内部类</p>\n<ol>\n<li><p>位置：类的里面，其他方法的外面，有static修饰</p>\n</li>\n<li><p>特点：只能直接访问外部类中静态成员变量</p>\n</li>\n<li><p>对象创建：不依赖于外部类</p>\n<blockquote>\n<p>导包</p>\n<p>Inner inner &#x3D; new Inner();</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>局部内部类</p>\n<ol>\n<li>位置：在方法里面定义的类</li>\n<li>特点：能访问外部类中定义的所有成员变量，也能访问定义他的方法中的局部变量</li>\n<li>对象创建：只能在当前方法内部创建对象</li>\n</ol>\n</li>\n<li><p>匿名内部类</p>\n<ol>\n<li><p>位置：可以在方法里面定义，也可以在类里面方法外面定义</p>\n</li>\n<li><p>特点：没有类的声明，只有类体</p>\n</li>\n<li><p>对象创建：必须依赖于其父类来创建匿名内部类对象</p>\n<blockquote>\n<p>语法：父类型 引用  &#x3D; new 父类型（）{</p>\n<p>​\t匿名内部类类体，重写方法</p>\n<p>}</p>\n<p>父类型可以使普通类，抽象类或接口</p>\n</blockquote>\n<p>注意：</p>\n<ol>\n<li>内部类不一定是普通类，也可以是抽象类或接口</li>\n<li>内部类可以使用任意的权限访问修饰符</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>lambda表达式</p>\n<ol>\n<li><p>JDK1.8之后新增的语法特性，主要用于简化部分匿名内部类的写法</p>\n</li>\n<li><p>lambda表达式要求匿名内部类的父类必须是一个接口，而且接口的中的抽象方法有且仅有一个</p>\n</li>\n<li><p>添加注解查看接口是否lambda表达式条件————@Functional Interface</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda表达式的语法：</span><br><span class=\"line\">    （需要被重写的参数列表） - &gt;  &#123;重写过后的方法体&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>类与类之间的关系</strong></p>\n<ol>\n<li><p>依赖关系（use a）</p>\n</li>\n<li><p>关联关系（has a）</p>\n<p>一个类以成员变量的形式出现在另一个类中，这两个类之间平等关系</p>\n<ol>\n<li>单向关联</li>\n<li>双向关联</li>\n</ol>\n</li>\n<li><p>聚合关系（has a）</p>\n<p>一个类以成员变量的形式出现在另外一个类中，但是这两个类之间有整体和局部的关系</p>\n</li>\n<li><p>组合关系（contain a）</p>\n<p>一个类以成员变量的形式出现在另外一个类中，一个类的存在必须要依赖于另外一个类，这两个类的生命周期是相互关联的</p>\n</li>\n<li><p>继承关系（is a）</p>\n<p>一个子类继承一个父类</p>\n</li>\n<li><p>实现关系（like a）</p>\n<p>一个实现类实现一个接口</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h4 id=\"面向对象-1\"><a href=\"#面向对象-1\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>一、什么是面向对象</p>\n<p>​\toop: object oriented programming</p>\n<p>​\t人为抽象出来的一种编程模型，其本质是将一个复杂庞大的问题拆分为若干个小的问题，通过完成这些小的问题最终达到解决大问题的一种编程方式（分而治之）</p>\n<p>二、对象</p>\n<pre><code> 1. object对象，东西\n 2. 一切客观存在的事物都是对象\n 3. 对象的特点，每一个对象一定是独一无二存在的个体\n</code></pre>\n<p>​\t</p>\n<p>三、类 Class</p>\n<ol>\n<li><p>类是具有相同静态特征和相同动态行为的对象的集合</p>\n</li>\n<li><p>类是对象模板，对象是类的具体实例</p>\n<p>日常生活中：先有对象后有类</p>\n<p>程序代码中：先有类后有对象</p>\n</li>\n</ol>\n<p>四、属性Field（成员属性，实例变量）</p>\n<ol>\n<li>类中所有的对象所拥有的相同的静态特征（对象都有什么）</li>\n<li>属性的位置：类的里面，其他方法的外面</li>\n<li>如果在类中没有给属性赋值那么创建出来的对象属性会有默认值</li>\n<li>通过引用名，属性名来对对象的属性值进行访问和修改</li>\n</ol>\n<p>五、方法（Method）函数</p>\n<ol>\n<li>类中所有的对象所拥有的相同的动态行为（对象都能干什么）</li>\n<li>对象的方法不能使用static进行修饰</li>\n<li>通过引用名·方法名（参数列表）来对对象的方法进行调用</li>\n</ol>\n<p>六、引用</p>\n<ol>\n<li>引用类型的变量，存储在栈内存中，用于保存堆内存中对象的地址值（地址哈希值）也就是通过引用可以指向一个对象</li>\n<li>对象必须要通过引用才能进行操作，通过引用操作对象的属性和方法</li>\n<li>可以多个引用指向同一个对象，但是一个引用不能同时指向多个对象</li>\n<li>引用类型特殊值:null（空，不存在），任意类对象类型的引用都可以被赋值为null， 如果一个引用被赋值为null，那么通过该引用访问了对象的属性或调用了对象的方法就会报空指针异常</li>\n</ol>\n<p>七、构造方法Constructor（构造函数，构造器）</p>\n<ol>\n<li>构造方法是用于创建对象的方法，在创建对象时自动调用</li>\n<li>构造方法的特点<ol>\n<li>构造方法没有返回值类型，也不能写void</li>\n<li>构造方法的名称必须和类名一致</li>\n</ol>\n</li>\n<li>如果自己没有在类中定义构造方法，当前类中会偶一个默认的无参构造方法，如果我们自己定义了带参数的构造方法，那么当前类中就不再生成默认无参构造方法，如果此时我们还需要通过无参构造方法创建对象，就需要手动定义</li>\n<li>带参数的构造方法通常可以用于给对象的属性赋值</li>\n<li>一个类中可以定义多个构造方法互为重载关系</li>\n</ol>\n<p>八、this.</p>\n<ol>\n<li><p>this用于指向当前对象，调用当前方法的对象或者当前正在创建的对象，只能用于构造方法和实例方法中</p>\n</li>\n<li><p>this.属性名操作当前对象的属性</p>\n<ol>\n<li>当局部变量和成员变量属性重名时，以局部变量为优先，此时必须通过this.属性名来进行区分，访问当前对象属性</li>\n<li>如果在方法中没有和成员变量重名的局部变量，this.可以省略不写，属性前面默认会有this.</li>\n<li>局部变量<ol>\n<li>方法的形参</li>\n<li>定义在方法内部的变量范围为当前方法的内部，离开方法就回收了</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>this(参数列表)</p>\n<ol>\n<li>调用本类其他的构造方法，注意此调用只能放在构造方法的第一行具体调用那一个构造方法由参数来决定</li>\n</ol>\n</li>\n<li><p>this.方法名（参数列表）</p>\n<p>在实例方法中调用本类其他的实例方法，默认就是通过this,来进行调用的，this可以省略不写</p>\n</li>\n</ol>\n<p>九、权限访问修饰符</p>\n<p>主要用于修饰类，方法（所有的方法），成员变量（属性）用于限制他们在哪个范围内可见</p>\n<ol>\n<li><p>public</p>\n<p>公开的，当前项目下任意地方都可以访问</p>\n</li>\n<li><p>protected</p>\n<p>受保护的，只能在当前包或不同包的子类中访问</p>\n</li>\n<li><p>默认的(不写)</p>\n<p>只能在当前包下面访问</p>\n</li>\n<li><p>private</p>\n<p>私有的，只能在当前类中访问</p>\n</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>权限访问修饰符不能用于修饰局部变量，因为局部变量的范围只在当前方法内部有效</li>\n<li>修饰外部类时，只能使用public或默认修饰修饰</li>\n<li>在一个类文件可以同时定义多个类，但是只能有一个类是public修饰的，其余为默认修饰符，并且public修饰的类必须与源文件类名相同</li>\n</ol>\n<p>十、三大特性</p>\n<ol>\n<li><p>封装</p>\n<p>使用类的结构将属性数据和方法行为组织起来（装），可以实现隐藏具体的实现细节，防止外界随意访问和修改类中的数据（封装），增强数据的安全性。在对外界提供一个公开的访问方式</p>\n<ol>\n<li><p>属性私有化</p>\n<p>在属性前面加上private修饰符，防止类中的属性数据被外界随意访问修改</p>\n</li>\n<li><p>方法公开</p>\n<p>提供公开的setXxx方法</p>\n<p>提供公开的getXxx方法</p>\n</li>\n</ol>\n</li>\n<li><p>继承（extends）</p>\n<ol>\n<li><p>继承的目的</p>\n<p>继承是为了实现代码的复用，在分类中定义的属性和方法可以直接被子类继承</p>\n</li>\n<li><p>继承原则</p>\n<ol>\n<li>子类使用exrends关键字来继承父类fulei</li>\n<li>单继承：一个子类只能继承一个父类，但是一个父类可以有多个子类</li>\n<li>子类会继承父类中所有的属性，私有属性和方法也可以被子类所继承，但是在外界不呢个直接访问或调用，父类在子类的内存地址上</li>\n</ol>\n</li>\n<li><p>super关键字</p>\n</li>\n</ol>\n<p>每个子类的每个构造方法第一行默认都会有一个super（）去调用父类中的无参构造方法因此创建子类对象时一定会先去创建父类对象</p>\n<p>如果父类没有无参构造方法，那么在每个子类中的每个构造方法第一行必须显示的通过super参数列表去调用父类中带参数的构造方法从而覆盖默认的super（），就不再去调用父类中的无参构造方法参数值时给创建出来的父类对象属性赋值了，但是子类对象会共用父类对象的属性，所以也相当于是给于类对象的属性赋值</p>\n<ol start=\"4\">\n<li><p>super的三种用法</p>\n<ol>\n<li><p>super参数列表</p>\n<p>调用父类中的构造方法，必须放在子类的构造方法的第一行</p>\n</li>\n<li><p>super.属性名，访问父类对象的属性</p>\n</li>\n<li><p>super.方法名，调用父类的实例方法</p>\n</li>\n</ol>\n</li>\n<li><p>重写Override</p>\n<ol>\n<li><p>重写的目的</p>\n<p>子类从父类中继承的方法不满足子类的需求，需要在子类中对该方法进行改写和扩展</p>\n</li>\n<li><p>重写的规则</p>\n<ol>\n<li>重写的方法必须和父类中方法的方法名和参数列表一致： 方法签名：方法名+参数列表</li>\n<li>重写的方法返回值类型必须和父类中方法一致或者父类中方法返回值类型的子类型、</li>\n<li>重写的方法修饰符必须和父类中方法一致或者比父类中方法修饰范围更大</li>\n<li>重写的方法不能比父类中的方法抛出更多更大的异常；</li>\n<li>重写的方法上面建议加上@Override注解，用于检测该方法是否正确重写了</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>重载Overload 和重写Override有什么区别</p>\n<ol>\n<li>重载是发生在同一个类中，多个方法之间同名不同参</li>\n<li>重写是发生在父类和子类之间，子类对父类中的方法进行改写，要求方法名和参数列表一致</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>多态</p>\n<p>多态指允许不同类的对象对同一消息做出响应即同一消息可以根据发送对象的不同而采用多种不同的行为方式</p>\n<ol>\n<li><p>什么是多态</p>\n<p>同一行为会因为执行对象的不同而产生不一样的结果，是对象多种表现形式的体现</p>\n</li>\n<li><p>多态存在的三个前提条件</p>\n<ol>\n<li><p>继承</p>\n</li>\n<li><p>方法重写</p>\n</li>\n<li><p>父类型引用可以指向子类型的对象</p>\n<p>在编译期间，引用是属于父类型的，在运行期间，会去调用子类中重写的方法。</p>\n<p>在编译期间，子类对象的引用是属于父类类型，只能调用在父类中已经定义过的方法，而不能调用子类中所持有的方法</p>\n</li>\n</ol>\n</li>\n<li><p>类型转换</p>\n<ol>\n<li><p>子类型转父类型</p>\n<p>向上类型转换，隐式类型转换，自动类型转换</p>\n<p>在编译期间和运行期间都不会报错，但是转成父类型后只能调用父类中已定义的方法</p>\n</li>\n<li><p>父类型转子类型</p>\n<p>向下类型转换，显式类型转换，强转类型转换</p>\n<p>在编译期间不会报错，在运行期间有可能会报ClassCastException类型转换异常，所以在强转之前需要通过instanceof关键字来进行判断</p>\n</li>\n</ol>\n</li>\n<li><p>instanceof关键字</p>\n<p>判断父类类型引用所指向的对象，是否属于子类类型，而不是判断引用本身的类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> animal <span class=\"keyword\">instanceof</span> Dog;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(f)&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;对象是Dog类型，可以强转&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;对象不是Dog类型,不能强转&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>static</p>\n<p>静态的，唯一的，属于类的，与类一起加载，被存储在方法区，被类中所有对象所共享的</p>\n<ol>\n<li><p>修饰类</p>\n<p>只能修饰内部类，不能修饰外部类</p>\n</li>\n<li><p>修饰变量</p>\n<p>类加载时初始化，只会初始化一次</p>\n<p>只能修饰静态成员变量，不能修饰局部变量，非静态成员变量创建对象时初始化，每创建一个对象就会初始化一次</p>\n<ol>\n<li>只能用于修饰成员变量静态成员变量，类变量属于类的，被类中所有的对象共享类加载时初始化，只会被初始化一次</li>\n<li>静态变量可以直接通过类名.变量名的方式来进行访问，在同一个类中如果没有同名的局部变量，那么类名可以省略不写</li>\n<li>静态变量也可以通过对象来进行访问，但是不建议，一个对象对静态变量的修改会影响到其他对象的访问</li>\n</ol>\n</li>\n<li><p>修饰方法</p>\n<ol>\n<li>静态方法：属于类的，被类中所有的对象共享，类加载时初始化只会初始化一次</li>\n<li>静态方法可以直接通过类名来进行调用，在同一个类中调用可以省略不写</li>\n<li>静态方法也可以通过对象来进行调用，但是不建议</li>\n<li>在同一个类中，静态方法可以直接访问，静态变量和调用静态方法，默认省略类名</li>\n<li>静态方法中不能直接访问实例变量和调用实例方法，因为静态方法中不能出现this如果要访问实例变量和调用实例方法必须要先创建对象，然后通过对象来访问和调用</li>\n</ol>\n<p>在静态方法中不能直接访问实例变量，因为实例变量默认通过this来进行访问，而静态方法中不能出现this，（this是指向当前对象，而静态方法可以通过类名来进行调用可以不通过对象来调用，类加载时机比创建对象要早，静态方法是随着类一起加载的，所以类加载时没有对象，this又必须要指向一个对象）</p>\n<p>访问实例变量必须要先创建实例对象</p>\n<p>在实例方法中可以直接调用实例方法和静态方法</p>\n</li>\n<li><p>修饰代码块</p>\n<ol>\n<li>属于类的，类加载时初始化，只会初始化一次</li>\n<li>一个类中可以同时定义多个静态代码块，类加载时从上往下依次初始化</li>\n<li>类什么时候加载<ol>\n<li>访问了类中的静态变量</li>\n<li>调用了类中静态方法</li>\n<li>创建了该类对象</li>\n<li>类中有main（）方法，执行了main()方法</li>\n<li>反射加载类</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>Final修饰符</strong></p>\n<ol>\n<li>final修饰类不可被继承</li>\n<li>final修饰变量，只能被赋一次值，不可再更改，也就是常量，常量名建议全大写<ol>\n<li>修饰成员变量，要么在定义时赋值，要么在定义时赋值，要么在构造方法中赋值，后续不可再更改这个值</li>\n<li>修饰局部变量，要么再定义时赋值，要么先定义后赋值，但是只能赋一次值，后续不可再更改，如果final修饰形参那么是在方法调用过程中赋值，在方法里面不能再更改该形参值</li>\n<li>修饰基本类型，值不可变，修饰引用类型地址值不可变，对象属性除去final修饰的属性值可变</li>\n</ol>\n</li>\n<li>final修饰方法，方法可以被继承，不能被重写</li>\n</ol>\n</li>\n<li><p><strong>抽象类</strong></p>\n<ol>\n<li><p>什么是抽象类</p>\n<p>当一个类中的实例不是具体存在的个体，没有足够的详细信息来描述这个类的对象时，就把这个类定义为抽象类，抽象类一般用于充当父类</p>\n</li>\n<li><p>抽象类的应用</p>\n<ol>\n<li>抽象类使用abstract来进行定义</li>\n<li>抽象类中可以定义实例变量，静态变量实例方法，静态方法</li>\n<li>抽象类中可以定义构造方法，但是不能创建对象，构造方法的作用是提供给予子类构造方法进行调用赋值的</li>\n</ol>\n</li>\n<li><p>抽象方法</p>\n<ol>\n<li>抽象方法使用abstract关键字来进行定义</li>\n<li>抽象方法只有方法声明没有方法体（没有后面的大括号）</li>\n<li>有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法</li>\n<li>子类继承抽象类后，必须重写抽象类中所有的抽象方法，否则子类也必须为一个抽象类</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>接口interface</strong></p>\n<ol>\n<li><p>接口是什么</p>\n<p>制定一个统一的标准和规范，其目的是为了实现程序解耦合（高内聚，低耦合）</p>\n</li>\n<li><p>接口的使用</p>\n<ol>\n<li>接口使用interface关键字进行定义</li>\n<li>接口中不能定义构造方法，也不能创建对象</li>\n<li>JDK1.7之前接口中只能定义静态常量和抽象方法，静态常量默认使用public static final修饰，抽象方法默认使用public abstract修饰</li>\n<li>一个实现类可以通过implement关键字实现一个接口，继承接口中所有的静态常量，必须要重写接口中所有的抽象方法</li>\n<li>一个实现类也可以同时实现多个接口，之间使用逗号隔开必须要重写所有接口中的所有抽象方法（多实现）</li>\n<li>接口和接口之间可以通过extends关键字互相继承，一个子接口可以同时继承多个父接口，拥有所有父接口中的静态常量和抽象方法（多层继承）</li>\n<li>一个类可以在继承一个父类的同时去实现多个接口</li>\n<li>JDK1.8之后接口新特性<ol>\n<li>静态方法：直接通过接口名来调用，不能被实现类所继承</li>\n<li>默认方法：在方法前面加上default关键字,实现类可以选择默认继承或重写</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>四个内部类</strong></p>\n<ol>\n<li><p>实例内部类</p>\n<ol>\n<li><p>位置：类的里面，其他方法的外面，没有static修饰</p>\n</li>\n<li><p>特点：可以直接访问外部类中所有成员变量</p>\n</li>\n<li><p>对象创建：必须要先创建外部类对象</p>\n<blockquote>\n<p>Outer.Inner inner &#x3D; new Outer().new Inner();</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>静态内部类</p>\n<ol>\n<li><p>位置：类的里面，其他方法的外面，有static修饰</p>\n</li>\n<li><p>特点：只能直接访问外部类中静态成员变量</p>\n</li>\n<li><p>对象创建：不依赖于外部类</p>\n<blockquote>\n<p>导包</p>\n<p>Inner inner &#x3D; new Inner();</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>局部内部类</p>\n<ol>\n<li>位置：在方法里面定义的类</li>\n<li>特点：能访问外部类中定义的所有成员变量，也能访问定义他的方法中的局部变量</li>\n<li>对象创建：只能在当前方法内部创建对象</li>\n</ol>\n</li>\n<li><p>匿名内部类</p>\n<ol>\n<li><p>位置：可以在方法里面定义，也可以在类里面方法外面定义</p>\n</li>\n<li><p>特点：没有类的声明，只有类体</p>\n</li>\n<li><p>对象创建：必须依赖于其父类来创建匿名内部类对象</p>\n<blockquote>\n<p>语法：父类型 引用  &#x3D; new 父类型（）{</p>\n<p>​\t匿名内部类类体，重写方法</p>\n<p>}</p>\n<p>父类型可以使普通类，抽象类或接口</p>\n</blockquote>\n<p>注意：</p>\n<ol>\n<li>内部类不一定是普通类，也可以是抽象类或接口</li>\n<li>内部类可以使用任意的权限访问修饰符</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>lambda表达式</p>\n<ol>\n<li><p>JDK1.8之后新增的语法特性，主要用于简化部分匿名内部类的写法</p>\n</li>\n<li><p>lambda表达式要求匿名内部类的父类必须是一个接口，而且接口的中的抽象方法有且仅有一个</p>\n</li>\n<li><p>添加注解查看接口是否lambda表达式条件————@Functional Interface</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda表达式的语法：</span><br><span class=\"line\">    （需要被重写的参数列表） - &gt;  &#123;重写过后的方法体&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>类与类之间的关系</strong></p>\n<ol>\n<li><p>依赖关系（use a）</p>\n</li>\n<li><p>关联关系（has a）</p>\n<p>一个类以成员变量的形式出现在另一个类中，这两个类之间平等关系</p>\n<ol>\n<li>单向关联</li>\n<li>双向关联</li>\n</ol>\n</li>\n<li><p>聚合关系（has a）</p>\n<p>一个类以成员变量的形式出现在另外一个类中，但是这两个类之间有整体和局部的关系</p>\n</li>\n<li><p>组合关系（contain a）</p>\n<p>一个类以成员变量的形式出现在另外一个类中，一个类的存在必须要依赖于另外一个类，这两个类的生命周期是相互关联的</p>\n</li>\n<li><p>继承关系（is a）</p>\n<p>一个子类继承一个父类</p>\n</li>\n<li><p>实现关系（like a）</p>\n<p>一个实现类实现一个接口</p>\n</li>\n</ol>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cll54pw8r0001fswogladhsvn","category_id":"cll54pw8z0004fswo3iabhr04","_id":"cll54pw9a000hfswo1tcb2bb3"},{"post_id":"cll54pw8w0003fswoff2rhrzj","category_id":"cll54pw97000cfswogmdpayo0","_id":"cll54pw9i000ofswoe4pwb2m2"},{"post_id":"cll54pw920007fswofmg12udj","category_id":"cll54pw97000cfswogmdpayo0","_id":"cll54pw9l000tfswoe8xuduh6"},{"post_id":"cll54pw9j000qfswo7dwydwhk","category_id":"cll54pw8z0004fswo3iabhr04","_id":"cll54pw9o0010fswoaynz40ss"},{"post_id":"cll54pw940009fswoa7vf9h1a","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pw9q0015fswob4uof3bc"},{"post_id":"cll54pw9k000sfswo35ms2kxm","category_id":"cll54pw8z0004fswo3iabhr04","_id":"cll54pw9s0018fswo1en69dze"},{"post_id":"cll54pw9m000xfswoh026163j","category_id":"cll54pw8z0004fswo3iabhr04","_id":"cll54pw9t001dfswobtsl4xjm"},{"post_id":"cll54pw96000bfswocfbafswy","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pw9v001gfswoevyq867a"},{"post_id":"cll54pw98000ffswo1jklh8k9","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pw9x001lfswoh68kaq2c"},{"post_id":"cll54pw9t001cfswo4wzmby56","category_id":"cll54pw97000cfswogmdpayo0","_id":"cll54pw9y001ofswogkyt5ekj"},{"post_id":"cll54pw99000gfswo9g299jh1","category_id":"cll54pw9s0019fswod17n2lke","_id":"cll54pw9z001qfswo0jkyanfr"},{"post_id":"cll54pw9x001nfswo7m1baiuf","category_id":"cll54pw97000cfswogmdpayo0","_id":"cll54pwa5001xfswo09gecdba"},{"post_id":"cll54pw9d000kfswo916jghuk","category_id":"cll54pw9v001ifswodcykaqdx","_id":"cll54pwa70021fswo336g07iz"},{"post_id":"cll54pwa3001ufswo77gl18qt","category_id":"cll54pw9v001ifswodcykaqdx","_id":"cll54pwa70023fswobvr72vhd"},{"post_id":"cll54pw9g000mfswog8s45iq4","category_id":"cll54pw9z001rfswo2pmk8z0w","_id":"cll54pwa80026fswo3olqe3dq"},{"post_id":"cll54pw9o000zfswo4xmo7t1p","category_id":"cll54pwa6001yfswoh4mg7ntu","_id":"cll54pwa80028fswohkdq1lvw"},{"post_id":"cll54pw9q0014fswo91fudx4y","category_id":"cll54pwa70024fswod3tq2loo","_id":"cll54pwa9002dfswo7deg71vv"},{"post_id":"cll54pw9r0017fswo67m80h16","category_id":"cll54pwa6001yfswoh4mg7ntu","_id":"cll54pwaa002hfswogttbevq5"},{"post_id":"cll54pw9u001ffswo13pr9gbc","category_id":"cll54pwa70024fswod3tq2loo","_id":"cll54pwac002lfswo5i23bwyg"},{"post_id":"cll54pw9w001kfswob61xeb70","category_id":"cll54pwa70024fswod3tq2loo","_id":"cll54pwad002ofswoceluev46"},{"post_id":"cll54pw9y001pfswodd7ncppg","category_id":"cll54pwab002kfswohhtp1ybe","_id":"cll54pwae002sfswogp4ffmho"},{"post_id":"cll54pwa4001wfswobqx61unm","category_id":"cll54pwab002kfswohhtp1ybe","_id":"cll54pwaf002ufswo0tzi1vt8"},{"post_id":"cll54pwah002vfswoa2l4covh","category_id":"cll54pw97000cfswogmdpayo0","_id":"cll54pwal0031fswo1mq815gm"},{"post_id":"cll54pwai002wfswofp5r41m1","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pwam0033fswoefev2y67"},{"post_id":"cll54pwaj002yfswo3w3oblpi","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pwam0035fswo9wdw7c3w"},{"post_id":"cll54pwak0030fswo4blq2uq9","category_id":"cll54pw9h000nfswoa897b68l","_id":"cll54pwan0036fswodq9g3fif"}],"PostTag":[{"post_id":"cll54pw8r0001fswogladhsvn","tag_id":"cll54pw900005fswo5g15gscj","_id":"cll54pw98000efswo2tpyd93a"},{"post_id":"cll54pw8w0003fswoff2rhrzj","tag_id":"cll54pw97000dfswoa9iobu41","_id":"cll54pw9f000lfswofmle00zg"},{"post_id":"cll54pw920007fswofmg12udj","tag_id":"cll54pw97000dfswoa9iobu41","_id":"cll54pw9k000rfswo7aubb23c"},{"post_id":"cll54pw9j000qfswo7dwydwhk","tag_id":"cll54pw900005fswo5g15gscj","_id":"cll54pw9m000wfswo7dxt1vbv"},{"post_id":"cll54pw940009fswoa7vf9h1a","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pw9n000yfswo5sf807ct"},{"post_id":"cll54pw9k000sfswo35ms2kxm","tag_id":"cll54pw900005fswo5g15gscj","_id":"cll54pw9p0013fswo6bja6k6s"},{"post_id":"cll54pw9m000xfswoh026163j","tag_id":"cll54pw900005fswo5g15gscj","_id":"cll54pw9r0016fswobo60ba1o"},{"post_id":"cll54pw96000bfswocfbafswy","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pw9t001bfswoaow6ejne"},{"post_id":"cll54pw98000ffswo1jklh8k9","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pw9u001efswocxnj0d3e"},{"post_id":"cll54pw9t001cfswo4wzmby56","tag_id":"cll54pw97000dfswoa9iobu41","_id":"cll54pw9v001hfswog8wb72kw"},{"post_id":"cll54pw99000gfswo9g299jh1","tag_id":"cll54pw9s001afswodkxs7zx8","_id":"cll54pw9x001mfswo48vfac0h"},{"post_id":"cll54pw9x001nfswo7m1baiuf","tag_id":"cll54pw97000dfswoa9iobu41","_id":"cll54pwa3001tfswo8hn4e31d"},{"post_id":"cll54pw9d000kfswo916jghuk","tag_id":"cll54pw9w001jfswod4m3d9yp","_id":"cll54pwa4001vfswo7su4c53f"},{"post_id":"cll54pwa3001ufswo77gl18qt","tag_id":"cll54pw9w001jfswod4m3d9yp","_id":"cll54pwa60020fswodqh09u06"},{"post_id":"cll54pw9g000mfswog8s45iq4","tag_id":"cll54pwa0001sfswo3z561yvy","_id":"cll54pwa70022fswohvqfgkbz"},{"post_id":"cll54pw9o000zfswo4xmo7t1p","tag_id":"cll54pwa6001zfswo07vfglbm","_id":"cll54pwa80027fswo79qb604y"},{"post_id":"cll54pw9q0014fswo91fudx4y","tag_id":"cll54pwa70025fswo7zsza9x8","_id":"cll54pwa9002bfswo0hhe9hfp"},{"post_id":"cll54pw9r0017fswo67m80h16","tag_id":"cll54pwa6001zfswo07vfglbm","_id":"cll54pwaa002ffswoezs7g26m"},{"post_id":"cll54pw9u001ffswo13pr9gbc","tag_id":"cll54pwa70025fswo7zsza9x8","_id":"cll54pwab002jfswo57pydde7"},{"post_id":"cll54pw9w001kfswob61xeb70","tag_id":"cll54pwa70025fswo7zsza9x8","_id":"cll54pwac002nfswobe9500dc"},{"post_id":"cll54pw9y001pfswodd7ncppg","tag_id":"cll54pwac002mfswo0mj5e62u","_id":"cll54pwae002rfswo2yjc88nr"},{"post_id":"cll54pwa4001wfswobqx61unm","tag_id":"cll54pwad002qfswo14vu5aai","_id":"cll54pwae002tfswoho7h6zt7"},{"post_id":"cll54pwah002vfswoa2l4covh","tag_id":"cll54pw97000dfswoa9iobu41","_id":"cll54pwaj002xfswo0lr99k37"},{"post_id":"cll54pwai002wfswofp5r41m1","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pwak002zfswo7yf70bsi"},{"post_id":"cll54pwaj002yfswo3w3oblpi","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pwam0032fswodp5ta31z"},{"post_id":"cll54pwak0030fswo4blq2uq9","tag_id":"cll54pw9i000pfswo1rfgaszs","_id":"cll54pwam0034fswofqtk0loy"}],"Tag":[{"name":"中间件","_id":"cll54pw900005fswo5g15gscj"},{"name":"网络","_id":"cll54pw97000dfswoa9iobu41"},{"name":"Java","_id":"cll54pw9i000pfswo1rfgaszs"},{"name":"Linux","_id":"cll54pw9s001afswodkxs7zx8"},{"name":"前端","_id":"cll54pw9w001jfswod4m3d9yp"},{"name":"数据库","_id":"cll54pwa0001sfswo3z561yvy"},{"name":"框架","_id":"cll54pwa6001zfswo07vfglbm"},{"name":"计算机学习","_id":"cll54pwa70025fswo7zsza9x8"},{"name":"设计模式","_id":"cll54pwac002mfswo0mj5e62u"},{"name":"数据结构","_id":"cll54pwad002qfswo14vu5aai"}]}}