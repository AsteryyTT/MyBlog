---
title: 面向对象
date: 2023-01-07 11:18:57
tags: Java
categories: Java
cover: /img/images/computer3.jpg
---

## 面向对象

#### 面向对象

一、什么是面向对象

​	oop: object oriented programming

​	人为抽象出来的一种编程模型，其本质是将一个复杂庞大的问题拆分为若干个小的问题，通过完成这些小的问题最终达到解决大问题的一种编程方式（分而治之）



二、对象

 	1. object对象，东西
 	2. 一切客观存在的事物都是对象
 	3. 对象的特点，每一个对象一定是独一无二存在的个体

​	

三、类 Class

1. 类是具有相同静态特征和相同动态行为的对象的集合

2. 类是对象模板，对象是类的具体实例

   日常生活中：先有对象后有类

   程序代码中：先有类后有对象

四、属性Field（成员属性，实例变量）

1. 类中所有的对象所拥有的相同的静态特征（对象都有什么）
2. 属性的位置：类的里面，其他方法的外面
3. 如果在类中没有给属性赋值那么创建出来的对象属性会有默认值
4. 通过引用名，属性名来对对象的属性值进行访问和修改



五、方法（Method）函数

1. 类中所有的对象所拥有的相同的动态行为（对象都能干什么）
2. 对象的方法不能使用static进行修饰
3. 通过引用名·方法名（参数列表）来对对象的方法进行调用

六、引用

1. 引用类型的变量，存储在栈内存中，用于保存堆内存中对象的地址值（地址哈希值）也就是通过引用可以指向一个对象
2. 对象必须要通过引用才能进行操作，通过引用操作对象的属性和方法
3. 可以多个引用指向同一个对象，但是一个引用不能同时指向多个对象
4. 引用类型特殊值:null（空，不存在），任意类对象类型的引用都可以被赋值为null， 如果一个引用被赋值为null，那么通过该引用访问了对象的属性或调用了对象的方法就会报空指针异常

七、构造方法Constructor（构造函数，构造器）

1. 构造方法是用于创建对象的方法，在创建对象时自动调用
2. 构造方法的特点
   1. 构造方法没有返回值类型，也不能写void
   2. 构造方法的名称必须和类名一致
3. 如果自己没有在类中定义构造方法，当前类中会偶一个默认的无参构造方法，如果我们自己定义了带参数的构造方法，那么当前类中就不再生成默认无参构造方法，如果此时我们还需要通过无参构造方法创建对象，就需要手动定义
4. 带参数的构造方法通常可以用于给对象的属性赋值
5. 一个类中可以定义多个构造方法互为重载关系

八、this.

1. this用于指向当前对象，调用当前方法的对象或者当前正在创建的对象，只能用于构造方法和实例方法中

2. this.属性名操作当前对象的属性

   1. 当局部变量和成员变量属性重名时，以局部变量为优先，此时必须通过this.属性名来进行区分，访问当前对象属性
   2. 如果在方法中没有和成员变量重名的局部变量，this.可以省略不写，属性前面默认会有this.
   3. 局部变量
      1. 方法的形参
      2. 定义在方法内部的变量范围为当前方法的内部，离开方法就回收了

3. this(参数列表)

   1. 调用本类其他的构造方法，注意此调用只能放在构造方法的第一行具体调用那一个构造方法由参数来决定

4. this.方法名（参数列表）

   在实例方法中调用本类其他的实例方法，默认就是通过this,来进行调用的，this可以省略不写

九、权限访问修饰符

主要用于修饰类，方法（所有的方法），成员变量（属性）用于限制他们在哪个范围内可见

1. public

   公开的，当前项目下任意地方都可以访问

2. protected

   受保护的，只能在当前包或不同包的子类中访问

3. 默认的(不写)

   只能在当前包下面访问

4. private

   私有的，只能在当前类中访问

注意：

1. 权限访问修饰符不能用于修饰局部变量，因为局部变量的范围只在当前方法内部有效
2. 修饰外部类时，只能使用public或默认修饰修饰
3. 在一个类文件可以同时定义多个类，但是只能有一个类是public修饰的，其余为默认修饰符，并且public修饰的类必须与源文件类名相同

十、三大特性

1. 封装

   使用类的结构将属性数据和方法行为组织起来（装），可以实现隐藏具体的实现细节，防止外界随意访问和修改类中的数据（封装），增强数据的安全性。在对外界提供一个公开的访问方式

   1. 属性私有化
   
      在属性前面加上private修饰符，防止类中的属性数据被外界随意访问修改
   
   2. 方法公开
   
      提供公开的setXxx方法
   
      提供公开的getXxx方法
   
2. 继承（extends）

   1. 继承的目的

      继承是为了实现代码的复用，在分类中定义的属性和方法可以直接被子类继承
      
   2. 继承原则

      1. 子类使用exrends关键字来继承父类fulei
      2. 单继承：一个子类只能继承一个父类，但是一个父类可以有多个子类
      3. 子类会继承父类中所有的属性，私有属性和方法也可以被子类所继承，但是在外界不呢个直接访问或调用，父类在子类的内存地址上

   3. super关键字

   每个子类的每个构造方法第一行默认都会有一个super（）去调用父类中的无参构造方法因此创建子类对象时一定会先去创建父类对象

   如果父类没有无参构造方法，那么在每个子类中的每个构造方法第一行必须显示的通过super参数列表去调用父类中带参数的构造方法从而覆盖默认的super（），就不再去调用父类中的无参构造方法参数值时给创建出来的父类对象属性赋值了，但是子类对象会共用父类对象的属性，所以也相当于是给于类对象的属性赋值

   4. super的三种用法

      1. super参数列表

         调用父类中的构造方法，必须放在子类的构造方法的第一行

      2. super.属性名，访问父类对象的属性

      3. super.方法名，调用父类的实例方法

   5. 重写Override

      1. 重写的目的

         子类从父类中继承的方法不满足子类的需求，需要在子类中对该方法进行改写和扩展

      2. 重写的规则

         1. 重写的方法必须和父类中方法的方法名和参数列表一致： 方法签名：方法名+参数列表
         2. 重写的方法返回值类型必须和父类中方法一致或者父类中方法返回值类型的子类型、
         3. 重写的方法修饰符必须和父类中方法一致或者比父类中方法修饰范围更大
         4. 重写的方法不能比父类中的方法抛出更多更大的异常；
         5. 重写的方法上面建议加上@Override注解，用于检测该方法是否正确重写了

   6. 重载Overload 和重写Override有什么区别

      1. 重载是发生在同一个类中，多个方法之间同名不同参
      2. 重写是发生在父类和子类之间，子类对父类中的方法进行改写，要求方法名和参数列表一致

3. 多态

   多态指允许不同类的对象对同一消息做出响应即同一消息可以根据发送对象的不同而采用多种不同的行为方式

   1. 什么是多态

      同一行为会因为执行对象的不同而产生不一样的结果，是对象多种表现形式的体现

   2. 多态存在的三个前提条件

      1. 继承

      2. 方法重写

      3. 父类型引用可以指向子类型的对象

         在编译期间，引用是属于父类型的，在运行期间，会去调用子类中重写的方法。

         在编译期间，子类对象的引用是属于父类类型，只能调用在父类中已经定义过的方法，而不能调用子类中所持有的方法

   3. 类型转换

      1. 子类型转父类型

         向上类型转换，隐式类型转换，自动类型转换

         在编译期间和运行期间都不会报错，但是转成父类型后只能调用父类中已定义的方法

      2. 父类型转子类型

         向下类型转换，显式类型转换，强转类型转换

         在编译期间不会报错，在运行期间有可能会报ClassCastException类型转换异常，所以在强转之前需要通过instanceof关键字来进行判断

   4. instanceof关键字

      判断父类类型引用所指向的对象，是否属于子类类型，而不是判断引用本身的类型

      ```java
      Animal animal = new Dog();
      boolean f = animal instanceof Dog;
      if(f){
      	System.out.println("对象是Dog类型，可以强转")
      }else{
      	System.out.println("对象不是Dog类型,不能强转")
      }
      ```

4. static

   静态的，唯一的，属于类的，与类一起加载，被存储在方法区，被类中所有对象所共享的

   1. 修饰类

      只能修饰内部类，不能修饰外部类

   2. 修饰变量

      类加载时初始化，只会初始化一次

      只能修饰静态成员变量，不能修饰局部变量，非静态成员变量创建对象时初始化，每创建一个对象就会初始化一次

      1. 只能用于修饰成员变量静态成员变量，类变量属于类的，被类中所有的对象共享类加载时初始化，只会被初始化一次
      2. 静态变量可以直接通过类名.变量名的方式来进行访问，在同一个类中如果没有同名的局部变量，那么类名可以省略不写
      3. 静态变量也可以通过对象来进行访问，但是不建议，一个对象对静态变量的修改会影响到其他对象的访问
   
   3. 修饰方法
   
      1. 静态方法：属于类的，被类中所有的对象共享，类加载时初始化只会初始化一次
      2. 静态方法可以直接通过类名来进行调用，在同一个类中调用可以省略不写
      3. 静态方法也可以通过对象来进行调用，但是不建议
      4. 在同一个类中，静态方法可以直接访问，静态变量和调用静态方法，默认省略类名
      5. 静态方法中不能直接访问实例变量和调用实例方法，因为静态方法中不能出现this如果要访问实例变量和调用实例方法必须要先创建对象，然后通过对象来访问和调用
   
      在静态方法中不能直接访问实例变量，因为实例变量默认通过this来进行访问，而静态方法中不能出现this，（this是指向当前对象，而静态方法可以通过类名来进行调用可以不通过对象来调用，类加载时机比创建对象要早，静态方法是随着类一起加载的，所以类加载时没有对象，this又必须要指向一个对象）
   
      访问实例变量必须要先创建实例对象
   
      在实例方法中可以直接调用实例方法和静态方法
   
   4. 修饰代码块
   
      1. 属于类的，类加载时初始化，只会初始化一次
      2. 一个类中可以同时定义多个静态代码块，类加载时从上往下依次初始化
      3. 类什么时候加载
         1. 访问了类中的静态变量
         2. 调用了类中静态方法
         3. 创建了该类对象
         4. 类中有main（）方法，执行了main()方法
         5. 反射加载类
   
5. **Final修饰符**

   1. final修饰类不可被继承
   2. final修饰变量，只能被赋一次值，不可再更改，也就是常量，常量名建议全大写
      1. 修饰成员变量，要么在定义时赋值，要么在定义时赋值，要么在构造方法中赋值，后续不可再更改这个值
      2. 修饰局部变量，要么再定义时赋值，要么先定义后赋值，但是只能赋一次值，后续不可再更改，如果final修饰形参那么是在方法调用过程中赋值，在方法里面不能再更改该形参值
      3. 修饰基本类型，值不可变，修饰引用类型地址值不可变，对象属性除去final修饰的属性值可变
   3. final修饰方法，方法可以被继承，不能被重写
   
6. **抽象类**

   1. 什么是抽象类

      当一个类中的实例不是具体存在的个体，没有足够的详细信息来描述这个类的对象时，就把这个类定义为抽象类，抽象类一般用于充当父类

   2. 抽象类的应用

      1. 抽象类使用abstract来进行定义
      2. 抽象类中可以定义实例变量，静态变量实例方法，静态方法
      3. 抽象类中可以定义构造方法，但是不能创建对象，构造方法的作用是提供给予子类构造方法进行调用赋值的

   3. 抽象方法

      1. 抽象方法使用abstract关键字来进行定义
      2. 抽象方法只有方法声明没有方法体（没有后面的大括号）
      3. 有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法
      4. 子类继承抽象类后，必须重写抽象类中所有的抽象方法，否则子类也必须为一个抽象类

7. **接口interface**

   1. 接口是什么

      制定一个统一的标准和规范，其目的是为了实现程序解耦合（高内聚，低耦合）
      
   2. 接口的使用
   
      1. 接口使用interface关键字进行定义
      2. 接口中不能定义构造方法，也不能创建对象
      3. JDK1.7之前接口中只能定义静态常量和抽象方法，静态常量默认使用public static final修饰，抽象方法默认使用public abstract修饰
      4. 一个实现类可以通过implement关键字实现一个接口，继承接口中所有的静态常量，必须要重写接口中所有的抽象方法
      5. 一个实现类也可以同时实现多个接口，之间使用逗号隔开必须要重写所有接口中的所有抽象方法（多实现）
      6. 接口和接口之间可以通过extends关键字互相继承，一个子接口可以同时继承多个父接口，拥有所有父接口中的静态常量和抽象方法（多层继承）
      7. 一个类可以在继承一个父类的同时去实现多个接口
      8. JDK1.8之后接口新特性
         1. 静态方法：直接通过接口名来调用，不能被实现类所继承
         2. 默认方法：在方法前面加上default关键字,实现类可以选择默认继承或重写
   
8. **四个内部类**

   1. 实例内部类

      1. 位置：类的里面，其他方法的外面，没有static修饰

      2. 特点：可以直接访问外部类中所有成员变量

      3. 对象创建：必须要先创建外部类对象

         > Outer.Inner inner = new Outer().new Inner();

   2. 静态内部类
   
      1. 位置：类的里面，其他方法的外面，有static修饰
   
      2. 特点：只能直接访问外部类中静态成员变量
   
      3. 对象创建：不依赖于外部类
   
         > 导包
         >
         > Inner inner = new Inner();
   
   3. 局部内部类
   
      1. 位置：在方法里面定义的类
      2. 特点：能访问外部类中定义的所有成员变量，也能访问定义他的方法中的局部变量
      3. 对象创建：只能在当前方法内部创建对象
   
   4. 匿名内部类
   
      1. 位置：可以在方法里面定义，也可以在类里面方法外面定义
   
      2. 特点：没有类的声明，只有类体
   
      3. 对象创建：必须依赖于其父类来创建匿名内部类对象
   
         > 语法：父类型 引用  = new 父类型（）{
         >
         > ​	匿名内部类类体，重写方法
         >
         > }
         >
         > 父类型可以使普通类，抽象类或接口
   
         注意：
   
         1. 内部类不一定是普通类，也可以是抽象类或接口
         2. 内部类可以使用任意的权限访问修饰符
   
   5. lambda表达式
   
      1. JDK1.8之后新增的语法特性，主要用于简化部分匿名内部类的写法
   
      2. lambda表达式要求匿名内部类的父类必须是一个接口，而且接口的中的抽象方法有且仅有一个
   
      3. 添加注解查看接口是否lambda表达式条件————@Functional Interface
   
         ```java
         lambda表达式的语法：
             （需要被重写的参数列表） - >  {重写过后的方法体}
         ```
   
9. **类与类之间的关系**

   1. 依赖关系（use a）
   
   2. 关联关系（has a）
   
      一个类以成员变量的形式出现在另一个类中，这两个类之间平等关系
   
      1. 单向关联
      2. 双向关联
   
   3. 聚合关系（has a）
   
      一个类以成员变量的形式出现在另外一个类中，但是这两个类之间有整体和局部的关系
   
   4. 组合关系（contain a）
   
      一个类以成员变量的形式出现在另外一个类中，一个类的存在必须要依赖于另外一个类，这两个类的生命周期是相互关联的
   
   5. 继承关系（is a）
   
      一个子类继承一个父类
   
   6. 实现关系（like a）
   
      一个实现类实现一个接口

