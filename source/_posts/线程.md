---
title: 线程Thread
date: 2023-01-15 11:18:57
tags: Java
categories: Java
cover: /img/images/computer4.jpg
---

# 线程Thread

### 一、什么是进程

​	进程（Process）：操作系统上一个正在运行中的程序，进程会拥有当前程序的所有资源

​	线程（Thread）：进程内部的一个执行功能单元，每个线程都会有自己独立的一块内存空间，一个进程内部会有一到多个线程组成，进程只是拥有程序的资源，而线程是负责获取资源来执行具体任务的，进程内部的资源会被当前进程内所有线程共享

### 二、多线程的执行方式

##### **并发（concurrent）**

​	多线程默认是并发执行

​	操作系统会将时间片划分为很多个时间点，在每个时间点上只允许一个线程获取CPU，并进入CPU中执行他的任务，执行一段时间后就退出CPU，下一个线程再获得CPU进入执行，依次类推，因此为时间被划分足够细，切换足够快所以从宏观上看是多个线程同时进行，而微观上看轮流切换执行，这种现象叫并发，并发并不是真正意义上的同时

##### 并行(parlen)

​	并行只会出现多核CPU，一个CPU再一个时间段内只能干一件事，但是多个CPU就可以再 一个时间段内干多件事，这个就是真正意义上的同时

##### 多线程并发的优点

​	优点：提升系统性能和工作效率

​	缺点：多线程对同一资源进行操作时，可能会发生并发问题导致数据不安全，可以通过加锁解决

### 三、线程的创建方式

##### 继承

​	继承Thread类

	1. 写一个线程类继承Thread类
	2. 重写run（）方法，代表线程所要执行的具体任务是什么
	3. 创建线程实例
	4. 调用start（）方法启动线程

##### 实现Runnable接口

	1. 写一个任务类实现Runnable接口，该类实例代表线程所要执行的任务对象
	2. 重写run（）方法，代表执行的具体任务是什么
	3. 创建任务实例
	4. 创建一个线程实例，将任务实例作为参数传给线程实例
	5. 调用start（）方法启动线程

> 推介使用：实现Runnable接口方式创建线程
>
> 1. 解决Java中单继承带来的弊端
> 2. 可以让多个线程来执行同一个任务
> 3. 将线程实例和任务实例解耦合

> 注意：线程调用了start（)方法后，不会立即获得CPU，而是处于一个就绪（准备）状态，等待操作系统为其分配时间片，线程只有获得了时间片才会进入CPU中执行他的任务，也就是执行run（）方法中的代码

### 四、线程的主要方法

1. run()

   线程获得CPU之后，执行的任务

2. start()

   启动线程，让线程处于就绪状态

3. Thread static currentThread()

   获取当前线程实例

4. void setName(String name)/String getName()

   获取/修改线程名称，线程默认名称：主线程：main，其他工作线程：Thread-0/Thread-1

5. long getId()

   获取线程Id,主线程id：1，其他工作线程，10，11，12....

6. static int activeCount()

   获取当前线程所属线程组中活动的线程数

7. void setPriority(int priority)/getProiority()

   获取/修改线程的优先级

   线程默认优先级：5，最高优先级：10，最低优先级：1

   > 优先级是改善线程获取CPU的概率

8. setDaemon(True)

   将线程设置后守护线程(后台线程，用户线程，精灵线程)那么其他的线程就会自动变为前台线程，一个进程最多只允许一个守护线程当其他所有前台线程都结束了，守护线程也就结束了必须要再启动线程之前设置

9. Thread.sleep(long millis)

   线程休眠,处于运行状态的线程如果调用了sleep()休眠方式，就会立即退出CPU,处于阻塞状态，在此期间线程是无法再次获得CPU的，休眠结束线程又重写回到就绪状态，等待操作系统重新为其分配时间片，处于休眠状态的线程可以再别的线程中通过调用interrupt（）方法进行唤醒
   
10. void join（）

   插入式线程

   将一个线程插入到另外一个线程前面去执行，被插入的线程就会处于阻塞状态，在此期间式无法获得CPU的，必须等待插入的线程在CPU中彻底执行完成任务退出CPU之后，被插入的线程才会结束阻塞状态进入就绪状态

### 五、线程的状态(生命周期)

1. 新建状态

   线程实例刚被创建出来

2. 就绪状态

   等待操作系统为其分配时间片

   1. 新建状态的线程调用start()方法
   2. 阻塞状态的线程阻塞结束

3. 运行状态

   就绪状态获得了操作系统为其分配的时间片，进入CPU中执行他的任务，也就是调用run（）方法

4. 阻塞状态

   运行状态的线程退出CPU处于等待状态，在阻塞期间是无法获得CPU的

   1. 线程休眠
   2. 线程被插入
   3. 线程wait()/await()等待
   4. IO阻塞

5. 死亡状态

   线程执行完了他的任务，就会被操作系统回收

### 六、线程同步与协作

1. 异步和同步的概念

   **异步**：一个进程内部的多个线程之间默认是异步并发执行的，轮流切换时间片来执行任务，宏观上看同时在进行

   **同步**：因为多线程默认是异步并发执行的，所以如果有多个线程对同一资源(共享变量)进行操作时，就有可能会引发线程并发不安全问题，所以这时候就需要多线程，有先后顺序的来执行，这个就叫线程同步（串发）

2. 如何将线程默认的异步操作改为同步操作

   Java中提供了一种锁机制来支持多线程同步，保证共享资源的安全性

   1. Synchronized同步锁
      1. 同步代码块
      
         若干个线程过来之后，只会有一个线程先获得同步锁对象，然后进入同步代码块中执行代码，同时将这一块代码锁死在该线程执行期间，其他线程均处于阻塞状态，无法获得CPU，只要等当前线程执行完了同步代码块中所有代码之后，才会释放同步锁，其他处于阻塞状态的状态进入到就绪状态从而来枪已经释放的同步锁，进入同步代码块中执行任务，未抢到的锁的线程依然处于阻塞状态，依次类推，多线程就可以按顺序先后执行
      
         ```java
         synchronized(同步锁对象){
         	//需要进行同步的代码
         }
         ```
      
      2. 同步方法
      
         多线程在调用这个方法时，只有一个线程会先获得同步锁对象，获得同步锁的线程会先来调用该方法，在调用期间其他线程也是处于阻塞状态，等该线程调用完方法释放同步锁后，其他线程才能获得同步锁来调用方法
      
         ```java
         修饰符 synchronized 返回值类型 方法名(参数列表){
         	//需要进行同步的代码
         }
         ```
      
      3. 同步锁对象的选择
      
         任意引用类型对象都可以来当做同步锁，但是必须保证多个线程看到的是同一个锁对象
      
         实例方法同步锁对象默认为this
      
         静态方法同步锁对象默认为当前类(类名.class)
         
      4. synchronized的可重入性
      
         可重入锁，也叫递归锁
      
         如果一个线程在外部已经获得改锁，那么进入到线程内部的后可以继续获得该锁，而不会因为之前的锁没有释放无法获得这把锁，可重入锁可以在一定程度上避免线程死锁
      
   2. ReentrantLock可重入锁
   
      1. ReentrantLock实现线程重入锁实现线程同步
      
         1. lock（)获得锁，获取不到会阻塞
         2. unlock()释放锁
         3. trylock()尝试获得锁，获得True，未获得False,不会阻塞
         4. lockInterruptibly（）获得锁，获取不到会阻塞，但是阻塞会被打断
      
         ```java
         为了确保无论如何都会被释放：
         try{
         	//获得锁
         	//需要进行同步的代码
         }finally{
         	//释放锁
         }
         ```
      
      2. ReentrantLock实现锁的可重入性
      
         synchronized锁和ReentrantLock锁都是可重入锁
      
      3. ReentrantLock获得锁的过程
      
         1. 当多个线程来获得同一个锁对象时，只有一个线程能获得锁对象，其他未获得所得线程会被添加到等待队列中，先就绪的线程就会被添加到列的头部，等上一个获得锁的线程执行完成任务释放锁之后，就会从队列的取出，一个线程再来获取锁
      
            > 注意：线程只有调用Starrt()方法会处于就绪状态，但是先调用start（）方法的线程不一定就会先就绪
      
            **非公平锁**：创建对象不带参数或参数为false，创建的就是非公平锁，持有锁的线程再执行完任务释放的一瞬间，如果有非队列中的线程过来获取锁，那么该线程就能立即获得锁，所以如果一直非队列线程过来获得锁，就会造成队列中的线程一直处于等待状态（饥饿等待），但是非公平锁效率高，因为不需要频繁的往等待的队列中添加和取出线程
      
            **公平锁**：创建对象时带的参数为true，则代表创建的时公平锁，严格按照FIFO先进先出原则，从队列中依次取出线程来获得锁执行任务，即使再持有锁的线程执行完任务释放锁的一瞬间，有非队列线程过来也依然会被加入到队列的末尾中，不会造成饥饿等待，效率比较低，因为需要频繁的往队列添加和取出线程
      
      4. 读写锁
      
         多线程在对同一资源进行操作时，可以使用读写锁
      
         1. 读锁和读锁之间是线程共享的
         2. 写锁和写锁之间是线程互斥的
         3. 读锁和写锁之间是线程互斥的
   
3. 线程间协作(等待)的概念

   1. 多线程在同步了的基础上，必须按照一个排好的顺序来获取CPU执行任务

   2. 怎样实现线程间协作

      1. 使用synchronized同步锁，可以借助Object类中wait()/notify()/notifyAll()三个方法来实现线程间协作

      2. wait()

         调用该方法的线程会释放已经获得的锁然后进入等待状态，一直等到其他具备相同锁的线程调用notify()或notifyAll()方法后才会结束等待进入就绪状态

      3. notify()

         调用该方法的线程会通知其他具备相同锁的线程结束等待，从而进入就绪状态，等到执行完同步代码块后才会释放同步锁，notify()方法本身是不会释放同步锁的，该方法一般写同步代码块最后面

      4. 使用ReentrantLock可重入锁实现线程间协作

         通过ReentrantLock来获取一个Condition对象，然后借助Condition对象中的await()/signal()/signalAll()三个方法

      > 注意：
      >
      > 1. 以上三个方法必须在lock()和unlock()两个方法之间
      > 2. 方法必须有condition对象来进行调用
      > 3. 多线程间的condition对象必须是同一个

### 七、线程池

​	线程池(ThreadPool线程的第三种创建方式)

1. **线程池的概念**

   用于创建和管理多个线程的容器对象，当我们的程序需要线程时可以直接从池中取出，当执行完任务后，将线程返回到池中，让线程得到复用，避免频繁的创建和销毁，从而节省系统的开销

2. **线程池的创建**

   ```java
   ThreadPoolExecutor pool = new ThreadPoolExecutor(
                   int corePoolSize   核心线程数,
                   int maximumPoolSize 最大线程数,
                   long keepAliveTime 超时(空闲，活跃)时间,
                   TimeUnit unit 时间单位,
                   BlockingQueue<Runnable> workQueue 任务队列,
                   ThreadFactory threadFactory 线程工厂,
       			RejectedExecutionHandler handler 拒绝执行处理;
   )
   ```

3. **拒绝策略**

   1、**AbortPolicy**
      拒绝执行新的任务，并抛出RejectedExecutionException异常
   2、**CallerRunPolicy**
      如果线程池已关闭，直接丢弃该任务，
      如果线程池没有关闭，不会使用线程池中的线程，
      也不会将其加入到任务队列中，而是让当前线程直接来调用run()方法，
      相当于没有创建额外的线程
   3、**DiscardOldestPolicy**
      如果线程池已关闭，直接丢掉该任务
      入宫线程没有关闭，将任务队列存在最久的任务丢掉，
      并将新的任务加入到任务队列中
   4、**DiscardPolicy**
      直接丢掉新的任务，但是不会抛出异常

4. Java**自带的线程池**

   1. 创建单线程的线程池

      只有一个线程，不允许创建非核心线程      

      ```java
      ExecutorService es = Executors.newSingleThreadExecutor();
      ```

   2. 创建固定数量线程的线程池

      传入的参数既是核心线程数也是最大线程数，不允许创建非核心线程

      ```java
      ExecutorService es = Executors.newFixedThreadPool(3);
      ```

   3. 创建可缓存线程池

      内部没有核心线程，所有的线程都是非核心线程
      所有的非核心线程都是超过60s处于空闲状态就会被回收

      ```java
      ExecutorService es = Executors.newCachedThreadPool();
      ```

   4. 创建周期性线程池

      传入的参数为核心线程数，队列为延迟队列

      ```java
      ScheduledExecutorService es =Executors.newScheduledThreadPool(3);
      ```

      线程池主要方法

      1. **execute**(Ruunable task)

         将任务交给线程池来执行

         线程池会自动获取出空闲的线程来执行该任务

      2. **allowCoreThreadTimeOut**()

         允许核心线程超时

      3. **es.shutdownNow**();

         立即关闭，可能会导致线程池中还没有执行完毕

      4. **es.shutdown**();

         安全关闭，必须等待线程池中所有线程都执行完成任务后才会关闭

      5. **es.schedule**(Runnable command,long delay, TimeUnit unit);

         周期性线程池执行周期任务

      6. **es.scheduleAtFixedRate**

         Runnable command, 要执行的任务
         long initialDelay, 第一次执行任务的延迟时间
         long period, 两次执行之间的间隔时间
         TimeUnit unit 时间单位
         任务的执行时间超过了间隔时间，那么在一次任务，执行完成后就会立即执行下一次任务如果没有超过间隔时间那么就会在指定间隔之后才会执行下一个任务

      7. **es.scheduleWithFixedDelay**

         不管任务的执行时间是否超过间隔时间,必须等待本次任务执行完成后,再间隔指定时间才会去执行下一次的任务
      
   5. **Callable**
   
      实现Callable接口的实现类为线程要执行的任务
   
      Callable使用步骤
   
      1. 写一个类实现Callable接口，并指定泛型，泛型为任务执行完成后需要得到的结果类型
      2. 重写Call()方法，该方法所要执行的任务，相当于是Runnable中的run()方法
      3. 通过线程来执行任务
         1. 创建Callable实现实例，并通过FutureTask来封装该实例
         2. 创建线程来执行FutureTask来执行实例
         3. 调用FutureTask的get()方法 来获取任务执行结果
      4. 通过线程池来执行任务
         1. 创建Callable实现实例，创建线程池
         2. 调用线程池的submit()方法执行Callable任务实例，返回一个Future()
         3. 调用Future类的get()方法来获取任务执行结果

### 八、线程内存模型

##### JMM:Java Memory Model

主要用于描述和定义Java程序中各种变量的访问和操作规则，以及在JVM中如何将变量存储到内存以及从内存读出的过程

1. 多线程访问共享变量的规则
   1. JVM会给每个线程更配一个自己独立的内存空间，同时也会有一个自己的主内存空间
   2. 多线程间的共享变量会存在主内存空间
   
2. 线程的特性
   1. 原子性
   2. 可见性
   
   JMM:Java Memory Model
         主要用于描述和定义Java程序中各种变量的访问和操作规则,
         以及在Jvm中如何将变量存储到内存以及从内存读出的过程
   
         1、多线程访问共享变量的规则
            1>Jvm会给每个线程分配一个自己独立的内存空间,
              同时也会有一个自己的主内存空间
            2>多线程间的共享变量会存储在主内存空间
            3>线程对共享变量的操作,需要从
              主内存中拷贝一份该变量的副本到自己独立的工作
              内存中进行,修改完成后将该变量的值再重新拷贝到主内存中,
              线程不能直接操作主内存的共享变量值
            4>不同线程之间无法直接访问其他线程工作内存中的变量,
              线程间变量值的传递必须通过主内存来进行完成
   
   
   ​     
   ​       2、线程的特性:
   ​           1>原子性(不可分割)
   ​             一系列的操作要么都执行,要么都不执行,不可再分割,
   ​             比如从主内存中读取共享变量的值,在工作内存中修改后,
   ​             再刷新回主内存,这些操作不可分割,
   ​             线程与线程之间相互独立,在一个时间段内
   ​    只允许一个线程进入cpu执行任务操作共享变量,
   ​    synchronized同步锁和ReentrantLock可重入锁
   ​    都可以实现线程原子性
   ​    
   ​           2>可见性
   ​             1)一个线程对共享变量的操作,能够及时的被其他线程所看到
   ​             2)可见性实现原理
   ​                1)每次操作该变量时都会将主内存中
   ​      共享变量拷贝到工作内存
   ​    2)每次在工作内存中操作完该变量时,
   ​      都会把值同步到主内存中
   ​       3)Synchronized,ReentrantLock以及
   ​      volatile都可以实现线程可见性
   ​    
   ​             3)synchronize实现可见性原理
   ​                1>获取同步锁
   ​                2>清空工作内存中的副本值
   ​                3>从主内中拷贝共享变量的最新值到自己的工作内存中
   ​                4>在工作内存中执行代码
   ​                5>将更改之后共享变量的值刷新到主内存
   ​                6>释放同步锁
   ​                7>synchronized既能保证原子性也能保证可见性
   ​    
   ​             4)volatile实现可见性原理
   ​                volatile只能保证共享变量的可见性,但不能保证原子性
   ​                当线程需要去修改volatile变量值:
   ​                1>先从主内存中读取volatile共享变量的最新值到工作内存
   ​                2>再操作工作内存volatile变量的副本值
   ​                3>再将改变之后的副本值从工作内存刷新到主内存
   ​    
   ​                 volatile使用场景:线程多次修改的共享值之间不存在依赖关系
   ​    
   ​              5)synchronized和volatile区别
   ​                1>volatile不需要加锁,比synchronized更加轻量级,
   ​                  不会阻塞线程
   ​                2>synchronized既保证可见性又保证原子性,
   ​                  而volatile只保证了可见性,不保证原子性
   ​                3>synchronized比validate使用场景更多,范围更广
   ​    
              3>有序性(非指令重排性):让JVM在解释执行字节码文件时,
          严格按照字节码中的顺序来执行指令,不要进行重排序
   
   
     4、指令重排序
      1>重排序概念
        代码的编写顺序和最终执行顺序不一致
        
      2>重排序目的
        编译器或处理器做优化,提高程序的执行性能,哪个指令先来,
        先执行哪个
   
      2.1>编译器优化重排序
        2.2>处理器指令级并行重排序或内存系统的重排序
            源代
   
   2.1>编译器优化重排序
        2.2>处理器指令级并行重排序或内存系统的重排序
            源代码 -> 编译器优化的重排 -> 
         指令并行的重排 -> 内存系统的重排 -> 最终执行指令
   
      3>重排序导致后果
        3.1>单线程重排序会遵循as-if-serial原则,
          也就是会考虑数据依赖问题,
          无论如何重排序,程序最终执行结果必须
          与代码顺序执行结果一致
   
      3.2>多线程并发情况下,指令重排序可能会导致
           最终结果与预期结果不一致
   
      3.3>synchronized和volatile都能禁止指令重排序
          volatile:通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化,
          volatile的写和读的时候，加入屏障，防止出现指令重排的
        
        线程A:
        int a = 10;
        int b = 20;
        
        线程B:
        int c = a+b;
          
        Object obj = new Object();
        创建对象过程
        1>初始化一块内存空间
        2>给成员变量赋初始值
        3>将内存空间地址赋值给引用
       
        if(obj!=null){
           //执行代码 
        }

